"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[6179],{1067:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"architecture-practices/architecture-execution/environment-promotion","title":"Environment Promotion Guide","description":"This guide provides comprehensive environment promotion strategies for NestJS microservices and Next.js microfrontend applications, covering environment-specific configurations, automated promotion pipelines, and progressive delivery across development, staging, and production environments.","source":"@site/docs/architecture-practices/architecture-execution/environment-promotion.md","sourceDirName":"architecture-practices/architecture-execution","slug":"/architecture-practices/architecture-execution/environment-promotion","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/environment-promotion","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-execution/environment-promotion.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Performance Testing Guide","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/performance-testing"},"next":{"title":"Rollback Procedures Guide","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/rollback-procedures"}}');var i=t(5813),s=t(7814);const a={},o="Environment Promotion Guide",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Environment Promotion Architecture",id:"environment-promotion-architecture",level:2},{value:"Complete Promotion Pipeline",id:"complete-promotion-pipeline",level:3},{value:"Environment Configuration Management",id:"environment-configuration-management",level:2},{value:"Environment-Specific Configuration",id:"environment-specific-configuration",level:3},{value:"Environment Configuration Service",id:"environment-configuration-service",level:3},{value:"Automated Promotion Pipelines",id:"automated-promotion-pipelines",level:2},{value:"GitHub Actions Environment Promotion",id:"github-actions-environment-promotion",level:3},{value:"Promotion Gates and Validation",id:"promotion-gates-and-validation",level:3},{value:"Next.js Environment Promotion",id:"nextjs-environment-promotion",level:2},{value:"Environment-Specific Build Configuration",id:"environment-specific-build-configuration",level:3},{value:"Frontend Environment Service",id:"frontend-environment-service",level:3},{value:"Environment Monitoring and Validation",id:"environment-monitoring-and-validation",level:2},{value:"Environment Health Dashboard",id:"environment-health-dashboard",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function m(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"environment-promotion-guide",children:"Environment Promotion Guide"})}),"\n",(0,i.jsx)(e.p,{children:"This guide provides comprehensive environment promotion strategies for NestJS microservices and Next.js microfrontend applications, covering environment-specific configurations, automated promotion pipelines, and progressive delivery across development, staging, and production environments."}),"\n",(0,i.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"Environment promotion ensures consistent and reliable deployment of applications across different environments while maintaining isolation, security, and proper testing at each stage. This guide covers automated promotion workflows, environment-specific configurations, and validation strategies."}),"\n",(0,i.jsx)(e.h2,{id:"environment-promotion-architecture",children:"Environment Promotion Architecture"}),"\n",(0,i.jsx)(e.h3,{id:"complete-promotion-pipeline",children:"Complete Promotion Pipeline"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-mermaid",children:"graph TD\n    A[Feature Development] --\x3e B[Local Testing]\n    B --\x3e C[Feature Branch CI]\n    C --\x3e D[Development Environment]\n    \n    D --\x3e E[Integration Testing]\n    E --\x3e F[QA Environment]\n    F --\x3e G[User Acceptance Testing]\n    \n    G --\x3e H[Staging Environment]\n    H --\x3e I[Performance Testing]\n    H --\x3e J[Security Testing]\n    H --\x3e K[Load Testing]\n    \n    I --\x3e L[Production Readiness]\n    J --\x3e L\n    K --\x3e L\n    \n    L --\x3e M[Production Environment]\n    M --\x3e N[Blue-Green Deployment]\n    M --\x3e O[Canary Release]\n    \n    P[Environment Configuration] --\x3e Q[Config Validation]\n    Q --\x3e R[Secret Management]\n    R --\x3e S[Feature Flags]\n    \n    T[Promotion Gates] --\x3e U[Automated Tests]\n    T --\x3e V[Manual Approvals]\n    T --\x3e W[Performance Thresholds]\n    \n    D --\x3e P\n    F --\x3e P\n    H --\x3e P\n    M --\x3e P\n    \n    E --\x3e T\n    G --\x3e T\n    I --\x3e T\n"})}),"\n",(0,i.jsx)(e.h2,{id:"environment-configuration-management",children:"Environment Configuration Management"}),"\n",(0,i.jsx)(e.h3,{id:"environment-specific-configuration",children:"Environment-Specific Configuration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// config/environments/base.config.ts\nexport interface EnvironmentConfig {\n  name: string;\n  database: {\n    host: string;\n    port: number;\n    name: string;\n    ssl: boolean;\n    pool: {\n      min: number;\n      max: number;\n    };\n  };\n  redis: {\n    host: string;\n    port: number;\n    password?: string;\n    db: number;\n  };\n  api: {\n    baseUrl: string;\n    timeout: number;\n    retries: number;\n  };\n  logging: {\n    level: string;\n    format: string;\n    outputs: string[];\n  };\n  monitoring: {\n    enabled: boolean;\n    sampleRate: number;\n    tracing: boolean;\n  };\n  security: {\n    cors: {\n      origins: string[];\n      credentials: boolean;\n    };\n    rateLimit: {\n      windowMs: number;\n      max: number;\n    };\n    encryption: {\n      algorithm: string;\n      keyRotation: boolean;\n    };\n  };\n  features: {\n    [key: string]: boolean | object;\n  };\n}\n\n// config/environments/development.config.ts\nimport { EnvironmentConfig } from './base.config';\n\nexport const developmentConfig: EnvironmentConfig = {\n  name: 'development',\n  database: {\n    host: 'localhost',\n    port: 5432,\n    name: 'microservice_dev',\n    ssl: false,\n    pool: {\n      min: 2,\n      max: 10,\n    },\n  },\n  redis: {\n    host: 'localhost',\n    port: 6379,\n    db: 0,\n  },\n  api: {\n    baseUrl: 'http://localhost:3001',\n    timeout: 5000,\n    retries: 3,\n  },\n  logging: {\n    level: 'debug',\n    format: 'pretty',\n    outputs: ['console'],\n  },\n  monitoring: {\n    enabled: false,\n    sampleRate: 1.0,\n    tracing: true,\n  },\n  security: {\n    cors: {\n      origins: ['http://localhost:3000', 'http://localhost:3001'],\n      credentials: true,\n    },\n    rateLimit: {\n      windowMs: 60000,\n      max: 1000,\n    },\n    encryption: {\n      algorithm: 'aes-256-gcm',\n      keyRotation: false,\n    },\n  },\n  features: {\n    enableNewUI: true,\n    enableExperimentalFeatures: true,\n    enableDebugMode: true,\n    enableMockData: true,\n  },\n};\n\n// config/environments/staging.config.ts\nexport const stagingConfig: EnvironmentConfig = {\n  name: 'staging',\n  database: {\n    host: process.env.STAGING_DB_HOST!,\n    port: parseInt(process.env.STAGING_DB_PORT || '5432'),\n    name: process.env.STAGING_DB_NAME!,\n    ssl: true,\n    pool: {\n      min: 5,\n      max: 20,\n    },\n  },\n  redis: {\n    host: process.env.STAGING_REDIS_HOST!,\n    port: parseInt(process.env.STAGING_REDIS_PORT || '6379'),\n    password: process.env.STAGING_REDIS_PASSWORD,\n    db: 0,\n  },\n  api: {\n    baseUrl: 'https://api-staging.example.com',\n    timeout: 10000,\n    retries: 3,\n  },\n  logging: {\n    level: 'info',\n    format: 'json',\n    outputs: ['console', 'file', 'elasticsearch'],\n  },\n  monitoring: {\n    enabled: true,\n    sampleRate: 0.5,\n    tracing: true,\n  },\n  security: {\n    cors: {\n      origins: ['https://app-staging.example.com'],\n      credentials: true,\n    },\n    rateLimit: {\n      windowMs: 60000,\n      max: 100,\n    },\n    encryption: {\n      algorithm: 'aes-256-gcm',\n      keyRotation: true,\n    },\n  },\n  features: {\n    enableNewUI: true,\n    enableExperimentalFeatures: false,\n    enableDebugMode: false,\n    enableMockData: false,\n  },\n};\n\n// config/environments/production.config.ts\nexport const productionConfig: EnvironmentConfig = {\n  name: 'production',\n  database: {\n    host: process.env.PROD_DB_HOST!,\n    port: parseInt(process.env.PROD_DB_PORT || '5432'),\n    name: process.env.PROD_DB_NAME!,\n    ssl: true,\n    pool: {\n      min: 10,\n      max: 50,\n    },\n  },\n  redis: {\n    host: process.env.PROD_REDIS_HOST!,\n    port: parseInt(process.env.PROD_REDIS_PORT || '6379'),\n    password: process.env.PROD_REDIS_PASSWORD!,\n    db: 0,\n  },\n  api: {\n    baseUrl: 'https://api.example.com',\n    timeout: 15000,\n    retries: 5,\n  },\n  logging: {\n    level: 'warn',\n    format: 'json',\n    outputs: ['file', 'elasticsearch', 'datadog'],\n  },\n  monitoring: {\n    enabled: true,\n    sampleRate: 0.1,\n    tracing: true,\n  },\n  security: {\n    cors: {\n      origins: ['https://app.example.com'],\n      credentials: true,\n    },\n    rateLimit: {\n      windowMs: 60000,\n      max: 50,\n    },\n    encryption: {\n      algorithm: 'aes-256-gcm',\n      keyRotation: true,\n    },\n  },\n  features: {\n    enableNewUI: false,\n    enableExperimentalFeatures: false,\n    enableDebugMode: false,\n    enableMockData: false,\n  },\n};\n"})}),"\n",(0,i.jsx)(e.h3,{id:"environment-configuration-service",children:"Environment Configuration Service"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// src/config/environment.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { EnvironmentConfig } from '../config/environments/base.config';\nimport { developmentConfig } from '../config/environments/development.config';\nimport { stagingConfig } from '../config/environments/staging.config';\nimport { productionConfig } from '../config/environments/production.config';\n\n@Injectable()\nexport class EnvironmentService {\n  private readonly logger = new Logger(EnvironmentService.name);\n  private readonly config: EnvironmentConfig;\n\n  constructor(private readonly configService: ConfigService) {\n    const environment = this.configService.get('NODE_ENV', 'development');\n    this.config = this.loadEnvironmentConfig(environment);\n    this.validateConfig();\n  }\n\n  private loadEnvironmentConfig(environment: string): EnvironmentConfig {\n    const configs = {\n      development: developmentConfig,\n      staging: stagingConfig,\n      production: productionConfig,\n    };\n\n    const config = configs[environment as keyof typeof configs];\n    if (!config) {\n      throw new Error(`Unknown environment: ${environment}`);\n    }\n\n    this.logger.log(`Loaded configuration for environment: ${environment}`);\n    return config;\n  }\n\n  private validateConfig(): void {\n    const required = [\n      'database.host',\n      'database.name',\n      'redis.host',\n      'api.baseUrl',\n    ];\n\n    for (const path of required) {\n      const value = this.getNestedValue(this.config, path);\n      if (!value) {\n        throw new Error(`Missing required configuration: ${path}`);\n      }\n    }\n\n    this.logger.log('Configuration validation passed');\n  }\n\n  private getNestedValue(obj: any, path: string): any {\n    return path.split('.').reduce((current, key) => current?.[key], obj);\n  }\n\n  getConfig(): EnvironmentConfig {\n    return this.config;\n  }\n\n  getDatabaseConfig() {\n    return this.config.database;\n  }\n\n  getRedisConfig() {\n    return this.config.redis;\n  }\n\n  getApiConfig() {\n    return this.config.api;\n  }\n\n  getLoggingConfig() {\n    return this.config.logging;\n  }\n\n  getMonitoringConfig() {\n    return this.config.monitoring;\n  }\n\n  getSecurityConfig() {\n    return this.config.security;\n  }\n\n  getFeatureFlag(flagName: string): boolean | object {\n    return this.config.features[flagName] ?? false;\n  }\n\n  isFeatureEnabled(flagName: string): boolean {\n    const flag = this.getFeatureFlag(flagName);\n    return typeof flag === 'boolean' ? flag : false;\n  }\n\n  getEnvironmentName(): string {\n    return this.config.name;\n  }\n\n  isProduction(): boolean {\n    return this.config.name === 'production';\n  }\n\n  isStaging(): boolean {\n    return this.config.name === 'staging';\n  }\n\n  isDevelopment(): boolean {\n    return this.config.name === 'development';\n  }\n\n  // Environment-specific behavior helpers\n  shouldEnableDebugMode(): boolean {\n    return this.isFeatureEnabled('enableDebugMode') && !this.isProduction();\n  }\n\n  shouldUseMockData(): boolean {\n    return this.isFeatureEnabled('enableMockData') && this.isDevelopment();\n  }\n\n  getLogLevel(): string {\n    return this.config.logging.level;\n  }\n\n  getMonitoringSampleRate(): number {\n    return this.config.monitoring.sampleRate;\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"automated-promotion-pipelines",children:"Automated Promotion Pipelines"}),"\n",(0,i.jsx)(e.h3,{id:"github-actions-environment-promotion",children:"GitHub Actions Environment Promotion"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'# .github/workflows/environment-promotion.yml\nname: Environment Promotion\n\non:\n  push:\n    branches: [develop, main]\n  pull_request:\n    branches: [main]\n  workflow_dispatch:\n    inputs:\n      target_environment:\n        description: \'Target environment for promotion\'\n        required: true\n        default: \'staging\'\n        type: choice\n        options:\n        - development\n        - staging\n        - production\n      skip_tests:\n        description: \'Skip automated tests\'\n        required: false\n        default: false\n        type: boolean\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  determine-environment:\n    runs-on: ubuntu-latest\n    outputs:\n      target-env: ${{ steps.env.outputs.target-env }}\n      should-deploy: ${{ steps.env.outputs.should-deploy }}\n    steps:\n    - name: Determine target environment\n      id: env\n      run: |\n        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then\n          echo "target-env=${{ github.event.inputs.target_environment }}" >> $GITHUB_OUTPUT\n          echo "should-deploy=true" >> $GITHUB_OUTPUT\n        elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then\n          echo "target-env=development" >> $GITHUB_OUTPUT\n          echo "should-deploy=true" >> $GITHUB_OUTPUT\n        elif [ "${{ github.ref }}" = "refs/heads/main" ]; then\n          echo "target-env=staging" >> $GITHUB_OUTPUT\n          echo "should-deploy=true" >> $GITHUB_OUTPUT\n        else\n          echo "target-env=none" >> $GITHUB_OUTPUT\n          echo "should-deploy=false" >> $GITHUB_OUTPUT\n        fi\n\n  build-and-test:\n    runs-on: ubuntu-latest\n    needs: determine-environment\n    if: needs.determine-environment.outputs.should-deploy == \'true\'\n    strategy:\n      matrix:\n        service: [api-gateway, user-service, product-service, frontend]\n    \n    steps:\n    - name: Checkout\n      uses: actions/checkout@v4\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: \'18\'\n        cache: \'npm\'\n        cache-dependency-path: ${{ matrix.service }}/package-lock.json\n\n    - name: Install dependencies\n      run: |\n        cd ${{ matrix.service }}\n        npm ci\n\n    - name: Run tests\n      if: ${{ github.event.inputs.skip_tests != \'true\' }}\n      run: |\n        cd ${{ matrix.service }}\n        npm run test\n        npm run test:e2e\n\n    - name: Build application\n      run: |\n        cd ${{ matrix.service }}\n        npm run build\n\n    - name: Build Docker image\n      run: |\n        cd ${{ matrix.service }}\n        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.service }}:${{ github.sha }} .\n\n    - name: Log in to Container Registry\n      uses: docker/login-action@v3\n      with:\n        registry: ${{ env.REGISTRY }}\n        username: ${{ github.actor }}\n        password: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Push Docker image\n      run: |\n        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.service }}:${{ github.sha }}\n\n  deploy-development:\n    runs-on: ubuntu-latest\n    needs: [determine-environment, build-and-test]\n    if: needs.determine-environment.outputs.target-env == \'development\'\n    environment: development\n    \n    steps:\n    - name: Deploy to Development\n      run: |\n        echo "Deploying to development environment..."\n        # Update development environment configurations\n        # Trigger development deployment\n\n  deploy-staging:\n    runs-on: ubuntu-latest\n    needs: [determine-environment, build-and-test]\n    if: needs.determine-environment.outputs.target-env == \'staging\'\n    environment: staging\n    \n    steps:\n    - name: Run integration tests\n      run: |\n        echo "Running integration tests..."\n        # Run comprehensive integration tests\n\n    - name: Deploy to Staging\n      run: |\n        echo "Deploying to staging environment..."\n        # Update staging environment configurations\n        # Trigger staging deployment\n\n    - name: Run smoke tests\n      run: |\n        echo "Running smoke tests..."\n        # Verify basic functionality in staging\n\n  deploy-production:\n    runs-on: ubuntu-latest\n    needs: [determine-environment, build-and-test]\n    if: needs.determine-environment.outputs.target-env == \'production\'\n    environment: production\n    \n    steps:\n    - name: Pre-production validation\n      run: |\n        echo "Running pre-production validation..."\n        # Validate staging environment\n        # Check performance metrics\n        # Verify security scans\n\n    - name: Create production backup\n      run: |\n        echo "Creating production backup..."\n        # Backup production database\n        # Backup configuration\n\n    - name: Deploy to Production\n      run: |\n        echo "Deploying to production environment..."\n        # Blue-green deployment to production\n        # Update production configurations\n\n    - name: Post-deployment verification\n      run: |\n        echo "Running post-deployment verification..."\n        # Health checks\n        # Performance validation\n        # User acceptance tests\n\n  notification:\n    runs-on: ubuntu-latest\n    needs: [deploy-development, deploy-staging, deploy-production]\n    if: always()\n    \n    steps:\n    - name: Notify deployment status\n      uses: 8398a7/action-slack@v3\n      with:\n        status: ${{ job.status }}\n        text: |\n          Environment promotion completed for ${{ needs.determine-environment.outputs.target-env }}\n          Status: ${{ job.status }}\n          Commit: ${{ github.sha }}\n      env:\n        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"promotion-gates-and-validation",children:"Promotion Gates and Validation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// src/promotion/promotion-gate.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { HttpService } from '@nestjs/axios';\nimport { firstValueFrom } from 'rxjs';\n\nexport interface PromotionGate {\n  name: string;\n  required: boolean;\n  timeout: number;\n  validator: () => Promise<PromotionGateResult>;\n}\n\nexport interface PromotionGateResult {\n  passed: boolean;\n  message: string;\n  details?: any;\n}\n\nexport interface PromotionRequest {\n  sourceEnvironment: string;\n  targetEnvironment: string;\n  version: string;\n  services: string[];\n  skipOptionalGates?: boolean;\n}\n\n@Injectable()\nexport class PromotionGateService {\n  private readonly logger = new Logger(PromotionGateService.name);\n\n  constructor(private readonly httpService: HttpService) {}\n\n  async validatePromotion(request: PromotionRequest): Promise<{\n    approved: boolean;\n    gates: Array<PromotionGateResult & { name: string; required: boolean }>;\n    message: string;\n  }> {\n    this.logger.log(`Validating promotion from ${request.sourceEnvironment} to ${request.targetEnvironment}`);\n\n    const gates = this.getPromotionGates(request.targetEnvironment);\n    const results = [];\n    let allRequiredPassed = true;\n\n    for (const gate of gates) {\n      try {\n        this.logger.debug(`Running gate: ${gate.name}`);\n        \n        const result = await Promise.race([\n          gate.validator(),\n          this.createTimeoutPromise(gate.timeout, gate.name),\n        ]);\n\n        results.push({\n          name: gate.name,\n          required: gate.required,\n          ...result,\n        });\n\n        if (gate.required && !result.passed) {\n          allRequiredPassed = false;\n        }\n\n        this.logger.debug(`Gate ${gate.name}: ${result.passed ? 'PASSED' : 'FAILED'} - ${result.message}`);\n      } catch (error) {\n        const errorResult = {\n          name: gate.name,\n          required: gate.required,\n          passed: false,\n          message: `Gate execution failed: ${error.message}`,\n          details: error,\n        };\n\n        results.push(errorResult);\n\n        if (gate.required) {\n          allRequiredPassed = false;\n        }\n\n        this.logger.error(`Gate ${gate.name} execution failed`, error);\n      }\n    }\n\n    const approved = allRequiredPassed || request.skipOptionalGates === true;\n    const message = approved \n      ? 'All required promotion gates passed'\n      : 'One or more required promotion gates failed';\n\n    return {\n      approved,\n      gates: results,\n      message,\n    };\n  }\n\n  private getPromotionGates(targetEnvironment: string): PromotionGate[] {\n    const commonGates: PromotionGate[] = [\n      {\n        name: 'health-check',\n        required: true,\n        timeout: 30000,\n        validator: () => this.validateHealthCheck(),\n      },\n      {\n        name: 'database-migrations',\n        required: true,\n        timeout: 60000,\n        validator: () => this.validateDatabaseMigrations(),\n      },\n      {\n        name: 'security-scan',\n        required: true,\n        timeout: 120000,\n        validator: () => this.validateSecurityScan(),\n      },\n    ];\n\n    const environmentSpecificGates: Record<string, PromotionGate[]> = {\n      staging: [\n        {\n          name: 'integration-tests',\n          required: true,\n          timeout: 300000,\n          validator: () => this.validateIntegrationTests(),\n        },\n        {\n          name: 'performance-baseline',\n          required: false,\n          timeout: 180000,\n          validator: () => this.validatePerformanceBaseline(),\n        },\n      ],\n      production: [\n        {\n          name: 'staging-validation',\n          required: true,\n          timeout: 60000,\n          validator: () => this.validateStagingEnvironment(),\n        },\n        {\n          name: 'performance-tests',\n          required: true,\n          timeout: 600000,\n          validator: () => this.validatePerformanceTests(),\n        },\n        {\n          name: 'backup-verification',\n          required: true,\n          timeout: 120000,\n          validator: () => this.validateBackupStatus(),\n        },\n        {\n          name: 'manual-approval',\n          required: true,\n          timeout: 3600000, // 1 hour\n          validator: () => this.validateManualApproval(),\n        },\n      ],\n    };\n\n    return [\n      ...commonGates,\n      ...(environmentSpecificGates[targetEnvironment] || []),\n    ];\n  }\n\n  private async createTimeoutPromise(timeout: number, gateName: string): Promise<PromotionGateResult> {\n    return new Promise((_, reject) => {\n      setTimeout(() => {\n        reject(new Error(`Gate ${gateName} timed out after ${timeout}ms`));\n      }, timeout);\n    });\n  }\n\n  private async validateHealthCheck(): Promise<PromotionGateResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get('/health', { timeout: 5000 })\n      );\n\n      if (response.status === 200) {\n        return {\n          passed: true,\n          message: 'Health check passed',\n          details: response.data,\n        };\n      } else {\n        return {\n          passed: false,\n          message: `Health check failed with status ${response.status}`,\n          details: response.data,\n        };\n      }\n    } catch (error) {\n      return {\n        passed: false,\n        message: 'Health check endpoint unreachable',\n        details: error.message,\n      };\n    }\n  }\n\n  private async validateDatabaseMigrations(): Promise<PromotionGateResult> {\n    try {\n      // Check if there are pending migrations\n      const response = await firstValueFrom(\n        this.httpService.get('/admin/migrations/status')\n      );\n\n      const { pending, errors } = response.data;\n\n      if (errors && errors.length > 0) {\n        return {\n          passed: false,\n          message: 'Database migration errors detected',\n          details: errors,\n        };\n      }\n\n      if (pending && pending.length > 0) {\n        return {\n          passed: false,\n          message: `${pending.length} pending migrations found`,\n          details: pending,\n        };\n      }\n\n      return {\n        passed: true,\n        message: 'All database migrations are up to date',\n      };\n    } catch (error) {\n      return {\n        passed: false,\n        message: 'Unable to verify database migration status',\n        details: error.message,\n      };\n    }\n  }\n\n  private async validateSecurityScan(): Promise<PromotionGateResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get('/admin/security/scan-status')\n      );\n\n      const { vulnerabilities, lastScan } = response.data;\n      const highSeverityVulns = vulnerabilities.filter(v => v.severity === 'high' || v.severity === 'critical');\n\n      if (highSeverityVulns.length > 0) {\n        return {\n          passed: false,\n          message: `${highSeverityVulns.length} high/critical vulnerabilities found`,\n          details: highSeverityVulns,\n        };\n      }\n\n      // Check if scan is recent (within last 24 hours)\n      const scanAge = Date.now() - new Date(lastScan).getTime();\n      const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n\n      if (scanAge > maxAge) {\n        return {\n          passed: false,\n          message: 'Security scan is outdated',\n          details: { lastScan, ageHours: scanAge / (60 * 60 * 1000) },\n        };\n      }\n\n      return {\n        passed: true,\n        message: 'Security scan passed with no critical vulnerabilities',\n        details: { vulnerabilities: vulnerabilities.length, lastScan },\n      };\n    } catch (error) {\n      return {\n        passed: false,\n        message: 'Unable to verify security scan status',\n        details: error.message,\n      };\n    }\n  }\n\n  private async validateIntegrationTests(): Promise<PromotionGateResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get('/admin/tests/integration/latest')\n      );\n\n      const { status, passRate, duration, failedTests } = response.data;\n\n      if (status !== 'passed') {\n        return {\n          passed: false,\n          message: `Integration tests failed with status: ${status}`,\n          details: failedTests,\n        };\n      }\n\n      if (passRate < 95) {\n        return {\n          passed: false,\n          message: `Integration test pass rate below threshold: ${passRate}%`,\n          details: { passRate, failedTests },\n        };\n      }\n\n      return {\n        passed: true,\n        message: `Integration tests passed with ${passRate}% success rate`,\n        details: { passRate, duration },\n      };\n    } catch (error) {\n      return {\n        passed: false,\n        message: 'Unable to verify integration test status',\n        details: error.message,\n      };\n    }\n  }\n\n  private async validatePerformanceBaseline(): Promise<PromotionGateResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get('/admin/performance/baseline')\n      );\n\n      const { currentMetrics, baseline, deviation } = response.data;\n\n      const thresholds = {\n        responseTime: 20, // 20% increase allowed\n        throughput: -10,  // 10% decrease allowed\n        errorRate: 50,    // 50% increase allowed\n      };\n\n      const violations = [];\n\n      for (const [metric, threshold] of Object.entries(thresholds)) {\n        if (deviation[metric] > threshold) {\n          violations.push({\n            metric,\n            deviation: deviation[metric],\n            threshold,\n            current: currentMetrics[metric],\n            baseline: baseline[metric],\n          });\n        }\n      }\n\n      if (violations.length > 0) {\n        return {\n          passed: false,\n          message: 'Performance metrics deviated beyond acceptable thresholds',\n          details: violations,\n        };\n      }\n\n      return {\n        passed: true,\n        message: 'Performance metrics within acceptable range',\n        details: { currentMetrics, baseline, deviation },\n      };\n    } catch (error) {\n      return {\n        passed: false,\n        message: 'Unable to verify performance baseline',\n        details: error.message,\n      };\n    }\n  }\n\n  private async validateStagingEnvironment(): Promise<PromotionGateResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get('/admin/staging/validation')\n      );\n\n      const { uptime, errorRate, responseTime, lastDeployment } = response.data;\n\n      // Check if staging has been stable for at least 2 hours\n      const deploymentAge = Date.now() - new Date(lastDeployment).getTime();\n      const minStabilityTime = 2 * 60 * 60 * 1000; // 2 hours\n\n      if (deploymentAge < minStabilityTime) {\n        return {\n          passed: false,\n          message: 'Staging environment needs more stability time',\n          details: { \n            deploymentAge: deploymentAge / (60 * 60 * 1000), \n            required: 2 \n          },\n        };\n      }\n\n      if (errorRate > 1) {\n        return {\n          passed: false,\n          message: `Staging error rate too high: ${errorRate}%`,\n          details: { errorRate, threshold: 1 },\n        };\n      }\n\n      if (responseTime > 2000) {\n        return {\n          passed: false,\n          message: `Staging response time too high: ${responseTime}ms`,\n          details: { responseTime, threshold: 2000 },\n        };\n      }\n\n      return {\n        passed: true,\n        message: 'Staging environment validation passed',\n        details: { uptime, errorRate, responseTime, lastDeployment },\n      };\n    } catch (error) {\n      return {\n        passed: false,\n        message: 'Unable to validate staging environment',\n        details: error.message,\n      };\n    }\n  }\n\n  private async validatePerformanceTests(): Promise<PromotionGateResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get('/admin/performance/tests/latest')\n      );\n\n      const { status, metrics, thresholds } = response.data;\n\n      if (status !== 'passed') {\n        return {\n          passed: false,\n          message: `Performance tests failed with status: ${status}`,\n          details: metrics,\n        };\n      }\n\n      const violations = [];\n      for (const [metric, value] of Object.entries(metrics)) {\n        const threshold = thresholds[metric];\n        if (threshold && value > threshold) {\n          violations.push({ metric, value, threshold });\n        }\n      }\n\n      if (violations.length > 0) {\n        return {\n          passed: false,\n          message: 'Performance tests exceeded thresholds',\n          details: violations,\n        };\n      }\n\n      return {\n        passed: true,\n        message: 'Performance tests passed all thresholds',\n        details: metrics,\n      };\n    } catch (error) {\n      return {\n        passed: false,\n        message: 'Unable to verify performance test results',\n        details: error.message,\n      };\n    }\n  }\n\n  private async validateBackupStatus(): Promise<PromotionGateResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get('/admin/backup/status')\n      );\n\n      const { lastBackup, status, size } = response.data;\n\n      // Check if backup is recent (within last 24 hours)\n      const backupAge = Date.now() - new Date(lastBackup).getTime();\n      const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n\n      if (backupAge > maxAge) {\n        return {\n          passed: false,\n          message: 'No recent backup found',\n          details: { lastBackup, ageHours: backupAge / (60 * 60 * 1000) },\n        };\n      }\n\n      if (status !== 'completed') {\n        return {\n          passed: false,\n          message: `Backup status is ${status}, not completed`,\n          details: { status, lastBackup },\n        };\n      }\n\n      return {\n        passed: true,\n        message: 'Recent backup verified',\n        details: { lastBackup, status, size },\n      };\n    } catch (error) {\n      return {\n        passed: false,\n        message: 'Unable to verify backup status',\n        details: error.message,\n      };\n    }\n  }\n\n  private async validateManualApproval(): Promise<PromotionGateResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get('/admin/approvals/production/latest')\n      );\n\n      const { approved, approver, timestamp, comments } = response.data;\n\n      if (!approved) {\n        return {\n          passed: false,\n          message: 'Manual approval required for production deployment',\n          details: { status: 'pending' },\n        };\n      }\n\n      // Check if approval is recent (within last 4 hours)\n      const approvalAge = Date.now() - new Date(timestamp).getTime();\n      const maxAge = 4 * 60 * 60 * 1000; // 4 hours\n\n      if (approvalAge > maxAge) {\n        return {\n          passed: false,\n          message: 'Manual approval is outdated',\n          details: { timestamp, ageHours: approvalAge / (60 * 60 * 1000) },\n        };\n      }\n\n      return {\n        passed: true,\n        message: 'Manual approval verified',\n        details: { approver, timestamp, comments },\n      };\n    } catch (error) {\n      return {\n        passed: false,\n        message: 'Unable to verify manual approval status',\n        details: error.message,\n      };\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"nextjs-environment-promotion",children:"Next.js Environment Promotion"}),"\n",(0,i.jsx)(e.h3,{id:"environment-specific-build-configuration",children:"Environment-Specific Build Configuration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// next.config.js\nconst { PHASE_DEVELOPMENT_SERVER, PHASE_PRODUCTION_BUILD } = require('next/constants');\n\nmodule.exports = (phase, { defaultConfig }) => {\n  const isDev = phase === PHASE_DEVELOPMENT_SERVER;\n  const isProd = phase === PHASE_PRODUCTION_BUILD;\n\n  const env = {\n    NEXT_PUBLIC_ENVIRONMENT: process.env.NODE_ENV,\n    NEXT_PUBLIC_API_BASE_URL: (() => {\n      switch (process.env.NODE_ENV) {\n        case 'production':\n          return 'https://api.example.com';\n        case 'staging':\n          return 'https://api-staging.example.com';\n        default:\n          return 'http://localhost:3001';\n      }\n    })(),\n    NEXT_PUBLIC_APP_VERSION: process.env.npm_package_version || '1.0.0',\n    NEXT_PUBLIC_BUILD_TIME: new Date().toISOString(),\n  };\n\n  const config = {\n    ...defaultConfig,\n    env,\n    \n    // Environment-specific optimizations\n    compiler: {\n      removeConsole: isProd ? { exclude: ['error'] } : false,\n    },\n    \n    // Bundle analyzer for staging builds\n    ...(process.env.ANALYZE === 'true' && {\n      webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {\n        if (!isServer) {\n          const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');\n          config.plugins.push(\n            new BundleAnalyzerPlugin({\n              analyzerMode: 'static',\n              openAnalyzer: false,\n            })\n          );\n        }\n        return config;\n      },\n    }),\n\n    // Environment-specific headers\n    async headers() {\n      const headers = [];\n      \n      if (isProd) {\n        headers.push({\n          source: '/(.*)',\n          headers: [\n            {\n              key: 'X-Frame-Options',\n              value: 'DENY',\n            },\n            {\n              key: 'X-Content-Type-Options',\n              value: 'nosniff',\n            },\n            {\n              key: 'Referrer-Policy',\n              value: 'origin-when-cross-origin',\n            },\n          ],\n        });\n      }\n\n      return headers;\n    },\n\n    // Environment-specific redirects\n    async redirects() {\n      const redirects = [];\n\n      // Staging-specific redirects\n      if (process.env.NODE_ENV === 'staging') {\n        redirects.push({\n          source: '/admin',\n          destination: '/admin/staging',\n          permanent: false,\n        });\n      }\n\n      return redirects;\n    },\n\n    // Environment-specific rewrites\n    async rewrites() {\n      return {\n        beforeFiles: [\n          // Environment-specific API rewrites\n          {\n            source: '/api/:path*',\n            destination: `${env.NEXT_PUBLIC_API_BASE_URL}/api/:path*`,\n          },\n        ],\n      };\n    },\n  };\n\n  return config;\n};\n"})}),"\n",(0,i.jsx)(e.h3,{id:"frontend-environment-service",children:"Frontend Environment Service"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// lib/environment.service.ts\ninterface FrontendEnvironmentConfig {\n  name: string;\n  apiBaseUrl: string;\n  features: {\n    enableAnalytics: boolean;\n    enableErrorReporting: boolean;\n    enablePerformanceMonitoring: boolean;\n    enableExperimentalFeatures: boolean;\n  };\n  monitoring: {\n    sentryDsn?: string;\n    googleAnalyticsId?: string;\n    hotjarId?: string;\n  };\n  performance: {\n    enableWebVitals: boolean;\n    enableImageOptimization: boolean;\n    enableCodeSplitting: boolean;\n  };\n}\n\nclass FrontendEnvironmentService {\n  private config: FrontendEnvironmentConfig;\n\n  constructor() {\n    this.config = this.loadEnvironmentConfig();\n  }\n\n  private loadEnvironmentConfig(): FrontendEnvironmentConfig {\n    const environment = process.env.NEXT_PUBLIC_ENVIRONMENT || 'development';\n\n    const configs: Record<string, FrontendEnvironmentConfig> = {\n      development: {\n        name: 'development',\n        apiBaseUrl: 'http://localhost:3001',\n        features: {\n          enableAnalytics: false,\n          enableErrorReporting: false,\n          enablePerformanceMonitoring: true,\n          enableExperimentalFeatures: true,\n        },\n        monitoring: {},\n        performance: {\n          enableWebVitals: true,\n          enableImageOptimization: false,\n          enableCodeSplitting: false,\n        },\n      },\n      staging: {\n        name: 'staging',\n        apiBaseUrl: 'https://api-staging.example.com',\n        features: {\n          enableAnalytics: true,\n          enableErrorReporting: true,\n          enablePerformanceMonitoring: true,\n          enableExperimentalFeatures: false,\n        },\n        monitoring: {\n          sentryDsn: process.env.NEXT_PUBLIC_SENTRY_DSN,\n          googleAnalyticsId: process.env.NEXT_PUBLIC_GA_ID_STAGING,\n        },\n        performance: {\n          enableWebVitals: true,\n          enableImageOptimization: true,\n          enableCodeSplitting: true,\n        },\n      },\n      production: {\n        name: 'production',\n        apiBaseUrl: 'https://api.example.com',\n        features: {\n          enableAnalytics: true,\n          enableErrorReporting: true,\n          enablePerformanceMonitoring: true,\n          enableExperimentalFeatures: false,\n        },\n        monitoring: {\n          sentryDsn: process.env.NEXT_PUBLIC_SENTRY_DSN,\n          googleAnalyticsId: process.env.NEXT_PUBLIC_GA_ID,\n          hotjarId: process.env.NEXT_PUBLIC_HOTJAR_ID,\n        },\n        performance: {\n          enableWebVitals: true,\n          enableImageOptimization: true,\n          enableCodeSplitting: true,\n        },\n      },\n    };\n\n    return configs[environment] || configs.development;\n  }\n\n  getConfig(): FrontendEnvironmentConfig {\n    return this.config;\n  }\n\n  getEnvironmentName(): string {\n    return this.config.name;\n  }\n\n  getApiBaseUrl(): string {\n    return this.config.apiBaseUrl;\n  }\n\n  isFeatureEnabled(feature: keyof FrontendEnvironmentConfig['features']): boolean {\n    return this.config.features[feature];\n  }\n\n  getMonitoringConfig() {\n    return this.config.monitoring;\n  }\n\n  getPerformanceConfig() {\n    return this.config.performance;\n  }\n\n  isDevelopment(): boolean {\n    return this.config.name === 'development';\n  }\n\n  isStaging(): boolean {\n    return this.config.name === 'staging';\n  }\n\n  isProduction(): boolean {\n    return this.config.name === 'production';\n  }\n}\n\nexport const frontendEnvironmentService = new FrontendEnvironmentService();\n"})}),"\n",(0,i.jsx)(e.h2,{id:"environment-monitoring-and-validation",children:"Environment Monitoring and Validation"}),"\n",(0,i.jsx)(e.h3,{id:"environment-health-dashboard",children:"Environment Health Dashboard"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// components/admin/environment-health-dashboard.tsx\nimport React, { useState, useEffect } from \'react\';\nimport { Card, CardHeader, CardContent } from \'@/components/ui/card\';\nimport { Badge } from \'@/components/ui/badge\';\nimport { Button } from \'@/components/ui/button\';\n\ninterface EnvironmentHealth {\n  name: string;\n  status: \'healthy\' | \'warning\' | \'critical\';\n  services: Array<{\n    name: string;\n    status: \'up\' | \'down\' | \'degraded\';\n    responseTime: number;\n    lastCheck: string;\n  }>;\n  metrics: {\n    uptime: number;\n    errorRate: number;\n    responseTime: number;\n    throughput: number;\n  };\n  lastDeployment: {\n    version: string;\n    timestamp: string;\n    status: \'success\' | \'failed\' | \'in-progress\';\n  };\n}\n\nexport const EnvironmentHealthDashboard: React.FC = () => {\n  const [environments, setEnvironments] = useState<EnvironmentHealth[]>([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    fetchEnvironmentHealth();\n    const interval = setInterval(fetchEnvironmentHealth, 30000); // Refresh every 30 seconds\n    return () => clearInterval(interval);\n  }, []);\n\n  const fetchEnvironmentHealth = async () => {\n    try {\n      const response = await fetch(\'/api/admin/environment-health\');\n      const data = await response.json();\n      setEnvironments(data);\n    } catch (error) {\n      console.error(\'Failed to fetch environment health:\', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case \'healthy\':\n      case \'up\':\n      case \'success\':\n        return \'green\';\n      case \'warning\':\n      case \'degraded\':\n      case \'in-progress\':\n        return \'yellow\';\n      case \'critical\':\n      case \'down\':\n      case \'failed\':\n        return \'red\';\n      default:\n        return \'gray\';\n    }\n  };\n\n  if (loading) {\n    return <div>Loading environment health...</div>;\n  }\n\n  return (\n    <div className="space-y-6">\n      <h1 className="text-3xl font-bold">Environment Health Dashboard</h1>\n      \n      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">\n        {environments.map((env) => (\n          <Card key={env.name} className="w-full">\n            <CardHeader>\n              <div className="flex justify-between items-center">\n                <h3 className="text-xl font-semibold capitalize">{env.name}</h3>\n                <Badge variant={getStatusColor(env.status)}>\n                  {env.status}\n                </Badge>\n              </div>\n            </CardHeader>\n            \n            <CardContent className="space-y-4">\n              {/* Services Status */}\n              <div>\n                <h4 className="font-medium mb-2">Services</h4>\n                <div className="space-y-1">\n                  {env.services.map((service) => (\n                    <div key={service.name} className="flex justify-between items-center text-sm">\n                      <span>{service.name}</span>\n                      <div className="flex items-center gap-2">\n                        <Badge variant={getStatusColor(service.status)} size="sm">\n                          {service.status}\n                        </Badge>\n                        <span className="text-gray-500">{service.responseTime}ms</span>\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              </div>\n\n              {/* Metrics */}\n              <div>\n                <h4 className="font-medium mb-2">Metrics</h4>\n                <div className="grid grid-cols-2 gap-2 text-sm">\n                  <div>\n                    <span className="text-gray-500">Uptime:</span>\n                    <span className="ml-1 font-medium">{env.metrics.uptime.toFixed(2)}%</span>\n                  </div>\n                  <div>\n                    <span className="text-gray-500">Error Rate:</span>\n                    <span className="ml-1 font-medium">{env.metrics.errorRate.toFixed(2)}%</span>\n                  </div>\n                  <div>\n                    <span className="text-gray-500">Response Time:</span>\n                    <span className="ml-1 font-medium">{env.metrics.responseTime}ms</span>\n                  </div>\n                  <div>\n                    <span className="text-gray-500">Throughput:</span>\n                    <span className="ml-1 font-medium">{env.metrics.throughput}/min</span>\n                  </div>\n                </div>\n              </div>\n\n              {/* Last Deployment */}\n              <div>\n                <h4 className="font-medium mb-2">Last Deployment</h4>\n                <div className="text-sm space-y-1">\n                  <div className="flex justify-between">\n                    <span className="text-gray-500">Version:</span>\n                    <span className="font-medium">{env.lastDeployment.version}</span>\n                  </div>\n                  <div className="flex justify-between">\n                    <span className="text-gray-500">Status:</span>\n                    <Badge variant={getStatusColor(env.lastDeployment.status)} size="sm">\n                      {env.lastDeployment.status}\n                    </Badge>\n                  </div>\n                  <div className="flex justify-between">\n                    <span className="text-gray-500">Time:</span>\n                    <span className="font-medium">\n                      {new Date(env.lastDeployment.timestamp).toLocaleString()}\n                    </span>\n                  </div>\n                </div>\n              </div>\n\n              {/* Actions */}\n              <div className="pt-2 border-t">\n                <Button variant="outline" size="sm" className="w-full">\n                  View Details\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n    </div>\n  );\n};\n'})}),"\n",(0,i.jsx)(e.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/configuration-management",children:"Configuration Management"})})," - Environment-specific configurations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/automated-deployment",children:"Automated Deployment"})})," - Deployment strategies and pipelines"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline",children:"CI/CD Pipeline"})})," - Continuous integration and delivery"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.p,{children:"This environment promotion guide should be regularly updated to incorporate new deployment strategies and environment management patterns."})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(m,{...n})}):m(n)}},7814:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>o});var r=t(9729);const i={},s=r.createContext(i);function a(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);