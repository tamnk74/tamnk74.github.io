"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[8990],{1165:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"architecture-practices/architecture-validation/continuous-testing","title":"Continuous Testing Strategy","description":"This guide provides comprehensive continuous testing strategies and automated testing frameworks for NestJS microservices and Next.js microfrontend applications, covering unit testing, integration testing, end-to-end testing, and cross-platform compatibility validation.","source":"@site/docs/architecture-practices/architecture-validation/continuous-testing.md","sourceDirName":"architecture-practices/architecture-validation","slug":"/architecture-practices/architecture-validation/continuous-testing","permalink":"/fullstack-dev/docs/architecture-practices/architecture-validation/continuous-testing","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-validation/continuous-testing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Architecture Evaluation Process","permalink":"/fullstack-dev/docs/architecture-practices/architecture-validation/architecture-evaluation"},"next":{"title":"Non-functional Requirements Validation","permalink":"/fullstack-dev/docs/architecture-practices/architecture-validation/non-functional-requirements-validation"}}');var r=t(5813),a=t(7814);const o={},i="Continuous Testing Strategy",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Testing Architecture",id:"testing-architecture",level:2},{value:"Complete Testing Framework",id:"complete-testing-framework",level:3},{value:"Unit Testing Framework",id:"unit-testing-framework",level:2},{value:"NestJS Unit Testing Setup",id:"nestjs-unit-testing-setup",level:3},{value:"Comprehensive Service Testing",id:"comprehensive-service-testing",level:3},{value:"Controller Testing with Mocks",id:"controller-testing-with-mocks",level:3},{value:"Integration Testing",id:"integration-testing",level:2},{value:"API Integration Tests",id:"api-integration-tests",level:3},{value:"Frontend Testing with React Testing Library",id:"frontend-testing-with-react-testing-library",level:2},{value:"Next.js Component Testing",id:"nextjs-component-testing",level:3},{value:"Hook Testing",id:"hook-testing",level:3},{value:"End-to-End Testing with Playwright",id:"end-to-end-testing-with-playwright",level:2},{value:"E2E Test Setup",id:"e2e-test-setup",level:3},{value:"Page Object Model",id:"page-object-model",level:3},{value:"E2E Test Cases",id:"e2e-test-cases",level:3},{value:"Cross-Browser and Device Testing",id:"cross-browser-and-device-testing",level:2},{value:"Playwright Configuration",id:"playwright-configuration",level:3},{value:"Test Coverage and Quality Gates",id:"test-coverage-and-quality-gates",level:2},{value:"Coverage Configuration",id:"coverage-configuration",level:3},{value:"Frontend Test Configuration",id:"frontend-test-configuration",level:3},{value:"Quality Gates CI/CD Integration",id:"quality-gates-cicd-integration",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"continuous-testing-strategy",children:"Continuous Testing Strategy"})}),"\n",(0,r.jsx)(n.p,{children:"This guide provides comprehensive continuous testing strategies and automated testing frameworks for NestJS microservices and Next.js microfrontend applications, covering unit testing, integration testing, end-to-end testing, and cross-platform compatibility validation."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Continuous testing ensures code quality and functionality through automated test execution at every stage of the development pipeline. This guide covers comprehensive testing strategies, automated test execution, coverage management, and quality gates that prevent regression and maintain high software quality standards."}),"\n",(0,r.jsx)(n.h2,{id:"testing-architecture",children:"Testing Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"complete-testing-framework",children:"Complete Testing Framework"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Source Code Changes] --\x3e B[Pre-commit Hooks]\n    B --\x3e C[Unit Tests]\n    C --\x3e D[Integration Tests]\n    D --\x3e E[Code Coverage Analysis]\n    \n    E --\x3e F[Quality Gates]\n    F --\x3e G[Component Tests]\n    G --\x3e H[API Tests]\n    H --\x3e I[E2E Tests]\n    \n    I --\x3e J[Cross-browser Testing]\n    J --\x3e K[Mobile Testing]\n    K --\x3e L[Performance Tests]\n    L --\x3e M[Accessibility Tests]\n    \n    M --\x3e N[Security Tests]\n    N --\x3e O[Visual Regression Tests]\n    O --\x3e P[Test Results Aggregation]\n    \n    P --\x3e Q[Coverage Reports]\n    Q --\x3e R[Test Metrics Dashboard]\n    R --\x3e S[Quality Feedback]\n    \n    T[Test Types] --\x3e U[Unit Tests]\n    T --\x3e V[Integration Tests]\n    T --\x3e W[Contract Tests]\n    T --\x3e X[E2E Tests]\n    \n    Y[Testing Tools] --\x3e Z[Jest/Vitest]\n    Y --\x3e AA[Playwright]\n    Y --\x3e BB[Cypress]\n    Y --\x3e CC[Testing Library]\n    \n    DD[Coverage Types] --\x3e EE[Line Coverage]\n    DD --\x3e FF[Branch Coverage]\n    DD --\x3e GG[Function Coverage]\n    DD --\x3e HH[Statement Coverage]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"unit-testing-framework",children:"Unit Testing Framework"}),"\n",(0,r.jsx)(n.h3,{id:"nestjs-unit-testing-setup",children:"NestJS Unit Testing Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/testing/test-setup.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ConfigService } from '@nestjs/config';\nimport { getRepositoryToken } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { JwtService } from '@nestjs/jwt';\n\nexport class TestSetup {\n  static async createTestingModule(providers: any[] = []): Promise<TestingModule> {\n    return Test.createTestingModule({\n      providers: [\n        ...providers,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn((key: string) => {\n              const config: Record<string, any> = {\n                JWT_SECRET: 'test-secret',\n                JWT_EXPIRES_IN: '24h',\n                DATABASE_URL: 'postgres://test:test@localhost:5432/test',\n                REDIS_URL: 'redis://localhost:6379',\n                NODE_ENV: 'test',\n              };\n              return config[key];\n            }),\n          },\n        },\n        {\n          provide: JwtService,\n          useValue: {\n            sign: jest.fn().mockReturnValue('mock-jwt-token'),\n            verify: jest.fn().mockReturnValue({ sub: 1, email: 'test@example.com' }),\n          },\n        },\n      ],\n    }).compile();\n  }\n\n  static createMockRepository<T>(): Partial<Repository<T>> {\n    return {\n      find: jest.fn(),\n      findOne: jest.fn(),\n      findOneBy: jest.fn(),\n      save: jest.fn(),\n      create: jest.fn(),\n      update: jest.fn(),\n      delete: jest.fn(),\n      remove: jest.fn(),\n      count: jest.fn(),\n      createQueryBuilder: jest.fn().mockReturnValue({\n        where: jest.fn().mockReturnThis(),\n        andWhere: jest.fn().mockReturnThis(),\n        orWhere: jest.fn().mockReturnThis(),\n        orderBy: jest.fn().mockReturnThis(),\n        limit: jest.fn().mockReturnThis(),\n        offset: jest.fn().mockReturnThis(),\n        leftJoinAndSelect: jest.fn().mockReturnThis(),\n        getOne: jest.fn(),\n        getMany: jest.fn(),\n        getManyAndCount: jest.fn(),\n      }),\n    };\n  }\n\n  static getRepositoryToken(entity: any): string {\n    return getRepositoryToken(entity);\n  }\n}\n\n// Example Entity for testing\nexport class MockUser {\n  id: number;\n  email: string;\n  name: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"comprehensive-service-testing",children:"Comprehensive Service Testing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/users/users.service.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { Repository } from 'typeorm';\nimport { UsersService } from './users.service';\nimport { User } from './entities/user.entity';\nimport { TestSetup } from '../testing/test-setup';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { NotFoundException, ConflictException } from '@nestjs/common';\n\ndescribe('UsersService', () => {\n  let service: UsersService;\n  let userRepository: Partial<Repository<User>>;\n  let module: TestingModule;\n\n  const mockUser: User = {\n    id: 1,\n    email: 'test@example.com',\n    name: 'Test User',\n    password: 'hashedPassword',\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    isActive: true,\n    roles: [],\n  };\n\n  beforeEach(async () => {\n    userRepository = TestSetup.createMockRepository<User>();\n\n    module = await TestSetup.createTestingModule([\n      UsersService,\n      {\n        provide: TestSetup.getRepositoryToken(User),\n        useValue: userRepository,\n      },\n    ]);\n\n    service = module.get<UsersService>(UsersService);\n  });\n\n  afterEach(async () => {\n    await module.close();\n  });\n\n  describe('findAll', () => {\n    it('should return an array of users', async () => {\n      const users = [mockUser];\n      jest.spyOn(userRepository, 'find').mockResolvedValue(users);\n\n      const result = await service.findAll();\n\n      expect(result).toEqual(users);\n      expect(userRepository.find).toHaveBeenCalledWith({\n        relations: ['roles'],\n        where: { isActive: true },\n      });\n    });\n\n    it('should return empty array when no users found', async () => {\n      jest.spyOn(userRepository, 'find').mockResolvedValue([]);\n\n      const result = await service.findAll();\n\n      expect(result).toEqual([]);\n    });\n\n    it('should handle repository errors', async () => {\n      jest.spyOn(userRepository, 'find').mockRejectedValue(new Error('Database error'));\n\n      await expect(service.findAll()).rejects.toThrow('Database error');\n    });\n  });\n\n  describe('findOne', () => {\n    it('should return a user by id', async () => {\n      jest.spyOn(userRepository, 'findOne').mockResolvedValue(mockUser);\n\n      const result = await service.findOne(1);\n\n      expect(result).toEqual(mockUser);\n      expect(userRepository.findOne).toHaveBeenCalledWith({\n        where: { id: 1, isActive: true },\n        relations: ['roles'],\n      });\n    });\n\n    it('should throw NotFoundException when user not found', async () => {\n      jest.spyOn(userRepository, 'findOne').mockResolvedValue(null);\n\n      await expect(service.findOne(999)).rejects.toThrow(NotFoundException);\n    });\n  });\n\n  describe('create', () => {\n    const createUserDto: CreateUserDto = {\n      email: 'new@example.com',\n      name: 'New User',\n      password: 'password123',\n    };\n\n    it('should create a new user', async () => {\n      const newUser = { ...mockUser, ...createUserDto, id: 2 };\n      \n      jest.spyOn(userRepository, 'findOne').mockResolvedValue(null); // Email not exists\n      jest.spyOn(userRepository, 'create').mockReturnValue(newUser as any);\n      jest.spyOn(userRepository, 'save').mockResolvedValue(newUser);\n\n      const result = await service.create(createUserDto);\n\n      expect(result).toEqual(newUser);\n      expect(userRepository.findOne).toHaveBeenCalledWith({\n        where: { email: createUserDto.email },\n      });\n      expect(userRepository.create).toHaveBeenCalledWith({\n        ...createUserDto,\n        password: expect.any(String), // Hashed password\n      });\n      expect(userRepository.save).toHaveBeenCalledWith(newUser);\n    });\n\n    it('should throw ConflictException when email already exists', async () => {\n      jest.spyOn(userRepository, 'findOne').mockResolvedValue(mockUser);\n\n      await expect(service.create(createUserDto)).rejects.toThrow(ConflictException);\n    });\n\n    it('should hash password before saving', async () => {\n      const newUser = { ...mockUser, ...createUserDto, id: 2 };\n      \n      jest.spyOn(userRepository, 'findOne').mockResolvedValue(null);\n      jest.spyOn(userRepository, 'create').mockReturnValue(newUser as any);\n      jest.spyOn(userRepository, 'save').mockResolvedValue(newUser);\n\n      await service.create(createUserDto);\n\n      expect(userRepository.create).toHaveBeenCalledWith({\n        ...createUserDto,\n        password: expect.not.stringMatching(createUserDto.password),\n      });\n    });\n  });\n\n  describe('update', () => {\n    const updateUserDto: UpdateUserDto = {\n      name: 'Updated Name',\n    };\n\n    it('should update a user', async () => {\n      const updatedUser = { ...mockUser, ...updateUserDto };\n      \n      jest.spyOn(userRepository, 'findOne').mockResolvedValue(mockUser);\n      jest.spyOn(userRepository, 'save').mockResolvedValue(updatedUser);\n\n      const result = await service.update(1, updateUserDto);\n\n      expect(result).toEqual(updatedUser);\n      expect(userRepository.save).toHaveBeenCalledWith({\n        ...mockUser,\n        ...updateUserDto,\n      });\n    });\n\n    it('should throw NotFoundException when user not found', async () => {\n      jest.spyOn(userRepository, 'findOne').mockResolvedValue(null);\n\n      await expect(service.update(999, updateUserDto)).rejects.toThrow(NotFoundException);\n    });\n  });\n\n  describe('remove', () => {\n    it('should soft delete a user', async () => {\n      const deletedUser = { ...mockUser, isActive: false };\n      \n      jest.spyOn(userRepository, 'findOne').mockResolvedValue(mockUser);\n      jest.spyOn(userRepository, 'save').mockResolvedValue(deletedUser);\n\n      await service.remove(1);\n\n      expect(userRepository.save).toHaveBeenCalledWith({\n        ...mockUser,\n        isActive: false,\n      });\n    });\n\n    it('should throw NotFoundException when user not found', async () => {\n      jest.spyOn(userRepository, 'findOne').mockResolvedValue(null);\n\n      await expect(service.remove(999)).rejects.toThrow(NotFoundException);\n    });\n  });\n\n  describe('findByEmail', () => {\n    it('should return user by email', async () => {\n      jest.spyOn(userRepository, 'findOne').mockResolvedValue(mockUser);\n\n      const result = await service.findByEmail('test@example.com');\n\n      expect(result).toEqual(mockUser);\n      expect(userRepository.findOne).toHaveBeenCalledWith({\n        where: { email: 'test@example.com', isActive: true },\n        relations: ['roles'],\n      });\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"controller-testing-with-mocks",children:"Controller Testing with Mocks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/users/users.controller.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { UsersController } from './users.controller';\nimport { UsersService } from './users.service';\nimport { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';\nimport { RolesGuard } from '../auth/guards/roles.guard';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { User } from './entities/user.entity';\n\ndescribe('UsersController', () => {\n  let controller: UsersController;\n  let usersService: jest.Mocked<UsersService>;\n\n  const mockUser: User = {\n    id: 1,\n    email: 'test@example.com',\n    name: 'Test User',\n    password: 'hashedPassword',\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    isActive: true,\n    roles: [],\n  };\n\n  beforeEach(async () => {\n    const mockUsersService = {\n      findAll: jest.fn(),\n      findOne: jest.fn(),\n      create: jest.fn(),\n      update: jest.fn(),\n      remove: jest.fn(),\n      findByEmail: jest.fn(),\n    };\n\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [UsersController],\n      providers: [\n        {\n          provide: UsersService,\n          useValue: mockUsersService,\n        },\n      ],\n    })\n      .overrideGuard(JwtAuthGuard)\n      .useValue({ canActivate: jest.fn(() => true) })\n      .overrideGuard(RolesGuard)\n      .useValue({ canActivate: jest.fn(() => true) })\n      .compile();\n\n    controller = module.get<UsersController>(UsersController);\n    usersService = module.get(UsersService);\n  });\n\n  describe('findAll', () => {\n    it('should return an array of users', async () => {\n      const users = [mockUser];\n      usersService.findAll.mockResolvedValue(users);\n\n      const result = await controller.findAll();\n\n      expect(result).toEqual(users);\n      expect(usersService.findAll).toHaveBeenCalled();\n    });\n  });\n\n  describe('findOne', () => {\n    it('should return a user by id', async () => {\n      usersService.findOne.mockResolvedValue(mockUser);\n\n      const result = await controller.findOne('1');\n\n      expect(result).toEqual(mockUser);\n      expect(usersService.findOne).toHaveBeenCalledWith(1);\n    });\n\n    it('should handle invalid id format', async () => {\n      await expect(controller.findOne('invalid')).rejects.toThrow();\n    });\n  });\n\n  describe('create', () => {\n    const createUserDto: CreateUserDto = {\n      email: 'new@example.com',\n      name: 'New User',\n      password: 'password123',\n    };\n\n    it('should create a new user', async () => {\n      const newUser = { ...mockUser, ...createUserDto, id: 2 };\n      usersService.create.mockResolvedValue(newUser);\n\n      const result = await controller.create(createUserDto);\n\n      expect(result).toEqual(newUser);\n      expect(usersService.create).toHaveBeenCalledWith(createUserDto);\n    });\n  });\n\n  describe('update', () => {\n    const updateUserDto: UpdateUserDto = {\n      name: 'Updated Name',\n    };\n\n    it('should update a user', async () => {\n      const updatedUser = { ...mockUser, ...updateUserDto };\n      usersService.update.mockResolvedValue(updatedUser);\n\n      const result = await controller.update('1', updateUserDto);\n\n      expect(result).toEqual(updatedUser);\n      expect(usersService.update).toHaveBeenCalledWith(1, updateUserDto);\n    });\n  });\n\n  describe('remove', () => {\n    it('should remove a user', async () => {\n      usersService.remove.mockResolvedValue(undefined);\n\n      await controller.remove('1');\n\n      expect(usersService.remove).toHaveBeenCalledWith(1);\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,r.jsx)(n.h3,{id:"api-integration-tests",children:"API Integration Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/testing/integration/users.integration.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport * as request from 'supertest';\nimport { AppModule } from '../../app.module';\nimport { User } from '../../users/entities/user.entity';\nimport { CreateUserDto } from '../../users/dto/create-user.dto';\nimport { Repository } from 'typeorm';\nimport { JwtService } from '@nestjs/jwt';\n\ndescribe('Users Integration Tests', () => {\n  let app: INestApplication;\n  let userRepository: Repository<User>;\n  let jwtService: JwtService;\n  let authToken: string;\n\n  beforeAll(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [\n        AppModule,\n        TypeOrmModule.forRoot({\n          type: 'postgres',\n          host: process.env.TEST_DB_HOST || 'localhost',\n          port: parseInt(process.env.TEST_DB_PORT) || 5433,\n          username: process.env.TEST_DB_USERNAME || 'test',\n          password: process.env.TEST_DB_PASSWORD || 'test',\n          database: process.env.TEST_DB_NAME || 'test_db',\n          entities: [User],\n          synchronize: true,\n          dropSchema: true,\n        }),\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n\n    userRepository = moduleFixture.get('UserRepository');\n    jwtService = moduleFixture.get(JwtService);\n\n    // Create test user and auth token\n    const testUser = await userRepository.save({\n      email: 'admin@example.com',\n      name: 'Admin User',\n      password: 'hashedPassword',\n      isActive: true,\n      roles: ['admin'],\n    });\n\n    authToken = jwtService.sign({ sub: testUser.id, email: testUser.email });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n\n  beforeEach(async () => {\n    // Clean database before each test\n    await userRepository.clear();\n  });\n\n  describe('/users (GET)', () => {\n    it('should return empty array when no users exist', async () => {\n      const response = await request(app.getHttpServer())\n        .get('/users')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(response.body).toEqual([]);\n    });\n\n    it('should return array of users', async () => {\n      const users = await userRepository.save([\n        {\n          email: 'user1@example.com',\n          name: 'User 1',\n          password: 'password',\n          isActive: true,\n        },\n        {\n          email: 'user2@example.com',\n          name: 'User 2',\n          password: 'password',\n          isActive: true,\n        },\n      ]);\n\n      const response = await request(app.getHttpServer())\n        .get('/users')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(response.body).toHaveLength(2);\n      expect(response.body[0]).toMatchObject({\n        email: 'user1@example.com',\n        name: 'User 1',\n      });\n    });\n\n    it('should require authentication', async () => {\n      await request(app.getHttpServer())\n        .get('/users')\n        .expect(401);\n    });\n  });\n\n  describe('/users/:id (GET)', () => {\n    it('should return a user by id', async () => {\n      const user = await userRepository.save({\n        email: 'test@example.com',\n        name: 'Test User',\n        password: 'password',\n        isActive: true,\n      });\n\n      const response = await request(app.getHttpServer())\n        .get(`/users/${user.id}`)\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(response.body).toMatchObject({\n        id: user.id,\n        email: 'test@example.com',\n        name: 'Test User',\n      });\n    });\n\n    it('should return 404 for non-existent user', async () => {\n      await request(app.getHttpServer())\n        .get('/users/999')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(404);\n    });\n  });\n\n  describe('/users (POST)', () => {\n    const createUserDto: CreateUserDto = {\n      email: 'new@example.com',\n      name: 'New User',\n      password: 'password123',\n    };\n\n    it('should create a new user', async () => {\n      const response = await request(app.getHttpServer())\n        .post('/users')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(createUserDto)\n        .expect(201);\n\n      expect(response.body).toMatchObject({\n        email: createUserDto.email,\n        name: createUserDto.name,\n      });\n      expect(response.body.password).toBeUndefined();\n\n      // Verify user was saved to database\n      const savedUser = await userRepository.findOne({\n        where: { email: createUserDto.email },\n      });\n      expect(savedUser).toBeDefined();\n    });\n\n    it('should return 409 for duplicate email', async () => {\n      await userRepository.save({\n        email: createUserDto.email,\n        name: 'Existing User',\n        password: 'password',\n        isActive: true,\n      });\n\n      await request(app.getHttpServer())\n        .post('/users')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(createUserDto)\n        .expect(409);\n    });\n\n    it('should validate required fields', async () => {\n      await request(app.getHttpServer())\n        .post('/users')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({ email: 'invalid' })\n        .expect(400);\n    });\n  });\n\n  describe('/users/:id (PATCH)', () => {\n    it('should update a user', async () => {\n      const user = await userRepository.save({\n        email: 'test@example.com',\n        name: 'Test User',\n        password: 'password',\n        isActive: true,\n      });\n\n      const updateDto = { name: 'Updated Name' };\n\n      const response = await request(app.getHttpServer())\n        .patch(`/users/${user.id}`)\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(updateDto)\n        .expect(200);\n\n      expect(response.body.name).toBe('Updated Name');\n\n      // Verify update in database\n      const updatedUser = await userRepository.findOne({\n        where: { id: user.id },\n      });\n      expect(updatedUser.name).toBe('Updated Name');\n    });\n  });\n\n  describe('/users/:id (DELETE)', () => {\n    it('should soft delete a user', async () => {\n      const user = await userRepository.save({\n        email: 'test@example.com',\n        name: 'Test User',\n        password: 'password',\n        isActive: true,\n      });\n\n      await request(app.getHttpServer())\n        .delete(`/users/${user.id}`)\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      // Verify soft delete\n      const deletedUser = await userRepository.findOne({\n        where: { id: user.id },\n      });\n      expect(deletedUser.isActive).toBe(false);\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"frontend-testing-with-react-testing-library",children:"Frontend Testing with React Testing Library"}),"\n",(0,r.jsx)(n.h3,{id:"nextjs-component-testing",children:"Next.js Component Testing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// components/__tests__/UserProfile.test.tsx\nimport React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { useRouter } from 'next/router';\nimport { UserProfile } from '../UserProfile';\nimport { useUser } from '../../hooks/useUser';\n\n// Mock Next.js router\njest.mock('next/router', () => ({\n  useRouter: jest.fn(),\n}));\n\n// Mock custom hooks\njest.mock('../../hooks/useUser');\n\nconst mockUseRouter = useRouter as jest.MockedFunction<typeof useRouter>;\nconst mockUseUser = useUser as jest.MockedFunction<typeof useUser>;\n\ndescribe('UserProfile', () => {\n  let queryClient: QueryClient;\n  const mockPush = jest.fn();\n\n  beforeEach(() => {\n    queryClient = new QueryClient({\n      defaultOptions: {\n        queries: { retry: false },\n        mutations: { retry: false },\n      },\n    });\n\n    mockUseRouter.mockReturnValue({\n      push: mockPush,\n      pathname: '/profile',\n      query: {},\n      asPath: '/profile',\n    } as any);\n\n    mockUseUser.mockReturnValue({\n      user: {\n        id: 1,\n        email: 'test@example.com',\n        name: 'Test User',\n        avatar: null,\n        createdAt: '2023-01-01T00:00:00Z',\n      },\n      isLoading: false,\n      error: null,\n      updateUser: jest.fn(),\n      deleteUser: jest.fn(),\n    });\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  const renderWithProviders = (component: React.ReactElement) => {\n    return render(\n      <QueryClientProvider client={queryClient}>\n        {component}\n      </QueryClientProvider>\n    );\n  };\n\n  it('should render user profile information', () => {\n    renderWithProviders(<UserProfile />);\n\n    expect(screen.getByText('Test User')).toBeInTheDocument();\n    expect(screen.getByText('test@example.com')).toBeInTheDocument();\n    expect(screen.getByText('Member since January 1, 2023')).toBeInTheDocument();\n  });\n\n  it('should show loading state', () => {\n    mockUseUser.mockReturnValue({\n      user: null,\n      isLoading: true,\n      error: null,\n      updateUser: jest.fn(),\n      deleteUser: jest.fn(),\n    });\n\n    renderWithProviders(<UserProfile />);\n\n    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n  });\n\n  it('should show error state', () => {\n    mockUseUser.mockReturnValue({\n      user: null,\n      isLoading: false,\n      error: new Error('Failed to load user'),\n      updateUser: jest.fn(),\n      deleteUser: jest.fn(),\n    });\n\n    renderWithProviders(<UserProfile />);\n\n    expect(screen.getByText('Failed to load user profile')).toBeInTheDocument();\n  });\n\n  it('should handle edit profile button click', () => {\n    renderWithProviders(<UserProfile />);\n\n    const editButton = screen.getByRole('button', { name: /edit profile/i });\n    fireEvent.click(editButton);\n\n    expect(mockPush).toHaveBeenCalledWith('/profile/edit');\n  });\n\n  it('should handle profile update', async () => {\n    const mockUpdateUser = jest.fn().mockResolvedValue({\n      id: 1,\n      name: 'Updated Name',\n      email: 'test@example.com',\n    });\n\n    mockUseUser.mockReturnValue({\n      user: {\n        id: 1,\n        email: 'test@example.com',\n        name: 'Test User',\n        avatar: null,\n        createdAt: '2023-01-01T00:00:00Z',\n      },\n      isLoading: false,\n      error: null,\n      updateUser: mockUpdateUser,\n      deleteUser: jest.fn(),\n    });\n\n    renderWithProviders(<UserProfile />);\n\n    const editButton = screen.getByRole('button', { name: /edit profile/i });\n    fireEvent.click(editButton);\n\n    // Simulate inline editing\n    const nameInput = screen.getByDisplayValue('Test User');\n    fireEvent.change(nameInput, { target: { value: 'Updated Name' } });\n\n    const saveButton = screen.getByRole('button', { name: /save/i });\n    fireEvent.click(saveButton);\n\n    await waitFor(() => {\n      expect(mockUpdateUser).toHaveBeenCalledWith({\n        name: 'Updated Name',\n      });\n    });\n  });\n\n  it('should handle avatar upload', async () => {\n    const mockUpdateUser = jest.fn().mockResolvedValue({});\n\n    mockUseUser.mockReturnValue({\n      user: {\n        id: 1,\n        email: 'test@example.com',\n        name: 'Test User',\n        avatar: null,\n        createdAt: '2023-01-01T00:00:00Z',\n      },\n      isLoading: false,\n      error: null,\n      updateUser: mockUpdateUser,\n      deleteUser: jest.fn(),\n    });\n\n    renderWithProviders(<UserProfile />);\n\n    const fileInput = screen.getByLabelText(/upload avatar/i);\n    const file = new File(['avatar'], 'avatar.jpg', { type: 'image/jpeg' });\n\n    fireEvent.change(fileInput, { target: { files: [file] } });\n\n    await waitFor(() => {\n      expect(mockUpdateUser).toHaveBeenCalledWith({\n        avatar: expect.any(FormData),\n      });\n    });\n  });\n\n  it('should handle delete account with confirmation', async () => {\n    const mockDeleteUser = jest.fn().mockResolvedValue(undefined);\n    window.confirm = jest.fn().mockReturnValue(true);\n\n    mockUseUser.mockReturnValue({\n      user: {\n        id: 1,\n        email: 'test@example.com',\n        name: 'Test User',\n        avatar: null,\n        createdAt: '2023-01-01T00:00:00Z',\n      },\n      isLoading: false,\n      error: null,\n      updateUser: jest.fn(),\n      deleteUser: mockDeleteUser,\n    });\n\n    renderWithProviders(<UserProfile />);\n\n    const deleteButton = screen.getByRole('button', { name: /delete account/i });\n    fireEvent.click(deleteButton);\n\n    expect(window.confirm).toHaveBeenCalledWith(\n      'Are you sure you want to delete your account? This action cannot be undone.'\n    );\n\n    await waitFor(() => {\n      expect(mockDeleteUser).toHaveBeenCalled();\n      expect(mockPush).toHaveBeenCalledWith('/');\n    });\n  });\n\n  it('should cancel delete account when not confirmed', () => {\n    const mockDeleteUser = jest.fn();\n    window.confirm = jest.fn().mockReturnValue(false);\n\n    mockUseUser.mockReturnValue({\n      user: {\n        id: 1,\n        email: 'test@example.com',\n        name: 'Test User',\n        avatar: null,\n        createdAt: '2023-01-01T00:00:00Z',\n      },\n      isLoading: false,\n      error: null,\n      updateUser: jest.fn(),\n      deleteUser: mockDeleteUser,\n    });\n\n    renderWithProviders(<UserProfile />);\n\n    const deleteButton = screen.getByRole('button', { name: /delete account/i });\n    fireEvent.click(deleteButton);\n\n    expect(mockDeleteUser).not.toHaveBeenCalled();\n    expect(mockPush).not.toHaveBeenCalled();\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"hook-testing",children:"Hook Testing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// hooks/__tests__/useUser.test.ts\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { useUser } from '../useUser';\nimport { userApi } from '../../services/userApi';\n\njest.mock('../../services/userApi');\n\nconst mockUserApi = userApi as jest.Mocked<typeof userApi>;\n\ndescribe('useUser', () => {\n  let queryClient: QueryClient;\n  let wrapper: React.FC<{ children: React.ReactNode }>;\n\n  beforeEach(() => {\n    queryClient = new QueryClient({\n      defaultOptions: {\n        queries: { retry: false },\n        mutations: { retry: false },\n      },\n    });\n\n    wrapper = ({ children }) => (\n      <QueryClientProvider client={queryClient}>\n        {children}\n      </QueryClientProvider>\n    );\n  });\n\n  it('should fetch user data successfully', async () => {\n    const mockUser = {\n      id: 1,\n      email: 'test@example.com',\n      name: 'Test User',\n      avatar: null,\n      createdAt: '2023-01-01T00:00:00Z',\n    };\n\n    mockUserApi.getCurrentUser.mockResolvedValue(mockUser);\n\n    const { result } = renderHook(() => useUser(), { wrapper });\n\n    expect(result.current.isLoading).toBe(true);\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    expect(result.current.user).toEqual(mockUser);\n    expect(result.current.error).toBeNull();\n  });\n\n  it('should handle fetch error', async () => {\n    const mockError = new Error('Failed to fetch user');\n    mockUserApi.getCurrentUser.mockRejectedValue(mockError);\n\n    const { result } = renderHook(() => useUser(), { wrapper });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    expect(result.current.user).toBeNull();\n    expect(result.current.error).toEqual(mockError);\n  });\n\n  it('should update user successfully', async () => {\n    const originalUser = {\n      id: 1,\n      email: 'test@example.com',\n      name: 'Test User',\n      avatar: null,\n      createdAt: '2023-01-01T00:00:00Z',\n    };\n\n    const updatedUser = {\n      ...originalUser,\n      name: 'Updated Name',\n    };\n\n    mockUserApi.getCurrentUser.mockResolvedValue(originalUser);\n    mockUserApi.updateUser.mockResolvedValue(updatedUser);\n\n    const { result } = renderHook(() => useUser(), { wrapper });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    await result.current.updateUser({ name: 'Updated Name' });\n\n    await waitFor(() => {\n      expect(result.current.user?.name).toBe('Updated Name');\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"end-to-end-testing-with-playwright",children:"End-to-End Testing with Playwright"}),"\n",(0,r.jsx)(n.h3,{id:"e2e-test-setup",children:"E2E Test Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// e2e/setup/test-setup.ts\nimport { test as base, expect } from '@playwright/test';\nimport { UserPage } from '../pages/user.page';\nimport { LoginPage } from '../pages/login.page';\n\nexport interface TestFixtures {\n  userPage: UserPage;\n  loginPage: LoginPage;\n  authenticatedPage: any;\n}\n\nexport const test = base.extend<TestFixtures>({\n  userPage: async ({ page }, use) => {\n    const userPage = new UserPage(page);\n    await use(userPage);\n  },\n\n  loginPage: async ({ page }, use) => {\n    const loginPage = new LoginPage(page);\n    await use(loginPage);\n  },\n\n  authenticatedPage: async ({ page }, use) => {\n    // Auto-login for tests that need authentication\n    await page.goto('/login');\n    await page.fill('[data-testid=\"email-input\"]', 'admin@example.com');\n    await page.fill('[data-testid=\"password-input\"]', 'password123');\n    await page.click('[data-testid=\"login-button\"]');\n    await expect(page).toHaveURL('/dashboard');\n    await use(page);\n  },\n});\n\nexport { expect } from '@playwright/test';\n"})}),"\n",(0,r.jsx)(n.h3,{id:"page-object-model",children:"Page Object Model"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// e2e/pages/user.page.ts\nimport { Page, Locator, expect } from '@playwright/test';\n\nexport class UserPage {\n  readonly page: Page;\n  readonly userNameInput: Locator;\n  readonly userEmailInput: Locator;\n  readonly saveButton: Locator;\n  readonly deleteButton: Locator;\n  readonly confirmDeleteButton: Locator;\n  readonly profileImage: Locator;\n  readonly uploadButton: Locator;\n\n  constructor(page: Page) {\n    this.page = page;\n    this.userNameInput = page.locator('[data-testid=\"user-name-input\"]');\n    this.userEmailInput = page.locator('[data-testid=\"user-email-input\"]');\n    this.saveButton = page.locator('[data-testid=\"save-button\"]');\n    this.deleteButton = page.locator('[data-testid=\"delete-button\"]');\n    this.confirmDeleteButton = page.locator('[data-testid=\"confirm-delete-button\"]');\n    this.profileImage = page.locator('[data-testid=\"profile-image\"]');\n    this.uploadButton = page.locator('[data-testid=\"upload-button\"]');\n  }\n\n  async goto(userId?: number) {\n    const url = userId ? `/users/${userId}` : '/users';\n    await this.page.goto(url);\n  }\n\n  async createUser(userData: { name: string; email: string }) {\n    await this.page.click('[data-testid=\"create-user-button\"]');\n    await this.userNameInput.fill(userData.name);\n    await this.userEmailInput.fill(userData.email);\n    await this.saveButton.click();\n  }\n\n  async updateUser(userData: Partial<{ name: string; email: string }>) {\n    if (userData.name) {\n      await this.userNameInput.clear();\n      await this.userNameInput.fill(userData.name);\n    }\n    if (userData.email) {\n      await this.userEmailInput.clear();\n      await this.userEmailInput.fill(userData.email);\n    }\n    await this.saveButton.click();\n  }\n\n  async deleteUser() {\n    await this.deleteButton.click();\n    await this.confirmDeleteButton.click();\n  }\n\n  async uploadProfileImage(filePath: string) {\n    const fileInput = this.page.locator('input[type=\"file\"]');\n    await fileInput.setInputFiles(filePath);\n    await this.uploadButton.click();\n  }\n\n  async expectUserDisplayed(userData: { name: string; email: string }) {\n    await expect(this.page.locator('[data-testid=\"user-name\"]')).toContainText(userData.name);\n    await expect(this.page.locator('[data-testid=\"user-email\"]')).toContainText(userData.email);\n  }\n\n  async expectUserNotFound() {\n    await expect(this.page.locator('[data-testid=\"user-not-found\"]')).toBeVisible();\n  }\n\n  async expectSuccessMessage(message: string) {\n    await expect(this.page.locator('[data-testid=\"success-message\"]')).toContainText(message);\n  }\n\n  async expectErrorMessage(message: string) {\n    await expect(this.page.locator('[data-testid=\"error-message\"]')).toContainText(message);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"e2e-test-cases",children:"E2E Test Cases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// e2e/tests/user-management.spec.ts\nimport { test, expect } from '../setup/test-setup';\n\ntest.describe('User Management', () => {\n  test.beforeEach(async ({ authenticatedPage }) => {\n    await authenticatedPage.goto('/users');\n  });\n\n  test('should create a new user', async ({ userPage }) => {\n    const userData = {\n      name: 'New Test User',\n      email: 'newuser@example.com',\n    };\n\n    await userPage.createUser(userData);\n    await userPage.expectSuccessMessage('User created successfully');\n    await userPage.expectUserDisplayed(userData);\n  });\n\n  test('should update existing user', async ({ userPage, page }) => {\n    // First create a user\n    const initialUserData = {\n      name: 'Initial User',\n      email: 'initial@example.com',\n    };\n    await userPage.createUser(initialUserData);\n\n    // Then update the user\n    const updatedUserData = {\n      name: 'Updated User Name',\n    };\n    \n    await page.click('[data-testid=\"edit-user-button\"]');\n    await userPage.updateUser(updatedUserData);\n    await userPage.expectSuccessMessage('User updated successfully');\n    await userPage.expectUserDisplayed({\n      name: updatedUserData.name,\n      email: initialUserData.email,\n    });\n  });\n\n  test('should delete a user', async ({ userPage, page }) => {\n    // Create a user first\n    const userData = {\n      name: 'User to Delete',\n      email: 'delete@example.com',\n    };\n    await userPage.createUser(userData);\n\n    // Delete the user\n    await page.click('[data-testid=\"edit-user-button\"]');\n    await userPage.deleteUser();\n    await userPage.expectSuccessMessage('User deleted successfully');\n  });\n\n  test('should handle user creation validation errors', async ({ userPage }) => {\n    // Try to create user with invalid email\n    const invalidUserData = {\n      name: 'Test User',\n      email: 'invalid-email',\n    };\n\n    await userPage.createUser(invalidUserData);\n    await userPage.expectErrorMessage('Please enter a valid email address');\n  });\n\n  test('should upload profile image', async ({ userPage, page }) => {\n    // Create a user first\n    const userData = {\n      name: 'User with Image',\n      email: 'image@example.com',\n    };\n    await userPage.createUser(userData);\n\n    // Upload profile image\n    await page.click('[data-testid=\"edit-user-button\"]');\n    await userPage.uploadProfileImage('e2e/fixtures/test-avatar.jpg');\n    await userPage.expectSuccessMessage('Profile image updated successfully');\n    \n    // Verify image is displayed\n    await expect(userPage.profileImage).toBeVisible();\n  });\n\n  test('should search for users', async ({ page }) => {\n    // Create multiple users\n    const users = [\n      { name: 'Alice Johnson', email: 'alice@example.com' },\n      { name: 'Bob Smith', email: 'bob@example.com' },\n      { name: 'Charlie Brown', email: 'charlie@example.com' },\n    ];\n\n    for (const user of users) {\n      await page.click('[data-testid=\"create-user-button\"]');\n      await page.fill('[data-testid=\"user-name-input\"]', user.name);\n      await page.fill('[data-testid=\"user-email-input\"]', user.email);\n      await page.click('[data-testid=\"save-button\"]');\n      await page.waitForSelector('[data-testid=\"success-message\"]');\n    }\n\n    // Search for specific user\n    await page.fill('[data-testid=\"search-input\"]', 'Alice');\n    await page.waitForTimeout(500); // Wait for debounced search\n\n    // Verify only Alice is shown\n    await expect(page.locator('[data-testid=\"user-list-item\"]')).toHaveCount(1);\n    await expect(page.locator('[data-testid=\"user-list-item\"]')).toContainText('Alice Johnson');\n  });\n\n  test('should handle network errors gracefully', async ({ page, userPage }) => {\n    // Simulate network failure\n    await page.route('**/api/users', route => route.abort());\n\n    const userData = {\n      name: 'Network Test User',\n      email: 'network@example.com',\n    };\n\n    await userPage.createUser(userData);\n    await userPage.expectErrorMessage('Unable to create user. Please try again.');\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"cross-browser-and-device-testing",children:"Cross-Browser and Device Testing"}),"\n",(0,r.jsx)(n.h3,{id:"playwright-configuration",children:"Playwright Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// playwright.config.ts\nimport { defineConfig, devices } from '@playwright/test';\n\nexport default defineConfig({\n  testDir: './e2e/tests',\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: [\n    ['html'],\n    ['junit', { outputFile: 'test-results/junit.xml' }],\n  ],\n  use: {\n    baseURL: process.env.BASE_URL || 'http://localhost:3000',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure',\n  },\n\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n\n    {\n      name: 'firefox',\n      use: { ...devices['Desktop Firefox'] },\n    },\n\n    {\n      name: 'webkit',\n      use: { ...devices['Desktop Safari'] },\n    },\n\n    // Mobile devices\n    {\n      name: 'Mobile Chrome',\n      use: { ...devices['Pixel 5'] },\n    },\n    {\n      name: 'Mobile Safari',\n      use: { ...devices['iPhone 12'] },\n    },\n\n    // Tablet devices\n    {\n      name: 'iPad',\n      use: { ...devices['iPad Pro'] },\n    },\n\n    // Different screen sizes\n    {\n      name: 'Desktop Large',\n      use: {\n        viewport: { width: 1920, height: 1080 },\n      },\n    },\n    {\n      name: 'Desktop Small',\n      use: {\n        viewport: { width: 1366, height: 768 },\n      },\n    },\n  ],\n\n  webServer: {\n    command: 'npm run dev',\n    url: 'http://localhost:3000',\n    reuseExistingServer: !process.env.CI,\n  },\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"test-coverage-and-quality-gates",children:"Test Coverage and Quality Gates"}),"\n",(0,r.jsx)(n.h3,{id:"coverage-configuration",children:"Coverage Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// jest.config.js\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src'],\n  testMatch: [\n    '**/__tests__/**/*.+(ts|tsx|js)',\n    '**/*.(test|spec).+(ts|tsx|js)',\n  ],\n  transform: {\n    '^.+\\\\.(ts|tsx)$': 'ts-jest',\n  },\n  collectCoverageFrom: [\n    'src/**/*.{ts,tsx}',\n    '!src/**/*.d.ts',\n    '!src/main.ts',\n    '!src/**/*.interface.ts',\n    '!src/**/*.dto.ts',\n    '!src/**/*.entity.ts',\n    '!src/migrations/**',\n    '!src/testing/**',\n  ],\n  coverageReporters: ['text', 'lcov', 'html', 'cobertura'],\n  coverageDirectory: 'coverage',\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80,\n    },\n    './src/users/': {\n      branches: 90,\n      functions: 90,\n      lines: 90,\n      statements: 90,\n    },\n    './src/auth/': {\n      branches: 85,\n      functions: 85,\n      lines: 85,\n      statements: 85,\n    },\n  },\n  setupFilesAfterEnv: ['<rootDir>/src/testing/jest-setup.ts'],\n  moduleNameMapping: {\n    '^@/(.*)$': '<rootDir>/src/$1',\n  },\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"frontend-test-configuration",children:"Frontend Test Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// jest.config.frontend.js\nconst nextJest = require('next/jest');\n\nconst createJestConfig = nextJest({\n  dir: './',\n});\n\nconst customJestConfig = {\n  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\n  moduleNameMapping: {\n    '^@/components/(.*)$': '<rootDir>/components/$1',\n    '^@/pages/(.*)$': '<rootDir>/pages/$1',\n    '^@/hooks/(.*)$': '<rootDir>/hooks/$1',\n    '^@/lib/(.*)$': '<rootDir>/lib/$1',\n    '^@/services/(.*)$': '<rootDir>/services/$1',\n  },\n  testEnvironment: 'jest-environment-jsdom',\n  collectCoverageFrom: [\n    'components/**/*.{js,jsx,ts,tsx}',\n    'hooks/**/*.{js,jsx,ts,tsx}',\n    'lib/**/*.{js,jsx,ts,tsx}',\n    'pages/**/*.{js,jsx,ts,tsx}',\n    'services/**/*.{js,jsx,ts,tsx}',\n    '!**/*.d.ts',\n    '!**/node_modules/**',\n    '!**/.next/**',\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 75,\n      functions: 75,\n      lines: 75,\n      statements: 75,\n    },\n  },\n};\n\nmodule.exports = createJestConfig(customJestConfig);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"quality-gates-cicd-integration",children:"Quality Gates CI/CD Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# .github/workflows/test-quality-gates.yml\nname: Test Quality Gates\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  unit-tests:\n    name: Unit Tests\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout\n      uses: actions/checkout@v4\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'npm'\n\n    - name: Install dependencies\n      run: npm ci\n\n    - name: Run backend unit tests\n      run: |\n        npm run test:unit\n        npm run test:coverage\n\n    - name: Run frontend unit tests\n      run: |\n        npm run test:frontend\n        npm run test:frontend:coverage\n\n    - name: Upload coverage reports\n      uses: codecov/codecov-action@v3\n      with:\n        files: ./coverage/lcov.info,./coverage-frontend/lcov.info\n        flags: unittests\n        name: codecov-umbrella\n\n    - name: Check coverage thresholds\n      run: |\n        npm run test:coverage:check\n\n  integration-tests:\n    name: Integration Tests\n    runs-on: ubuntu-latest\n    \n    services:\n      postgres:\n        image: postgres:14\n        env:\n          POSTGRES_PASSWORD: test\n          POSTGRES_USER: test\n          POSTGRES_DB: test_db\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 5433:5432\n\n      redis:\n        image: redis:7\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 6380:6379\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v4\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'npm'\n\n    - name: Install dependencies\n      run: npm ci\n\n    - name: Run integration tests\n      env:\n        TEST_DB_HOST: localhost\n        TEST_DB_PORT: 5433\n        TEST_DB_USERNAME: test\n        TEST_DB_PASSWORD: test\n        TEST_DB_NAME: test_db\n        TEST_REDIS_URL: redis://localhost:6380\n      run: npm run test:integration\n\n  e2e-tests:\n    name: E2E Tests\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout\n      uses: actions/checkout@v4\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'npm'\n\n    - name: Install dependencies\n      run: npm ci\n\n    - name: Install Playwright browsers\n      run: npx playwright install --with-deps\n\n    - name: Build application\n      run: npm run build\n\n    - name: Run E2E tests\n      run: npm run test:e2e\n\n    - name: Upload E2E test results\n      uses: actions/upload-artifact@v4\n      if: always()\n      with:\n        name: playwright-report\n        path: playwright-report/\n        retention-days: 30\n\n  quality-check:\n    name: Quality Gates\n    runs-on: ubuntu-latest\n    needs: [unit-tests, integration-tests, e2e-tests]\n    \n    steps:\n    - name: Checkout\n      uses: actions/checkout@v4\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'npm'\n\n    - name: Install dependencies\n      run: npm ci\n\n    - name: Run linting\n      run: npm run lint\n\n    - name: Run type checking\n      run: npm run type-check\n\n    - name: Validate test coverage\n      run: |\n        npm run test:coverage:validate\n        \n    - name: Generate test report\n      run: |\n        npm run test:report:generate\n\n    - name: Quality gate check\n      run: |\n        echo \"\u2705 All quality gates passed!\"\n        echo \"\ud83d\udcca Test Coverage: $(cat coverage/coverage-summary.json | jq '.total.lines.pct')%\"\n        echo \"\ud83e\uddea Total Tests: $(cat test-results/summary.json | jq '.numTotalTests')\"\n        echo \"\u2705 Passing Tests: $(cat test-results/summary.json | jq '.numPassedTests')\"\n"})}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-validation/code-review-process",children:"Code Review Process"})})," - Manual code quality validation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline",children:"CI/CD Pipeline"})})," - Automated test execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/performance-testing",children:"Performance Testing"})})," - Specialized performance validation"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"This continuous testing guide should be regularly updated to incorporate new testing tools and methodologies."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},7814:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(9729);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);