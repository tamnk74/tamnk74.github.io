"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[5723],{1195:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>E,contentTitle:()=>d,default:()=>l,frontMatter:()=>s,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"coding-conventions/database-conventions","title":"Database Conventions","description":"Comprehensive guidelines for database design, optimization, and management practices covering schema design, query optimization, data modeling, and security best practices.","source":"@site/docs/coding-conventions/database-conventions.md","sourceDirName":"coding-conventions","slug":"/coding-conventions/database-conventions","permalink":"/fullstack-dev/docs/coding-conventions/database-conventions","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/coding-conventions/database-conventions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"NestJS Guidelines","permalink":"/fullstack-dev/docs/coding-conventions/nestjs-guidelines"},"next":{"title":"Building Intelligent E-commerce Recommendations with RAG","permalink":"/fullstack-dev/docs/rag-recommendations/"}}');var i=a(5813),r=a(7814);const s={},d="Database Conventions",E={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Database Design Principles",id:"database-design-principles",level:2},{value:"Normalization and Denormalization",id:"normalization-and-denormalization",level:3},{value:"Referential Integrity and Constraints",id:"referential-integrity-and-constraints",level:3},{value:"Naming Conventions",id:"naming-conventions",level:2},{value:"Table and Column Naming",id:"table-and-column-naming",level:3},{value:"Index Naming",id:"index-naming",level:3},{value:"Schema Design Patterns",id:"schema-design-patterns",level:2},{value:"Soft Delete Pattern",id:"soft-delete-pattern",level:3},{value:"Audit Trail Pattern",id:"audit-trail-pattern",level:3},{value:"Versioning Pattern",id:"versioning-pattern",level:3},{value:"Indexing Strategies",id:"indexing-strategies",level:2},{value:"Composite Index Design",id:"composite-index-design",level:3},{value:"Partial and Functional Indexes",id:"partial-and-functional-indexes",level:3},{value:"Index Maintenance",id:"index-maintenance",level:3},{value:"Query Optimization",id:"query-optimization",level:2},{value:"Efficient Join Patterns",id:"efficient-join-patterns",level:3},{value:"Query Performance Optimization",id:"query-performance-optimization",level:3},{value:"Pagination Best Practices",id:"pagination-best-practices",level:3},{value:"Data Migration Patterns",id:"data-migration-patterns",level:2},{value:"Safe Migration Strategies",id:"safe-migration-strategies",level:3},{value:"Data Transformation Migrations",id:"data-transformation-migrations",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"Row Level Security (RLS)",id:"row-level-security-rls",level:3},{value:"Data Encryption and Masking",id:"data-encryption-and-masking",level:3},{value:"SQL Injection Prevention",id:"sql-injection-prevention",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:2},{value:"Query Performance Tracking",id:"query-performance-tracking",level:3},{value:"Database Health Monitoring",id:"database-health-monitoring",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2}];function _(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"database-conventions",children:"Database Conventions"})}),"\n",(0,i.jsx)(n.p,{children:"Comprehensive guidelines for database design, optimization, and management practices covering schema design, query optimization, data modeling, and security best practices."}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#database-design-principles",children:"Database Design Principles"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#naming-conventions",children:"Naming Conventions"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#schema-design-patterns",children:"Schema Design Patterns"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#indexing-strategies",children:"Indexing Strategies"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#query-optimization",children:"Query Optimization"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#data-migration-patterns",children:"Data Migration Patterns"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#security-best-practices",children:"Security Best Practices"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#performance-monitoring",children:"Performance Monitoring"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"database-design-principles",children:"Database Design Principles"}),"\n",(0,i.jsx)(n.h3,{id:"normalization-and-denormalization",children:"Normalization and Denormalization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Good: Normalized design for transactional data\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    first_name VARCHAR(100) NOT NULL,\n    last_name VARCHAR(100) NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE user_profiles (\n    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,\n    bio TEXT,\n    avatar_url VARCHAR(500),\n    date_of_birth DATE,\n    phone_number VARCHAR(20),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE addresses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    type VARCHAR(20) NOT NULL CHECK (type IN ('billing', 'shipping', 'home', 'work')),\n    street_line_1 VARCHAR(255) NOT NULL,\n    street_line_2 VARCHAR(255),\n    city VARCHAR(100) NOT NULL,\n    state_province VARCHAR(100),\n    postal_code VARCHAR(20),\n    country_code CHAR(2) NOT NULL,\n    is_default BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    \n    UNIQUE(user_id, type, is_default) WHERE is_default = TRUE\n);\n\n-- Strategic denormalization for read-heavy analytics\nCREATE TABLE order_analytics (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    order_id UUID NOT NULL REFERENCES orders(id),\n    user_id UUID NOT NULL,\n    user_email VARCHAR(255) NOT NULL, -- Denormalized for faster queries\n    order_total DECIMAL(10,2) NOT NULL,\n    order_date DATE NOT NULL,\n    customer_segment VARCHAR(50),\n    product_categories TEXT[], -- Array for faster filtering\n    order_month DATE GENERATED ALWAYS AS (DATE_TRUNC('month', order_date)) STORED,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"referential-integrity-and-constraints",children:"Referential Integrity and Constraints"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Foreign key constraints with appropriate actions\nCREATE TABLE orders (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT,\n    status VARCHAR(20) NOT NULL DEFAULT 'pending' \n        CHECK (status IN ('pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled')),\n    total_amount DECIMAL(10,2) NOT NULL CHECK (total_amount >= 0),\n    currency_code CHAR(3) NOT NULL DEFAULT 'USD',\n    shipping_address_id UUID REFERENCES addresses(id) ON DELETE SET NULL,\n    billing_address_id UUID REFERENCES addresses(id) ON DELETE SET NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    \n    -- Ensure billing address belongs to the user\n    CONSTRAINT fk_billing_address_user \n        FOREIGN KEY (billing_address_id, user_id) \n        REFERENCES addresses(id, user_id),\n    \n    -- Ensure shipping address belongs to the user\n    CONSTRAINT fk_shipping_address_user \n        FOREIGN KEY (shipping_address_id, user_id) \n        REFERENCES addresses(id, user_id)\n);\n\n-- Check constraints for business rules\nCREATE TABLE products (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    sku VARCHAR(50) UNIQUE NOT NULL,\n    name VARCHAR(255) NOT NULL,\n    description TEXT,\n    price DECIMAL(10,2) NOT NULL CHECK (price > 0),\n    cost DECIMAL(10,2) CHECK (cost >= 0 AND cost <= price),\n    weight_kg DECIMAL(8,3) CHECK (weight_kg > 0),\n    stock_quantity INTEGER NOT NULL DEFAULT 0 CHECK (stock_quantity >= 0),\n    min_stock_level INTEGER NOT NULL DEFAULT 0 CHECK (min_stock_level >= 0),\n    max_stock_level INTEGER CHECK (max_stock_level IS NULL OR max_stock_level >= min_stock_level),\n    is_active BOOLEAN NOT NULL DEFAULT TRUE,\n    category_id UUID REFERENCES categories(id) ON DELETE SET NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    \n    -- Ensure logical stock levels\n    CONSTRAINT check_stock_levels \n        CHECK (max_stock_level IS NULL OR stock_quantity <= max_stock_level)\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"naming-conventions",children:"Naming Conventions"}),"\n",(0,i.jsx)(n.h3,{id:"table-and-column-naming",children:"Table and Column Naming"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Good: Clear, consistent naming conventions\n\n-- Tables: plural nouns, snake_case\nCREATE TABLE user_sessions (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    session_token VARCHAR(255) UNIQUE NOT NULL,\n    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    last_accessed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    ip_address INET,\n    user_agent TEXT\n);\n\n-- Junction tables: combine table names\nCREATE TABLE user_roles (\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,\n    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    assigned_by UUID REFERENCES users(id),\n    \n    PRIMARY KEY (user_id, role_id)\n);\n\n-- Audit tables: prefix with original table name\nCREATE TABLE order_audit_log (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,\n    action VARCHAR(20) NOT NULL CHECK (action IN ('CREATE', 'UPDATE', 'DELETE')),\n    old_values JSONB,\n    new_values JSONB,\n    changed_by UUID REFERENCES users(id),\n    changed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    change_reason TEXT\n);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"index-naming",children:"Index Naming"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Index naming convention: idx_[table]_[columns]_[type]\nCREATE INDEX idx_orders_user_id_status ON orders(user_id, status);\nCREATE INDEX idx_orders_created_at_btree ON orders(created_at);\nCREATE INDEX idx_products_name_gin ON products USING gin(to_tsvector('english', name));\n\n-- Unique index naming: uniq_[table]_[columns]\nCREATE UNIQUE INDEX uniq_users_email_active ON users(email) WHERE is_active = TRUE;\n\n-- Partial index naming: idx_[table]_[columns]_[condition]\nCREATE INDEX idx_orders_total_amount_large ON orders(total_amount) \nWHERE total_amount > 1000;\n\n-- Functional index naming: idx_[table]_[function]_[columns]\nCREATE INDEX idx_users_email_lower ON users(lower(email));\n"})}),"\n",(0,i.jsx)(n.h2,{id:"schema-design-patterns",children:"Schema Design Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"soft-delete-pattern",children:"Soft Delete Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Soft delete implementation\nCREATE TABLE categories (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    name VARCHAR(100) NOT NULL,\n    description TEXT,\n    parent_category_id UUID REFERENCES categories(id),\n    display_order INTEGER DEFAULT 0,\n    is_active BOOLEAN NOT NULL DEFAULT TRUE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    deleted_at TIMESTAMP WITH TIME ZONE,\n    \n    -- Unique constraint that ignores soft-deleted records\n    UNIQUE(name, parent_category_id) WHERE deleted_at IS NULL\n);\n\n-- View for active records only\nCREATE VIEW active_categories AS\nSELECT id, name, description, parent_category_id, display_order, \n       created_at, updated_at\nFROM categories\nWHERE deleted_at IS NULL;\n\n-- Function to soft delete with cascade\nCREATE OR REPLACE FUNCTION soft_delete_category(category_id UUID)\nRETURNS VOID AS $$\nBEGIN\n    -- Soft delete the category\n    UPDATE categories \n    SET deleted_at = CURRENT_TIMESTAMP,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE id = category_id AND deleted_at IS NULL;\n    \n    -- Soft delete all child categories\n    UPDATE categories \n    SET deleted_at = CURRENT_TIMESTAMP,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE parent_category_id = category_id AND deleted_at IS NULL;\n    \n    -- Update products to remove category reference\n    UPDATE products \n    SET category_id = NULL,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE category_id = category_id;\nEND;\n$$ LANGUAGE plpgsql;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"audit-trail-pattern",children:"Audit Trail Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Generic audit trail implementation\nCREATE TABLE audit_log (\n    id BIGSERIAL PRIMARY KEY,\n    table_name VARCHAR(50) NOT NULL,\n    record_id UUID NOT NULL,\n    operation VARCHAR(10) NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE')),\n    old_values JSONB,\n    new_values JSONB,\n    changed_fields TEXT[],\n    user_id UUID REFERENCES users(id),\n    session_id UUID,\n    ip_address INET,\n    user_agent TEXT,\n    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    \n    -- Index for common queries\n    INDEX idx_audit_log_table_record (table_name, record_id),\n    INDEX idx_audit_log_timestamp (timestamp),\n    INDEX idx_audit_log_user_id (user_id)\n);\n\n-- Trigger function for automatic audit logging\nCREATE OR REPLACE FUNCTION create_audit_log()\nRETURNS TRIGGER AS $$\nDECLARE\n    old_data JSONB;\n    new_data JSONB;\n    changed_fields TEXT[] = '{}';\n    field_name TEXT;\nBEGIN\n    -- Determine operation type\n    IF TG_OP = 'DELETE' THEN\n        old_data = to_jsonb(OLD);\n        new_data = NULL;\n    ELSIF TG_OP = 'INSERT' THEN\n        old_data = NULL;\n        new_data = to_jsonb(NEW);\n    ELSIF TG_OP = 'UPDATE' THEN\n        old_data = to_jsonb(OLD);\n        new_data = to_jsonb(NEW);\n        \n        -- Identify changed fields\n        FOR field_name IN SELECT key FROM jsonb_each(new_data) LOOP\n            IF old_data->field_name IS DISTINCT FROM new_data->field_name THEN\n                changed_fields = array_append(changed_fields, field_name);\n            END IF;\n        END LOOP;\n    END IF;\n    \n    -- Insert audit record\n    INSERT INTO audit_log (\n        table_name, record_id, operation, old_values, new_values, \n        changed_fields, user_id, session_id, ip_address\n    ) VALUES (\n        TG_TABLE_NAME,\n        COALESCE(NEW.id, OLD.id),\n        TG_OP,\n        old_data,\n        new_data,\n        changed_fields,\n        current_setting('app.current_user_id', TRUE)::UUID,\n        current_setting('app.current_session_id', TRUE)::UUID,\n        current_setting('app.current_ip_address', TRUE)::INET\n    );\n    \n    RETURN COALESCE(NEW, OLD);\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Apply audit trigger to tables\nCREATE TRIGGER audit_trigger_users\n    AFTER INSERT OR UPDATE OR DELETE ON users\n    FOR EACH ROW EXECUTE FUNCTION create_audit_log();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"versioning-pattern",children:"Versioning Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Document versioning system\nCREATE TABLE documents (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    current_version_id UUID,\n    title VARCHAR(255) NOT NULL,\n    created_by UUID NOT NULL REFERENCES users(id),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE document_versions (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,\n    version_number INTEGER NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    content_type VARCHAR(50) DEFAULT 'text/plain',\n    change_summary TEXT,\n    created_by UUID NOT NULL REFERENCES users(id),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    \n    UNIQUE(document_id, version_number)\n);\n\n-- Add foreign key after both tables are created\nALTER TABLE documents \nADD CONSTRAINT fk_documents_current_version \nFOREIGN KEY (current_version_id) REFERENCES document_versions(id);\n\n-- Function to create new document version\nCREATE OR REPLACE FUNCTION create_document_version(\n    p_document_id UUID,\n    p_title VARCHAR(255),\n    p_content TEXT,\n    p_change_summary TEXT,\n    p_user_id UUID\n) RETURNS UUID AS $$\nDECLARE\n    next_version INTEGER;\n    version_id UUID;\nBEGIN\n    -- Get next version number\n    SELECT COALESCE(MAX(version_number), 0) + 1 \n    INTO next_version\n    FROM document_versions \n    WHERE document_id = p_document_id;\n    \n    -- Create new version\n    INSERT INTO document_versions (\n        document_id, version_number, title, content, \n        change_summary, created_by\n    ) VALUES (\n        p_document_id, next_version, p_title, p_content,\n        p_change_summary, p_user_id\n    ) RETURNING id INTO version_id;\n    \n    -- Update document to point to new version\n    UPDATE documents \n    SET current_version_id = version_id,\n        title = p_title,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE id = p_document_id;\n    \n    RETURN version_id;\nEND;\n$$ LANGUAGE plpgsql;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"indexing-strategies",children:"Indexing Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"composite-index-design",children:"Composite Index Design"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Order of columns in composite indexes matters\n-- Most selective column first, then by query patterns\n\n-- Good: Status is selective, created_at for range queries\nCREATE INDEX idx_orders_status_created_at ON orders(status, created_at);\n\n-- Query this index supports efficiently:\nSELECT * FROM orders \nWHERE status = 'pending' \nAND created_at >= '2024-01-01'\nORDER BY created_at DESC;\n\n-- Multi-column index for complex queries\nCREATE INDEX idx_products_category_active_price ON products(category_id, is_active, price)\nWHERE is_active = TRUE;\n\n-- Supports queries like:\nSELECT * FROM products \nWHERE category_id = 'uuid-here' \nAND is_active = TRUE \nAND price BETWEEN 10.00 AND 100.00;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"partial-and-functional-indexes",children:"Partial and Functional Indexes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Partial indexes for specific conditions\nCREATE INDEX idx_orders_pending_created_at ON orders(created_at)\nWHERE status = 'pending';\n\nCREATE INDEX idx_users_active_email ON users(email)\nWHERE is_active = TRUE AND deleted_at IS NULL;\n\n-- Functional indexes for case-insensitive searches\nCREATE INDEX idx_users_email_lower ON users(lower(email));\nCREATE INDEX idx_products_name_lower ON products(lower(name));\n\n-- GIN indexes for array and JSON columns\nCREATE INDEX idx_order_analytics_categories_gin ON order_analytics \nUSING gin(product_categories);\n\nCREATE INDEX idx_user_preferences_gin ON user_profiles \nUSING gin(preferences) WHERE preferences IS NOT NULL;\n\n-- Full-text search indexes\nCREATE INDEX idx_products_search_text ON products \nUSING gin(to_tsvector('english', name || ' ' || COALESCE(description, '')));\n\n-- Usage example for full-text search:\nSELECT id, name, description,\n       ts_rank(to_tsvector('english', name || ' ' || COALESCE(description, '')), \n               plainto_tsquery('english', 'search term')) as rank\nFROM products\nWHERE to_tsvector('english', name || ' ' || COALESCE(description, '')) \n      @@ plainto_tsquery('english', 'search term')\nORDER BY rank DESC;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"index-maintenance",children:"Index Maintenance"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Monitor index usage\nSELECT \n    schemaname,\n    tablename,\n    indexname,\n    idx_scan as index_scans,\n    idx_tup_read as tuples_read,\n    idx_tup_fetch as tuples_fetched\nFROM pg_stat_user_indexes\nORDER BY idx_scan DESC;\n\n-- Find unused indexes\nSELECT \n    schemaname,\n    tablename,\n    indexname,\n    idx_scan\nFROM pg_stat_user_indexes\nWHERE idx_scan = 0\nAND indexname NOT LIKE '%_pkey';\n\n-- Index bloat monitoring\nSELECT \n    schemaname,\n    tablename,\n    indexname,\n    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,\n    idx_scan,\n    round(100 * idx_scan::numeric / NULLIF(seq_scan + idx_scan, 0), 2) as index_usage_pct\nFROM pg_stat_user_indexes\nJOIN pg_stat_user_tables USING (schemaname, tablename)\nORDER BY pg_relation_size(indexrelid) DESC;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"query-optimization",children:"Query Optimization"}),"\n",(0,i.jsx)(n.h3,{id:"efficient-join-patterns",children:"Efficient Join Patterns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Good: Use appropriate join types and conditions\nSELECT \n    u.id,\n    u.email,\n    u.first_name,\n    u.last_name,\n    p.bio,\n    COUNT(o.id) as order_count,\n    SUM(o.total_amount) as total_spent\nFROM users u\nLEFT JOIN user_profiles p ON u.id = p.user_id\nLEFT JOIN orders o ON u.id = o.user_id AND o.status = 'delivered'\nWHERE u.is_active = TRUE\nGROUP BY u.id, u.email, u.first_name, u.last_name, p.bio\nHAVING COUNT(o.id) > 0\nORDER BY total_spent DESC NULLS LAST\nLIMIT 100;\n\n-- Use EXISTS instead of IN for better performance with large datasets\nSELECT p.id, p.name, p.price\nFROM products p\nWHERE EXISTS (\n    SELECT 1 FROM order_items oi \n    WHERE oi.product_id = p.id \n    AND oi.created_at >= CURRENT_DATE - INTERVAL '30 days'\n)\nAND p.is_active = TRUE;\n\n-- Window functions for analytics\nSELECT \n    user_id,\n    order_date,\n    total_amount,\n    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY order_date) as order_sequence,\n    LAG(total_amount) OVER (PARTITION BY user_id ORDER BY order_date) as previous_order_amount,\n    SUM(total_amount) OVER (PARTITION BY user_id ORDER BY order_date ROWS UNBOUNDED PRECEDING) as running_total\nFROM orders\nWHERE status = 'delivered'\nORDER BY user_id, order_date;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"query-performance-optimization",children:"Query Performance Optimization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Use EXPLAIN ANALYZE to understand query performance\nEXPLAIN (ANALYZE, BUFFERS, FORMAT JSON)\nSELECT \n    u.email,\n    COUNT(o.id) as order_count,\n    AVG(o.total_amount) as avg_order_value\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.created_at >= CURRENT_DATE - INTERVAL '90 days'\nGROUP BY u.id, u.email\nHAVING COUNT(o.id) >= 5\nORDER BY avg_order_value DESC;\n\n-- Optimize with CTEs for complex queries\nWITH recent_orders AS (\n    SELECT \n        user_id,\n        COUNT(*) as order_count,\n        AVG(total_amount) as avg_order_value,\n        MAX(created_at) as last_order_date\n    FROM orders \n    WHERE created_at >= CURRENT_DATE - INTERVAL '90 days'\n    AND status = 'delivered'\n    GROUP BY user_id\n    HAVING COUNT(*) >= 5\n),\nuser_segments AS (\n    SELECT \n        user_id,\n        order_count,\n        avg_order_value,\n        last_order_date,\n        CASE \n            WHEN avg_order_value >= 500 THEN 'premium'\n            WHEN avg_order_value >= 100 THEN 'standard'\n            ELSE 'budget'\n        END as customer_segment\n    FROM recent_orders\n)\nSELECT \n    u.email,\n    u.first_name,\n    u.last_name,\n    us.customer_segment,\n    us.order_count,\n    us.avg_order_value,\n    us.last_order_date\nFROM users u\nJOIN user_segments us ON u.id = us.user_id\nORDER BY us.avg_order_value DESC;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pagination-best-practices",children:"Pagination Best Practices"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Cursor-based pagination for large datasets\n-- Instead of OFFSET which becomes slow with large offsets\nCREATE OR REPLACE FUNCTION get_orders_cursor(\n    cursor_id UUID DEFAULT NULL,\n    page_size INTEGER DEFAULT 20,\n    order_direction TEXT DEFAULT 'ASC'\n) RETURNS TABLE (\n    id UUID,\n    user_id UUID,\n    total_amount DECIMAL(10,2),\n    created_at TIMESTAMP WITH TIME ZONE,\n    has_next_page BOOLEAN\n) AS $$\nDECLARE\n    direction_operator TEXT;\n    order_clause TEXT;\nBEGIN\n    -- Determine comparison operator based on direction\n    direction_operator := CASE WHEN order_direction = 'DESC' THEN '<' ELSE '>' END;\n    order_clause := 'ORDER BY created_at ' || order_direction || ', id ' || order_direction;\n    \n    RETURN QUERY EXECUTE format('\n        WITH page_data AS (\n            SELECT o.id, o.user_id, o.total_amount, o.created_at\n            FROM orders o\n            WHERE ($1 IS NULL OR o.created_at %s $2 OR (o.created_at = $2 AND o.id %s $1))\n            %s\n            LIMIT $3 + 1\n        )\n        SELECT \n            pd.id,\n            pd.user_id,\n            pd.total_amount,\n            pd.created_at,\n            (SELECT COUNT(*) FROM page_data) > $3 as has_next_page\n        FROM page_data pd\n        LIMIT $3',\n        direction_operator,\n        direction_operator,\n        order_clause\n    ) USING cursor_id, \n            CASE WHEN cursor_id IS NOT NULL THEN \n                (SELECT created_at FROM orders WHERE id = cursor_id) \n            END,\n            page_size;\nEND;\n$$ LANGUAGE plpgsql;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"data-migration-patterns",children:"Data Migration Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"safe-migration-strategies",children:"Safe Migration Strategies"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Migration script template with rollback capability\n-- Migration: add_user_email_verification_fields\n-- Date: 2024-01-15\n-- Description: Add email verification fields to users table\n\nBEGIN;\n\n-- Store migration info\nINSERT INTO schema_migrations (version, description, applied_at)\nVALUES ('20240115001', 'add_user_email_verification_fields', CURRENT_TIMESTAMP);\n\n-- Add new columns with safe defaults\nALTER TABLE users \nADD COLUMN email_verified BOOLEAN DEFAULT FALSE,\nADD COLUMN email_verification_token VARCHAR(255),\nADD COLUMN email_verification_sent_at TIMESTAMP WITH TIME ZONE,\nADD COLUMN email_verification_expires_at TIMESTAMP WITH TIME ZONE;\n\n-- Create index for verification tokens\nCREATE INDEX idx_users_email_verification_token \nON users(email_verification_token) \nWHERE email_verification_token IS NOT NULL;\n\n-- Update existing users to be verified (existing users are trusted)\nUPDATE users \nSET email_verified = TRUE \nWHERE created_at < CURRENT_TIMESTAMP - INTERVAL '1 day';\n\n-- Add constraint to ensure token expiry is after sent time\nALTER TABLE users \nADD CONSTRAINT check_email_verification_expiry \nCHECK (email_verification_expires_at IS NULL OR \n       email_verification_sent_at IS NULL OR \n       email_verification_expires_at > email_verification_sent_at);\n\nCOMMIT;\n\n-- Rollback script (run separately if needed)\n/*\nBEGIN;\n\n-- Remove constraint\nALTER TABLE users DROP CONSTRAINT IF EXISTS check_email_verification_expiry;\n\n-- Remove index\nDROP INDEX IF EXISTS idx_users_email_verification_token;\n\n-- Remove columns\nALTER TABLE users \nDROP COLUMN IF EXISTS email_verified,\nDROP COLUMN IF EXISTS email_verification_token,\nDROP COLUMN IF EXISTS email_verification_sent_at,\nDROP COLUMN IF EXISTS email_verification_expires_at;\n\n-- Remove migration record\nDELETE FROM schema_migrations WHERE version = '20240115001';\n\nCOMMIT;\n*/\n"})}),"\n",(0,i.jsx)(n.h3,{id:"data-transformation-migrations",children:"Data Transformation Migrations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Complex data transformation with backup\n-- Migration: normalize_user_names\nBEGIN;\n\n-- Create backup table\nCREATE TABLE users_backup_20240115 AS \nSELECT * FROM users;\n\n-- Add temporary columns for normalized data\nALTER TABLE users \nADD COLUMN first_name_normalized VARCHAR(100),\nADD COLUMN last_name_normalized VARCHAR(100);\n\n-- Normalize existing data\nUPDATE users \nSET \n    first_name_normalized = TRIM(REGEXP_REPLACE(first_name, '\\s+', ' ', 'g')),\n    last_name_normalized = TRIM(REGEXP_REPLACE(last_name, '\\s+', ' ', 'g'))\nWHERE first_name IS NOT NULL OR last_name IS NOT NULL;\n\n-- Validate data transformation\nDO $$\nDECLARE\n    invalid_count INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO invalid_count\n    FROM users \n    WHERE (first_name IS NOT NULL AND first_name_normalized IS NULL)\n       OR (last_name IS NOT NULL AND last_name_normalized IS NULL);\n       \n    IF invalid_count > 0 THEN\n        RAISE EXCEPTION 'Data transformation validation failed: % invalid records', invalid_count;\n    END IF;\nEND $$;\n\n-- Replace original columns\nALTER TABLE users \nDROP COLUMN first_name,\nDROP COLUMN last_name;\n\nALTER TABLE users \nRENAME COLUMN first_name_normalized TO first_name;\n\nALTER TABLE users \nRENAME COLUMN last_name_normalized TO last_name;\n\n-- Add constraints to new columns\nALTER TABLE users \nALTER COLUMN first_name SET NOT NULL,\nALTER COLUMN last_name SET NOT NULL;\n\nINSERT INTO schema_migrations (version, description, applied_at)\nVALUES ('20240115002', 'normalize_user_names', CURRENT_TIMESTAMP);\n\nCOMMIT;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"row-level-security-rls",children:"Row Level Security (RLS)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Enable RLS on sensitive tables\nALTER TABLE orders ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;\nALTER TABLE addresses ENABLE ROW LEVEL SECURITY;\n\n-- Policy for users to see only their own orders\nCREATE POLICY user_orders_policy ON orders\nFOR ALL TO app_user\nUSING (user_id = current_setting('app.current_user_id')::UUID);\n\n-- Policy for admins to see all orders\nCREATE POLICY admin_orders_policy ON orders\nFOR ALL TO app_admin\nUSING (true);\n\n-- Policy for users to manage their own profile\nCREATE POLICY user_profile_policy ON user_profiles\nFOR ALL TO app_user\nUSING (user_id = current_setting('app.current_user_id')::UUID)\nWITH CHECK (user_id = current_setting('app.current_user_id')::UUID);\n\n-- Read-only policy for public product information\nCREATE POLICY products_public_read ON products\nFOR SELECT TO app_user, app_guest\nUSING (is_active = TRUE AND deleted_at IS NULL);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"data-encryption-and-masking",children:"Data Encryption and Masking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Store sensitive data encrypted\nCREATE EXTENSION IF NOT EXISTS pgcrypto;\n\nCREATE TABLE payment_methods (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    type VARCHAR(20) NOT NULL CHECK (type IN ('credit_card', 'debit_card', 'bank_account')),\n    encrypted_number BYTEA NOT NULL, -- Encrypted card/account number\n    last_four CHAR(4) NOT NULL, -- Last 4 digits for display\n    encrypted_expiry BYTEA, -- Encrypted expiry date\n    cardholder_name VARCHAR(255),\n    is_default BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    \n    UNIQUE(user_id, is_default) WHERE is_default = TRUE\n);\n\n-- Function to encrypt sensitive data\nCREATE OR REPLACE FUNCTION encrypt_payment_data(\n    card_number TEXT,\n    expiry_date TEXT,\n    encryption_key TEXT\n) RETURNS TABLE (\n    encrypted_number BYTEA,\n    encrypted_expiry BYTEA,\n    last_four CHAR(4)\n) AS $$\nBEGIN\n    RETURN QUERY SELECT \n        pgp_sym_encrypt(card_number, encryption_key)::BYTEA,\n        pgp_sym_encrypt(expiry_date, encryption_key)::BYTEA,\n        RIGHT(card_number, 4)::CHAR(4);\nEND;\n$$ LANGUAGE plpgsql;\n\n-- View for displaying masked payment methods\nCREATE VIEW user_payment_methods_view AS\nSELECT \n    id,\n    user_id,\n    type,\n    CASE \n        WHEN type = 'credit_card' THEN '**** **** **** ' || last_four\n        WHEN type = 'bank_account' THEN '****' || last_four\n        ELSE '**** **** **** ****'\n    END as masked_number,\n    cardholder_name,\n    is_default,\n    created_at\nFROM payment_methods;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"sql-injection-prevention",children:"SQL Injection Prevention"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Use parameterized queries and proper escaping\n-- Example of secure dynamic query building\nCREATE OR REPLACE FUNCTION search_products(\n    search_term TEXT,\n    category_filter UUID DEFAULT NULL,\n    min_price DECIMAL DEFAULT NULL,\n    max_price DECIMAL DEFAULT NULL,\n    sort_by TEXT DEFAULT 'name',\n    sort_order TEXT DEFAULT 'ASC'\n) RETURNS TABLE (\n    id UUID,\n    name VARCHAR(255),\n    price DECIMAL(10,2),\n    category_name VARCHAR(100)\n) AS $$\nDECLARE\n    query_text TEXT;\n    sort_column TEXT;\nBEGIN\n    -- Validate and sanitize sort parameters\n    CASE sort_by\n        WHEN 'name' THEN sort_column := 'p.name';\n        WHEN 'price' THEN sort_column := 'p.price';\n        WHEN 'created_at' THEN sort_column := 'p.created_at';\n        ELSE sort_column := 'p.name';\n    END CASE;\n    \n    IF sort_order NOT IN ('ASC', 'DESC') THEN\n        sort_order := 'ASC';\n    END IF;\n    \n    -- Build query with proper parameterization\n    query_text := '\n        SELECT p.id, p.name, p.price, c.name as category_name\n        FROM products p\n        LEFT JOIN categories c ON p.category_id = c.id\n        WHERE p.is_active = TRUE\n        AND p.deleted_at IS NULL\n        AND ($1 IS NULL OR to_tsvector(''english'', p.name || '' '' || COALESCE(p.description, '''')) @@ plainto_tsquery(''english'', $1))\n        AND ($2 IS NULL OR p.category_id = $2)\n        AND ($3 IS NULL OR p.price >= $3)\n        AND ($4 IS NULL OR p.price <= $4)\n        ORDER BY ' || sort_column || ' ' || sort_order;\n    \n    RETURN QUERY EXECUTE query_text \n    USING search_term, category_filter, min_price, max_price;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Grant execute permission to specific roles\nGRANT EXECUTE ON FUNCTION search_products TO app_user;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,i.jsx)(n.h3,{id:"query-performance-tracking",children:"Query Performance Tracking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Enable query statistics collection\n-- Add to postgresql.conf:\n-- shared_preload_libraries = 'pg_stat_statements'\n-- pg_stat_statements.track = all\n-- pg_stat_statements.max = 10000\n\n-- Query to find slow queries\nSELECT \n    query,\n    calls,\n    total_time,\n    total_time/calls as avg_time,\n    stddev_time,\n    rows,\n    100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent\nFROM pg_stat_statements\nWHERE calls > 100\nORDER BY total_time DESC\nLIMIT 20;\n\n-- Find queries with high I/O\nSELECT \n    query,\n    calls,\n    shared_blks_read,\n    shared_blks_written,\n    shared_blks_dirtied,\n    shared_blks_hit,\n    temp_blks_read,\n    temp_blks_written\nFROM pg_stat_statements\nWHERE shared_blks_read > 1000 OR temp_blks_read > 100\nORDER BY shared_blks_read + temp_blks_read DESC;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"database-health-monitoring",children:"Database Health Monitoring"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Create monitoring views for database health\nCREATE VIEW database_health_summary AS\nSELECT \n    'connections' as metric,\n    current_setting('max_connections')::INTEGER as max_value,\n    COUNT(*) as current_value,\n    ROUND(100.0 * COUNT(*) / current_setting('max_connections')::INTEGER, 2) as usage_percent\nFROM pg_stat_activity\nWHERE state IS NOT NULL\nUNION ALL\nSELECT \n    'database_size' as metric,\n    NULL as max_value,\n    pg_database_size(current_database()) as current_value,\n    NULL as usage_percent\nUNION ALL\nSELECT \n    'cache_hit_ratio' as metric,\n    NULL as max_value,\n    ROUND(100.0 * sum(blks_hit) / nullif(sum(blks_hit + blks_read), 0), 2)::BIGINT as current_value,\n    NULL as usage_percent\nFROM pg_stat_database\nWHERE datname = current_database();\n\n-- Monitor table bloat\nCREATE VIEW table_bloat_summary AS\nSELECT \n    schemaname,\n    tablename,\n    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,\n    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,\n    n_tup_ins as inserts,\n    n_tup_upd as updates,\n    n_tup_del as deletes,\n    n_dead_tup as dead_tuples,\n    CASE WHEN n_live_tup > 0 \n         THEN ROUND(100.0 * n_dead_tup / n_live_tup, 2) \n         ELSE 0 \n    END as dead_tuple_percent\nFROM pg_stat_user_tables\nWHERE n_live_tup > 1000\nORDER BY n_dead_tup DESC;\n\n-- Automated maintenance tasks\nCREATE OR REPLACE FUNCTION run_maintenance_tasks()\nRETURNS TEXT AS $$\nDECLARE\n    result TEXT := '';\n    table_rec RECORD;\nBEGIN\n    -- Auto-vacuum tables with high dead tuple percentage\n    FOR table_rec IN \n        SELECT schemaname, tablename, dead_tuple_percent\n        FROM table_bloat_summary\n        WHERE dead_tuple_percent > 10\n    LOOP\n        EXECUTE 'VACUUM ANALYZE ' || quote_ident(table_rec.schemaname) || '.' || quote_ident(table_rec.tablename);\n        result := result || 'Vacuumed ' || table_rec.schemaname || '.' || table_rec.tablename || E'\\n';\n    END LOOP;\n    \n    -- Update table statistics\n    ANALYZE;\n    result := result || 'Updated table statistics' || E'\\n';\n    \n    RETURN result;\nEND;\n$$ LANGUAGE plpgsql;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Follow consistent naming conventions"})," for tables, columns, and constraints"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Design normalized schemas"})," with strategic denormalization for performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implement proper indexing strategies"})," based on query patterns"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use appropriate data types"})," and constraints for data integrity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Apply security best practices"})," including RLS and data encryption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitor query performance"})," and optimize slow queries"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Plan safe migration strategies"})," with rollback capabilities"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implement audit trails"})," for sensitive data changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use proper transaction management"})," for data consistency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Regular maintenance tasks"})," for optimal database performance"]}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(_,{...e})}):_(e)}},7814:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>d});var t=a(9729);const i={},r=t.createContext(i);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);