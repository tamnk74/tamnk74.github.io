"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[4479],{5734:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"architecture-practices/architecture-execution/security-scanning","title":"Security Scanning Guide","description":"This guide provides comprehensive security scanning strategies and automated vulnerability detection for NestJS microservices and Next.js microfrontend applications, covering static analysis, dynamic testing, dependency scanning, and infrastructure security assessment.","source":"@site/docs/architecture-practices/architecture-execution/security-scanning.md","sourceDirName":"architecture-practices/architecture-execution","slug":"/architecture-practices/architecture-execution/security-scanning","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/security-scanning","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-execution/security-scanning.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Rollback Procedures Guide","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/rollback-procedures"},"next":{"title":"Resource Scaling Guide","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/resource-scaling"}}');var r=t(5813),s=t(7814);const a={},c="Security Scanning Guide",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Security Scanning Architecture",id:"security-scanning-architecture",level:2},{value:"Complete Security Scanning Framework",id:"complete-security-scanning-framework",level:3},{value:"Static Application Security Testing (SAST)",id:"static-application-security-testing-sast",level:2},{value:"SAST Integration Service",id:"sast-integration-service",level:3},{value:"Dependency Scanning (SCA)",id:"dependency-scanning-sca",level:2},{value:"Software Composition Analysis Service",id:"software-composition-analysis-service",level:3},{value:"Dynamic Application Security Testing (DAST)",id:"dynamic-application-security-testing-dast",level:2},{value:"DAST Scanner Service",id:"dast-scanner-service",level:3},{value:"Container and Infrastructure Scanning",id:"container-and-infrastructure-scanning",level:2},{value:"Container Security Scanner",id:"container-security-scanner",level:3},{value:"Security Scanning CI/CD Integration",id:"security-scanning-cicd-integration",level:2},{value:"GitHub Actions Security Pipeline",id:"github-actions-security-pipeline",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function u(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"security-scanning-guide",children:"Security Scanning Guide"})}),"\n",(0,r.jsx)(e.p,{children:"This guide provides comprehensive security scanning strategies and automated vulnerability detection for NestJS microservices and Next.js microfrontend applications, covering static analysis, dynamic testing, dependency scanning, and infrastructure security assessment."}),"\n",(0,r.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(e.p,{children:"Security scanning is a critical component of the development lifecycle that helps identify vulnerabilities, security misconfigurations, and potential threats before they reach production. This guide covers automated security scanning pipelines, vulnerability management, and continuous security monitoring across the entire application stack."}),"\n",(0,r.jsx)(e.h2,{id:"security-scanning-architecture",children:"Security Scanning Architecture"}),"\n",(0,r.jsx)(e.h3,{id:"complete-security-scanning-framework",children:"Complete Security Scanning Framework"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mermaid",children:"graph TD\n    A[Code Repository] --\x3e B[Static Analysis]\n    A --\x3e C[Dependency Scanning]\n    A --\x3e D[Secrets Detection]\n    \n    B --\x3e E[SAST Results]\n    C --\x3e F[SCA Results]\n    D --\x3e G[Secret Scan Results]\n    \n    E --\x3e H[Vulnerability Database]\n    F --\x3e H\n    G --\x3e H\n    \n    H --\x3e I[Risk Assessment]\n    I --\x3e J[Severity Classification]\n    J --\x3e K[Remediation Prioritization]\n    \n    L[Running Application] --\x3e M[DAST Scanning]\n    L --\x3e N[IAST Monitoring]\n    L --\x3e O[Penetration Testing]\n    \n    M --\x3e P[Runtime Vulnerabilities]\n    N --\x3e Q[Interactive Analysis]\n    O --\x3e R[Manual Testing Results]\n    \n    P --\x3e H\n    Q --\x3e H\n    R --\x3e H\n    \n    S[Infrastructure] --\x3e T[Container Scanning]\n    S --\x3e U[Infrastructure as Code Scanning]\n    S --\x3e V[Cloud Security Posture]\n    \n    T --\x3e W[Container Vulnerabilities]\n    U --\x3e X[IaC Misconfigurations]\n    V --\x3e Y[Cloud Security Issues]\n    \n    W --\x3e H\n    X --\x3e H\n    Y --\x3e H\n    \n    K --\x3e Z[Security Dashboard]\n    Z --\x3e AA[Remediation Tracking]\n    Z --\x3e BB[Compliance Reporting]\n"})}),"\n",(0,r.jsx)(e.h2,{id:"static-application-security-testing-sast",children:"Static Application Security Testing (SAST)"}),"\n",(0,r.jsx)(e.h3,{id:"sast-integration-service",children:"SAST Integration Service"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/security/sast-scanner.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { HttpService } from '@nestjs/axios';\nimport { firstValueFrom } from 'rxjs';\n\nexport interface SASTVulnerability {\n  id: string;\n  title: string;\n  description: string;\n  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';\n  cwe: string;\n  owasp: string;\n  file: string;\n  line: number;\n  column: number;\n  code: string;\n  recommendation: string;\n  confidence: 'high' | 'medium' | 'low';\n  category: string;\n}\n\nexport interface SASTScanResult {\n  scanId: string;\n  timestamp: Date;\n  status: 'completed' | 'failed' | 'in-progress';\n  projectId: string;\n  branch: string;\n  commit: string;\n  vulnerabilities: SASTVulnerability[];\n  summary: {\n    total: number;\n    critical: number;\n    high: number;\n    medium: number;\n    low: number;\n    info: number;\n  };\n  metrics: {\n    scanDuration: number;\n    linesOfCode: number;\n    filesScanned: number;\n  };\n}\n\n@Injectable()\nexport class SASTScannerService {\n  private readonly logger = new Logger(SASTScannerService.name);\n\n  constructor(private readonly httpService: HttpService) {}\n\n  async initiateScan(\n    projectId: string,\n    repositoryUrl: string,\n    branch: string,\n    commit: string\n  ): Promise<string> {\n    this.logger.log(`Initiating SAST scan for project ${projectId}, branch ${branch}`);\n\n    try {\n      // Example integration with SonarQube\n      const sonarResponse = await firstValueFrom(\n        this.httpService.post('/api/ce/submit', {\n          projectKey: projectId,\n          repository: repositoryUrl,\n          branch: branch,\n          revision: commit,\n          sources: 'src/',\n          tests: 'src/**/*.spec.ts,src/**/*.test.ts',\n          exclusions: 'node_modules/**,build/**,dist/**',\n          'sonar.typescript.lcov.reportPaths': 'coverage/lcov.info',\n          'sonar.javascript.lcov.reportPaths': 'coverage/lcov.info',\n        })\n      );\n\n      const scanId = sonarResponse.data.taskId;\n\n      // Example integration with CodeQL\n      await this.initiateCodeQLScan(projectId, repositoryUrl, branch, commit);\n\n      // Example integration with Semgrep\n      await this.initiateSemgrepScan(projectId, repositoryUrl, branch, commit);\n\n      this.logger.log(`SAST scan initiated with ID: ${scanId}`);\n      return scanId;\n    } catch (error) {\n      this.logger.error('Failed to initiate SAST scan', error);\n      throw error;\n    }\n  }\n\n  private async initiateCodeQLScan(\n    projectId: string,\n    repositoryUrl: string,\n    branch: string,\n    commit: string\n  ): Promise<void> {\n    // CodeQL scanning integration\n    const codeqlConfig = {\n      database: projectId,\n      source: repositoryUrl,\n      commit: commit,\n      language: 'typescript',\n      queries: [\n        'security-and-quality',\n        'security-extended',\n        'cwe-top25-2021',\n      ],\n    };\n\n    this.logger.debug('Initiating CodeQL scan', codeqlConfig);\n    // Implementation would integrate with GitHub CodeQL or standalone CodeQL\n  }\n\n  private async initiateSemgrepScan(\n    projectId: string,\n    repositoryUrl: string,\n    branch: string,\n    commit: string\n  ): Promise<void> {\n    // Semgrep scanning integration\n    const semgrepConfig = {\n      config: [\n        'p/security-audit',\n        'p/nodejs',\n        'p/typescript',\n        'p/react',\n        'p/owasp-top-ten',\n      ],\n      severity: ['ERROR', 'WARNING'],\n      timeout: 300,\n    };\n\n    this.logger.debug('Initiating Semgrep scan', semgrepConfig);\n    // Implementation would integrate with Semgrep API or CLI\n  }\n\n  async getScanResults(scanId: string): Promise<SASTScanResult> {\n    this.logger.log(`Retrieving SAST scan results for scan ${scanId}`);\n\n    try {\n      // Aggregate results from multiple tools\n      const sonarResults = await this.getSonarResults(scanId);\n      const codeqlResults = await this.getCodeQLResults(scanId);\n      const semgrepResults = await this.getSemgrepResults(scanId);\n\n      const aggregatedResults = this.aggregateResults(\n        sonarResults,\n        codeqlResults,\n        semgrepResults\n      );\n\n      return aggregatedResults;\n    } catch (error) {\n      this.logger.error(`Failed to retrieve scan results for ${scanId}`, error);\n      throw error;\n    }\n  }\n\n  private async getSonarResults(scanId: string): Promise<Partial<SASTScanResult>> {\n    const response = await firstValueFrom(\n      this.httpService.get(`/api/ce/task?id=${scanId}`)\n    );\n\n    if (response.data.task.status !== 'SUCCESS') {\n      throw new Error(`SonarQube scan not completed: ${response.data.task.status}`);\n    }\n\n    const issuesResponse = await firstValueFrom(\n      this.httpService.get(`/api/issues/search?componentKeys=${response.data.task.componentKey}&types=VULNERABILITY,SECURITY_HOTSPOT`)\n    );\n\n    const vulnerabilities: SASTVulnerability[] = issuesResponse.data.issues.map(issue => ({\n      id: issue.key,\n      title: issue.message,\n      description: issue.message,\n      severity: this.mapSonarSeverity(issue.severity),\n      cwe: issue.rule.tags?.find(tag => tag.startsWith('cwe'))?.replace('cwe-', '') || 'Unknown',\n      owasp: issue.rule.tags?.find(tag => tag.startsWith('owasp'))?.replace('owasp-', '') || 'Unknown',\n      file: issue.component.replace(`${response.data.task.componentKey}:`, ''),\n      line: issue.line || 0,\n      column: 0,\n      code: issue.message,\n      recommendation: issue.rule.htmlDesc || '',\n      confidence: this.mapSonarConfidence(issue.severity),\n      category: issue.rule.type,\n    }));\n\n    return {\n      vulnerabilities,\n      summary: this.calculateSummary(vulnerabilities),\n    };\n  }\n\n  private async getCodeQLResults(scanId: string): Promise<Partial<SASTScanResult>> {\n    // Implementation would retrieve CodeQL results\n    // This is a placeholder returning mock data\n    return {\n      vulnerabilities: [],\n      summary: {\n        total: 0,\n        critical: 0,\n        high: 0,\n        medium: 0,\n        low: 0,\n        info: 0,\n      },\n    };\n  }\n\n  private async getSemgrepResults(scanId: string): Promise<Partial<SASTScanResult>> {\n    // Implementation would retrieve Semgrep results\n    // This is a placeholder returning mock data\n    return {\n      vulnerabilities: [],\n      summary: {\n        total: 0,\n        critical: 0,\n        high: 0,\n        medium: 0,\n        low: 0,\n        info: 0,\n      },\n    };\n  }\n\n  private aggregateResults(\n    ...results: Partial<SASTScanResult>[]\n  ): SASTScanResult {\n    const allVulnerabilities: SASTVulnerability[] = [];\n    \n    for (const result of results) {\n      if (result.vulnerabilities) {\n        allVulnerabilities.push(...result.vulnerabilities);\n      }\n    }\n\n    // Deduplicate vulnerabilities based on file, line, and CWE\n    const uniqueVulnerabilities = this.deduplicateVulnerabilities(allVulnerabilities);\n\n    return {\n      scanId: Date.now().toString(),\n      timestamp: new Date(),\n      status: 'completed',\n      projectId: 'example-project',\n      branch: 'main',\n      commit: 'abc123',\n      vulnerabilities: uniqueVulnerabilities,\n      summary: this.calculateSummary(uniqueVulnerabilities),\n      metrics: {\n        scanDuration: 120000, // 2 minutes\n        linesOfCode: 50000,\n        filesScanned: 500,\n      },\n    };\n  }\n\n  private deduplicateVulnerabilities(vulnerabilities: SASTVulnerability[]): SASTVulnerability[] {\n    const seen = new Set<string>();\n    return vulnerabilities.filter(vuln => {\n      const key = `${vuln.file}:${vuln.line}:${vuln.cwe}`;\n      if (seen.has(key)) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n  }\n\n  private calculateSummary(vulnerabilities: SASTVulnerability[]) {\n    const summary = {\n      total: vulnerabilities.length,\n      critical: 0,\n      high: 0,\n      medium: 0,\n      low: 0,\n      info: 0,\n    };\n\n    for (const vuln of vulnerabilities) {\n      summary[vuln.severity]++;\n    }\n\n    return summary;\n  }\n\n  private mapSonarSeverity(severity: string): SASTVulnerability['severity'] {\n    const mapping: Record<string, SASTVulnerability['severity']> = {\n      BLOCKER: 'critical',\n      CRITICAL: 'high',\n      MAJOR: 'medium',\n      MINOR: 'low',\n      INFO: 'info',\n    };\n    return mapping[severity] || 'low';\n  }\n\n  private mapSonarConfidence(severity: string): SASTVulnerability['confidence'] {\n    const mapping: Record<string, SASTVulnerability['confidence']> = {\n      BLOCKER: 'high',\n      CRITICAL: 'high',\n      MAJOR: 'medium',\n      MINOR: 'low',\n      INFO: 'low',\n    };\n    return mapping[severity] || 'low';\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"dependency-scanning-sca",children:"Dependency Scanning (SCA)"}),"\n",(0,r.jsx)(e.h3,{id:"software-composition-analysis-service",children:"Software Composition Analysis Service"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/security/dependency-scanner.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { HttpService } from '@nestjs/axios';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport interface DependencyVulnerability {\n  id: string;\n  cve: string;\n  packageName: string;\n  packageVersion: string;\n  severity: 'critical' | 'high' | 'medium' | 'low';\n  cvssScore: number;\n  description: string;\n  references: string[];\n  patchedVersions: string[];\n  vulnerableVersions: string;\n  publishedDate: Date;\n  updatedDate: Date;\n  source: 'npm-audit' | 'snyk' | 'whitesource' | 'owasp-dependency-check';\n}\n\nexport interface DependencyScanResult {\n  scanId: string;\n  timestamp: Date;\n  projectPath: string;\n  packageManager: 'npm' | 'yarn' | 'pnpm';\n  totalDependencies: number;\n  vulnerabilities: DependencyVulnerability[];\n  summary: {\n    total: number;\n    critical: number;\n    high: number;\n    medium: number;\n    low: number;\n  };\n  licensing: {\n    totalLicenses: number;\n    incompatibleLicenses: string[];\n    unknownLicenses: string[];\n  };\n}\n\n@Injectable()\nexport class DependencyScannerService {\n  private readonly logger = new Logger(DependencyScannerService.name);\n\n  constructor(private readonly httpService: HttpService) {}\n\n  async scanDependencies(projectPath: string): Promise<DependencyScanResult> {\n    this.logger.log(`Starting dependency scan for project: ${projectPath}`);\n\n    const packageManager = this.detectPackageManager(projectPath);\n    const scanId = `dep-scan-${Date.now()}`;\n\n    try {\n      // Run multiple dependency scanners\n      const npmAuditResults = await this.runNpmAudit(projectPath);\n      const snykResults = await this.runSnykScan(projectPath);\n      const owaspResults = await this.runOwaspDependencyCheck(projectPath);\n\n      // Aggregate results\n      const vulnerabilities = this.aggregateDependencyVulnerabilities([\n        ...npmAuditResults,\n        ...snykResults,\n        ...owaspResults,\n      ]);\n\n      const totalDependencies = await this.countDependencies(projectPath, packageManager);\n      const licensing = await this.analyzeLicensing(projectPath);\n\n      const result: DependencyScanResult = {\n        scanId,\n        timestamp: new Date(),\n        projectPath,\n        packageManager,\n        totalDependencies,\n        vulnerabilities,\n        summary: this.calculateDependencySummary(vulnerabilities),\n        licensing,\n      };\n\n      this.logger.log(`Dependency scan completed. Found ${vulnerabilities.length} vulnerabilities`);\n      return result;\n    } catch (error) {\n      this.logger.error('Dependency scan failed', error);\n      throw error;\n    }\n  }\n\n  private detectPackageManager(projectPath: string): 'npm' | 'yarn' | 'pnpm' {\n    if (fs.existsSync(path.join(projectPath, 'pnpm-lock.yaml'))) {\n      return 'pnpm';\n    } else if (fs.existsSync(path.join(projectPath, 'yarn.lock'))) {\n      return 'yarn';\n    } else {\n      return 'npm';\n    }\n  }\n\n  private async runNpmAudit(projectPath: string): Promise<DependencyVulnerability[]> {\n    this.logger.debug('Running npm audit');\n\n    try {\n      const { spawn } = require('child_process');\n      const auditProcess = spawn('npm', ['audit', '--json'], {\n        cwd: projectPath,\n        stdio: 'pipe',\n      });\n\n      let auditOutput = '';\n      auditProcess.stdout.on('data', (data: Buffer) => {\n        auditOutput += data.toString();\n      });\n\n      await new Promise((resolve, reject) => {\n        auditProcess.on('close', (code: number) => {\n          if (code === 0 || code === 1) { // npm audit returns 1 when vulnerabilities found\n            resolve(code);\n          } else {\n            reject(new Error(`npm audit failed with code ${code}`));\n          }\n        });\n      });\n\n      const auditData = JSON.parse(auditOutput);\n      return this.parseNpmAuditResults(auditData);\n    } catch (error) {\n      this.logger.warn('npm audit failed', error);\n      return [];\n    }\n  }\n\n  private parseNpmAuditResults(auditData: any): DependencyVulnerability[] {\n    const vulnerabilities: DependencyVulnerability[] = [];\n\n    if (auditData.vulnerabilities) {\n      for (const [packageName, vuln] of Object.entries(auditData.vulnerabilities)) {\n        const vulnData = vuln as any;\n        \n        for (const advisory of vulnData.via) {\n          if (typeof advisory === 'object' && advisory.cwe) {\n            vulnerabilities.push({\n              id: advisory.id?.toString() || `npm-${Date.now()}`,\n              cve: advisory.cve || '',\n              packageName,\n              packageVersion: vulnData.range || '',\n              severity: this.mapNpmSeverity(advisory.severity),\n              cvssScore: advisory.cvss?.score || 0,\n              description: advisory.title || '',\n              references: advisory.references || [],\n              patchedVersions: vulnData.fixAvailable?.version ? [vulnData.fixAvailable.version] : [],\n              vulnerableVersions: advisory.vulnerable_versions || '',\n              publishedDate: new Date(advisory.created || Date.now()),\n              updatedDate: new Date(advisory.updated || Date.now()),\n              source: 'npm-audit',\n            });\n          }\n        }\n      }\n    }\n\n    return vulnerabilities;\n  }\n\n  private async runSnykScan(projectPath: string): Promise<DependencyVulnerability[]> {\n    this.logger.debug('Running Snyk scan');\n\n    try {\n      // Implementation would integrate with Snyk API or CLI\n      // This is a placeholder implementation\n      return [];\n    } catch (error) {\n      this.logger.warn('Snyk scan failed', error);\n      return [];\n    }\n  }\n\n  private async runOwaspDependencyCheck(projectPath: string): Promise<DependencyVulnerability[]> {\n    this.logger.debug('Running OWASP Dependency Check');\n\n    try {\n      // Implementation would integrate with OWASP Dependency Check\n      // This is a placeholder implementation\n      return [];\n    } catch (error) {\n      this.logger.warn('OWASP Dependency Check failed', error);\n      return [];\n    }\n  }\n\n  private aggregateDependencyVulnerabilities(\n    vulnerabilities: DependencyVulnerability[]\n  ): DependencyVulnerability[] {\n    // Deduplicate vulnerabilities based on CVE and package\n    const seen = new Set<string>();\n    return vulnerabilities.filter(vuln => {\n      const key = `${vuln.cve}:${vuln.packageName}`;\n      if (seen.has(key)) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n  }\n\n  private async countDependencies(projectPath: string, packageManager: string): Promise<number> {\n    try {\n      const packageJsonPath = path.join(projectPath, 'package.json');\n      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n      \n      const dependencies = Object.keys(packageJson.dependencies || {});\n      const devDependencies = Object.keys(packageJson.devDependencies || {});\n      \n      return dependencies.length + devDependencies.length;\n    } catch (error) {\n      this.logger.warn('Failed to count dependencies', error);\n      return 0;\n    }\n  }\n\n  private async analyzeLicensing(projectPath: string): Promise<DependencyScanResult['licensing']> {\n    try {\n      // Implementation would analyze package licenses\n      // This is a placeholder implementation\n      return {\n        totalLicenses: 0,\n        incompatibleLicenses: [],\n        unknownLicenses: [],\n      };\n    } catch (error) {\n      this.logger.warn('License analysis failed', error);\n      return {\n        totalLicenses: 0,\n        incompatibleLicenses: [],\n        unknownLicenses: [],\n      };\n    }\n  }\n\n  private calculateDependencySummary(vulnerabilities: DependencyVulnerability[]) {\n    const summary = {\n      total: vulnerabilities.length,\n      critical: 0,\n      high: 0,\n      medium: 0,\n      low: 0,\n    };\n\n    for (const vuln of vulnerabilities) {\n      summary[vuln.severity]++;\n    }\n\n    return summary;\n  }\n\n  private mapNpmSeverity(severity: string): DependencyVulnerability['severity'] {\n    const mapping: Record<string, DependencyVulnerability['severity']> = {\n      critical: 'critical',\n      high: 'high',\n      moderate: 'medium',\n      low: 'low',\n    };\n    return mapping[severity] || 'low';\n  }\n\n  async generateDependencyReport(scanResult: DependencyScanResult): Promise<string> {\n    const report = {\n      project: scanResult.projectPath,\n      scanDate: scanResult.timestamp,\n      summary: scanResult.summary,\n      vulnerabilities: scanResult.vulnerabilities.map(vuln => ({\n        package: vuln.packageName,\n        version: vuln.packageVersion,\n        vulnerability: vuln.cve || vuln.id,\n        severity: vuln.severity,\n        cvssScore: vuln.cvssScore,\n        description: vuln.description,\n        fixAvailable: vuln.patchedVersions.length > 0,\n        recommendedVersion: vuln.patchedVersions[0] || 'No fix available',\n      })),\n      licensing: scanResult.licensing,\n    };\n\n    return JSON.stringify(report, null, 2);\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"dynamic-application-security-testing-dast",children:"Dynamic Application Security Testing (DAST)"}),"\n",(0,r.jsx)(e.h3,{id:"dast-scanner-service",children:"DAST Scanner Service"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/security/dast-scanner.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { HttpService } from '@nestjs/axios';\n\nexport interface DASTVulnerability {\n  id: string;\n  name: string;\n  description: string;\n  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';\n  confidence: 'high' | 'medium' | 'low';\n  url: string;\n  method: string;\n  parameter: string;\n  evidence: string;\n  cwe: string;\n  owasp: string;\n  remediation: string;\n  references: string[];\n}\n\nexport interface DASTScanConfig {\n  targetUrl: string;\n  scanType: 'quick' | 'full' | 'custom';\n  authentication: {\n    type: 'none' | 'basic' | 'session' | 'api-key';\n    credentials?: {\n      username?: string;\n      password?: string;\n      apiKey?: string;\n      sessionToken?: string;\n    };\n  };\n  scope: {\n    includeUrls: string[];\n    excludeUrls: string[];\n    maxDepth: number;\n    maxPages: number;\n  };\n  policies: string[];\n  timeout: number;\n}\n\nexport interface DASTScanResult {\n  scanId: string;\n  config: DASTScanConfig;\n  status: 'completed' | 'failed' | 'timeout';\n  startTime: Date;\n  endTime: Date;\n  duration: number;\n  vulnerabilities: DASTVulnerability[];\n  summary: {\n    total: number;\n    critical: number;\n    high: number;\n    medium: number;\n    low: number;\n    info: number;\n  };\n  coverage: {\n    urlsScanned: number;\n    pagesAnalyzed: number;\n    formsAnalyzed: number;\n    parametersAnalyzed: number;\n  };\n}\n\n@Injectable()\nexport class DASTScannerService {\n  private readonly logger = new Logger(DASTScannerService.name);\n\n  constructor(private readonly httpService: HttpService) {}\n\n  async startScan(config: DASTScanConfig): Promise<string> {\n    this.logger.log(`Starting DAST scan for target: ${config.targetUrl}`);\n\n    try {\n      // Start OWASP ZAP scan\n      const zapScanId = await this.startZAPScan(config);\n      \n      // Start Burp Suite scan (if available)\n      // const burpScanId = await this.startBurpScan(config);\n      \n      // Start custom security checks\n      await this.startCustomSecurityChecks(config);\n\n      return zapScanId;\n    } catch (error) {\n      this.logger.error('Failed to start DAST scan', error);\n      throw error;\n    }\n  }\n\n  private async startZAPScan(config: DASTScanConfig): Promise<string> {\n    // OWASP ZAP integration\n    const zapConfig = {\n      target: config.targetUrl,\n      scanType: config.scanType,\n      contextName: `scan-${Date.now()}`,\n      scanPolicyName: config.policies.length > 0 ? config.policies[0] : 'Default Policy',\n      method: 'POST',\n    };\n\n    this.logger.debug('Starting OWASP ZAP scan', zapConfig);\n\n    // Implementation would integrate with ZAP API\n    const scanId = `zap-${Date.now()}`;\n    return scanId;\n  }\n\n  private async startCustomSecurityChecks(config: DASTScanConfig): Promise<void> {\n    // Custom security tests\n    const securityChecks = [\n      this.checkSQLInjection(config.targetUrl),\n      this.checkXSS(config.targetUrl),\n      this.checkCSRF(config.targetUrl),\n      this.checkSecurityHeaders(config.targetUrl),\n      this.checkSSLConfiguration(config.targetUrl),\n      this.checkAuthentication(config.targetUrl),\n      this.checkAuthorization(config.targetUrl),\n    ];\n\n    await Promise.allSettled(securityChecks);\n  }\n\n  async getScanResults(scanId: string): Promise<DASTScanResult> {\n    this.logger.log(`Retrieving DAST scan results for scan: ${scanId}`);\n\n    try {\n      // Get ZAP scan results\n      const zapResults = await this.getZAPResults(scanId);\n      \n      // Get custom security check results\n      const customResults = await this.getCustomSecurityResults(scanId);\n\n      // Aggregate all results\n      const allVulnerabilities = [...zapResults, ...customResults];\n      const uniqueVulnerabilities = this.deduplicateDASTVulnerabilities(allVulnerabilities);\n\n      const result: DASTScanResult = {\n        scanId,\n        config: {} as DASTScanConfig, // Would be stored from original scan\n        status: 'completed',\n        startTime: new Date(Date.now() - 600000), // 10 minutes ago\n        endTime: new Date(),\n        duration: 600000,\n        vulnerabilities: uniqueVulnerabilities,\n        summary: this.calculateDASTSummary(uniqueVulnerabilities),\n        coverage: {\n          urlsScanned: 50,\n          pagesAnalyzed: 45,\n          formsAnalyzed: 12,\n          parametersAnalyzed: 89,\n        },\n      };\n\n      return result;\n    } catch (error) {\n      this.logger.error(`Failed to retrieve DAST scan results for ${scanId}`, error);\n      throw error;\n    }\n  }\n\n  private async getZAPResults(scanId: string): Promise<DASTVulnerability[]> {\n    // Implementation would retrieve results from ZAP\n    return [];\n  }\n\n  private async getCustomSecurityResults(scanId: string): Promise<DASTVulnerability[]> {\n    // Implementation would retrieve custom security check results\n    return [];\n  }\n\n  // Security check implementations\n  private async checkSQLInjection(targetUrl: string): Promise<DASTVulnerability[]> {\n    const vulnerabilities: DASTVulnerability[] = [];\n    \n    const sqlPayloads = [\n      \"' OR '1'='1\",\n      \"'; DROP TABLE users; --\",\n      \"' UNION SELECT 1,2,3 --\",\n      \"1' AND SLEEP(5) --\",\n    ];\n\n    for (const payload of sqlPayloads) {\n      try {\n        // Test SQL injection on various endpoints\n        const testUrls = [\n          `${targetUrl}/api/users?id=${encodeURIComponent(payload)}`,\n          `${targetUrl}/search?q=${encodeURIComponent(payload)}`,\n        ];\n\n        for (const testUrl of testUrls) {\n          const startTime = Date.now();\n          const response = await this.httpService.get(testUrl).toPromise();\n          const responseTime = Date.now() - startTime;\n\n          // Check for SQL injection indicators\n          if (this.detectSQLInjection(response.data, responseTime)) {\n            vulnerabilities.push({\n              id: `sql-inj-${Date.now()}`,\n              name: 'SQL Injection',\n              description: 'Potential SQL injection vulnerability detected',\n              severity: 'high',\n              confidence: 'medium',\n              url: testUrl,\n              method: 'GET',\n              parameter: 'query parameter',\n              evidence: `Payload: ${payload}`,\n              cwe: 'CWE-89',\n              owasp: 'A03:2021',\n              remediation: 'Use parameterized queries and input validation',\n              references: ['https://owasp.org/www-community/attacks/SQL_Injection'],\n            });\n          }\n        }\n      } catch (error) {\n        // Analyze error responses for SQL injection indicators\n        if (this.detectSQLErrorMessages(error.message)) {\n          vulnerabilities.push({\n            id: `sql-err-${Date.now()}`,\n            name: 'SQL Injection (Error-based)',\n            description: 'SQL error messages revealed in response',\n            severity: 'medium',\n            confidence: 'high',\n            url: targetUrl,\n            method: 'GET',\n            parameter: 'query parameter',\n            evidence: error.message,\n            cwe: 'CWE-89',\n            owasp: 'A03:2021',\n            remediation: 'Implement proper error handling and input validation',\n            references: ['https://owasp.org/www-community/attacks/SQL_Injection'],\n          });\n        }\n      }\n    }\n\n    return vulnerabilities;\n  }\n\n  private async checkXSS(targetUrl: string): Promise<DASTVulnerability[]> {\n    const vulnerabilities: DASTVulnerability[] = [];\n    \n    const xssPayloads = [\n      '<script>alert(\"XSS\")<\/script>',\n      '<img src=\"x\" onerror=\"alert(\\'XSS\\')\">',\n      'javascript:alert(\"XSS\")',\n      '<svg onload=\"alert(\\'XSS\\')\">',\n    ];\n\n    for (const payload of xssPayloads) {\n      try {\n        // Test XSS on various endpoints\n        const response = await this.httpService.post(`${targetUrl}/api/feedback`, {\n          message: payload,\n          email: 'test@example.com',\n        }).toPromise();\n\n        if (response.data.includes(payload)) {\n          vulnerabilities.push({\n            id: `xss-${Date.now()}`,\n            name: 'Cross-Site Scripting (XSS)',\n            description: 'Reflected XSS vulnerability detected',\n            severity: 'high',\n            confidence: 'high',\n            url: `${targetUrl}/api/feedback`,\n            method: 'POST',\n            parameter: 'message',\n            evidence: `Payload reflected: ${payload}`,\n            cwe: 'CWE-79',\n            owasp: 'A03:2021',\n            remediation: 'Implement proper input validation and output encoding',\n            references: ['https://owasp.org/www-community/attacks/xss/'],\n          });\n        }\n      } catch (error) {\n        // Continue with other payloads\n      }\n    }\n\n    return vulnerabilities;\n  }\n\n  private async checkCSRF(targetUrl: string): Promise<DASTVulnerability[]> {\n    const vulnerabilities: DASTVulnerability[] = [];\n\n    try {\n      // Check for CSRF protection\n      const response = await this.httpService.post(`${targetUrl}/api/profile`, {\n        email: 'attacker@evil.com',\n      }).toPromise();\n\n      // If request succeeds without CSRF token, it's vulnerable\n      if (response.status === 200) {\n        vulnerabilities.push({\n          id: `csrf-${Date.now()}`,\n          name: 'Cross-Site Request Forgery (CSRF)',\n          description: 'Endpoint lacks CSRF protection',\n          severity: 'medium',\n          confidence: 'high',\n          url: `${targetUrl}/api/profile`,\n          method: 'POST',\n          parameter: 'N/A',\n          evidence: 'Request succeeded without CSRF token',\n          cwe: 'CWE-352',\n          owasp: 'A01:2021',\n          remediation: 'Implement CSRF tokens and SameSite cookies',\n          references: ['https://owasp.org/www-community/attacks/csrf'],\n        });\n      }\n    } catch (error) {\n      // Expected behavior if CSRF protection is in place\n    }\n\n    return vulnerabilities;\n  }\n\n  private async checkSecurityHeaders(targetUrl: string): Promise<DASTVulnerability[]> {\n    const vulnerabilities: DASTVulnerability[] = [];\n\n    try {\n      const response = await this.httpService.get(targetUrl).toPromise();\n      const headers = response.headers;\n\n      const securityHeaders = [\n        'content-security-policy',\n        'x-frame-options',\n        'x-content-type-options',\n        'strict-transport-security',\n        'referrer-policy',\n      ];\n\n      for (const header of securityHeaders) {\n        if (!headers[header]) {\n          vulnerabilities.push({\n            id: `header-${header}-${Date.now()}`,\n            name: `Missing Security Header: ${header}`,\n            description: `Security header ${header} is not set`,\n            severity: this.getHeaderSeverity(header),\n            confidence: 'high',\n            url: targetUrl,\n            method: 'GET',\n            parameter: 'HTTP Header',\n            evidence: `Missing header: ${header}`,\n            cwe: 'CWE-693',\n            owasp: 'A05:2021',\n            remediation: `Implement ${header} security header`,\n            references: ['https://owasp.org/www-project-secure-headers/'],\n          });\n        }\n      }\n    } catch (error) {\n      this.logger.warn('Failed to check security headers', error);\n    }\n\n    return vulnerabilities;\n  }\n\n  private async checkSSLConfiguration(targetUrl: string): Promise<DASTVulnerability[]> {\n    const vulnerabilities: DASTVulnerability[] = [];\n\n    if (!targetUrl.startsWith('https://')) {\n      vulnerabilities.push({\n        id: `ssl-none-${Date.now()}`,\n        name: 'No SSL/TLS Encryption',\n        description: 'Application does not use SSL/TLS encryption',\n        severity: 'high',\n        confidence: 'high',\n        url: targetUrl,\n        method: 'N/A',\n        parameter: 'Protocol',\n        evidence: 'URL uses HTTP instead of HTTPS',\n        cwe: 'CWE-319',\n        owasp: 'A02:2021',\n        remediation: 'Implement SSL/TLS encryption',\n        references: ['https://owasp.org/www-community/controls/Transport_Layer_Protection_Cheat_Sheet'],\n      });\n    }\n\n    // Additional SSL checks would go here (certificate validation, cipher strength, etc.)\n\n    return vulnerabilities;\n  }\n\n  private async checkAuthentication(targetUrl: string): Promise<DASTVulnerability[]> {\n    const vulnerabilities: DASTVulnerability[] = [];\n\n    // Test weak authentication mechanisms\n    const weakCredentials = [\n      { username: 'admin', password: 'admin' },\n      { username: 'admin', password: 'password' },\n      { username: 'admin', password: '123456' },\n    ];\n\n    for (const creds of weakCredentials) {\n      try {\n        const response = await this.httpService.post(`${targetUrl}/auth/login`, creds).toPromise();\n        \n        if (response.status === 200) {\n          vulnerabilities.push({\n            id: `weak-auth-${Date.now()}`,\n            name: 'Weak Authentication',\n            description: 'Weak or default credentials accepted',\n            severity: 'critical',\n            confidence: 'high',\n            url: `${targetUrl}/auth/login`,\n            method: 'POST',\n            parameter: 'credentials',\n            evidence: `Weak credentials: ${creds.username}/${creds.password}`,\n            cwe: 'CWE-521',\n            owasp: 'A07:2021',\n            remediation: 'Implement strong password policies and disable default accounts',\n            references: ['https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication'],\n          });\n        }\n      } catch (error) {\n        // Expected behavior for proper authentication\n      }\n    }\n\n    return vulnerabilities;\n  }\n\n  private async checkAuthorization(targetUrl: string): Promise<DASTVulnerability[]> {\n    const vulnerabilities: DASTVulnerability[] = [];\n\n    // Test for authorization bypass\n    const adminEndpoints = [\n      `${targetUrl}/admin`,\n      `${targetUrl}/api/admin/users`,\n      `${targetUrl}/api/admin/settings`,\n    ];\n\n    for (const endpoint of adminEndpoints) {\n      try {\n        const response = await this.httpService.get(endpoint).toPromise();\n        \n        if (response.status === 200) {\n          vulnerabilities.push({\n            id: `authz-bypass-${Date.now()}`,\n            name: 'Authorization Bypass',\n            description: 'Admin endpoint accessible without proper authorization',\n            severity: 'high',\n            confidence: 'high',\n            url: endpoint,\n            method: 'GET',\n            parameter: 'N/A',\n            evidence: 'Admin endpoint accessible without authentication',\n            cwe: 'CWE-862',\n            owasp: 'A01:2021',\n            remediation: 'Implement proper authorization checks',\n            references: ['https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control'],\n          });\n        }\n      } catch (error) {\n        // Expected behavior for protected endpoints\n      }\n    }\n\n    return vulnerabilities;\n  }\n\n  // Helper methods\n  private detectSQLInjection(responseData: any, responseTime: number): boolean {\n    const sqlErrorPatterns = [\n      /sql syntax/i,\n      /mysql_fetch/i,\n      /ora-\\d{5}/i,\n      /sqlstate/i,\n    ];\n\n    // Check for SQL error patterns\n    const hasErrorPattern = sqlErrorPatterns.some(pattern => \n      pattern.test(JSON.stringify(responseData))\n    );\n\n    // Check for time-based injection (significant delay)\n    const hasTimeDelay = responseTime > 5000;\n\n    return hasErrorPattern || hasTimeDelay;\n  }\n\n  private detectSQLErrorMessages(errorMessage: string): boolean {\n    const sqlErrorKeywords = [\n      'syntax error',\n      'mysql',\n      'oracle',\n      'postgresql',\n      'sqlite',\n      'sql server',\n    ];\n\n    return sqlErrorKeywords.some(keyword => \n      errorMessage.toLowerCase().includes(keyword)\n    );\n  }\n\n  private getHeaderSeverity(header: string): DASTVulnerability['severity'] {\n    const severityMap: Record<string, DASTVulnerability['severity']> = {\n      'content-security-policy': 'high',\n      'strict-transport-security': 'high',\n      'x-frame-options': 'medium',\n      'x-content-type-options': 'medium',\n      'referrer-policy': 'low',\n    };\n\n    return severityMap[header] || 'medium';\n  }\n\n  private deduplicateDASTVulnerabilities(vulnerabilities: DASTVulnerability[]): DASTVulnerability[] {\n    const seen = new Set<string>();\n    return vulnerabilities.filter(vuln => {\n      const key = `${vuln.url}:${vuln.method}:${vuln.cwe}`;\n      if (seen.has(key)) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n  }\n\n  private calculateDASTSummary(vulnerabilities: DASTVulnerability[]) {\n    const summary = {\n      total: vulnerabilities.length,\n      critical: 0,\n      high: 0,\n      medium: 0,\n      low: 0,\n      info: 0,\n    };\n\n    for (const vuln of vulnerabilities) {\n      summary[vuln.severity]++;\n    }\n\n    return summary;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"container-and-infrastructure-scanning",children:"Container and Infrastructure Scanning"}),"\n",(0,r.jsx)(e.h3,{id:"container-security-scanner",children:"Container Security Scanner"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/security/container-scanner.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\nexport interface ContainerVulnerability {\n  id: string;\n  packageName: string;\n  packageVersion: string;\n  vulnerability: string;\n  severity: 'critical' | 'high' | 'medium' | 'low' | 'negligible';\n  description: string;\n  fixedVersion?: string;\n  links: string[];\n  layer: string;\n}\n\nexport interface ContainerScanResult {\n  imageId: string;\n  repository: string;\n  tag: string;\n  digest: string;\n  scanTime: Date;\n  vulnerabilities: ContainerVulnerability[];\n  summary: {\n    total: number;\n    critical: number;\n    high: number;\n    medium: number;\n    low: number;\n    negligible: number;\n  };\n  compliance: {\n    passed: number;\n    failed: number;\n    checks: Array<{\n      id: string;\n      title: string;\n      severity: string;\n      status: 'PASS' | 'FAIL' | 'WARN';\n      description: string;\n    }>;\n  };\n}\n\n@Injectable()\nexport class ContainerScannerService {\n  private readonly logger = new Logger(ContainerScannerService.name);\n\n  async scanImage(imageRef: string): Promise<ContainerScanResult> {\n    this.logger.log(`Scanning container image: ${imageRef}`);\n\n    try {\n      // Run Trivy scan\n      const trivyResults = await this.runTrivyScan(imageRef);\n      \n      // Run Clair scan\n      const clairResults = await this.runClairScan(imageRef);\n      \n      // Run custom compliance checks\n      const complianceResults = await this.runComplianceChecks(imageRef);\n\n      // Aggregate results\n      const vulnerabilities = this.aggregateContainerVulnerabilities([\n        ...trivyResults,\n        ...clairResults,\n      ]);\n\n      const result: ContainerScanResult = {\n        imageId: this.extractImageId(imageRef),\n        repository: this.extractRepository(imageRef),\n        tag: this.extractTag(imageRef),\n        digest: await this.getImageDigest(imageRef),\n        scanTime: new Date(),\n        vulnerabilities,\n        summary: this.calculateContainerSummary(vulnerabilities),\n        compliance: complianceResults,\n      };\n\n      this.logger.log(`Container scan completed. Found ${vulnerabilities.length} vulnerabilities`);\n      return result;\n    } catch (error) {\n      this.logger.error('Container scan failed', error);\n      throw error;\n    }\n  }\n\n  private async runTrivyScan(imageRef: string): Promise<ContainerVulnerability[]> {\n    this.logger.debug('Running Trivy scan');\n\n    // Implementation would run Trivy CLI or API\n    // This is a placeholder implementation\n    return [];\n  }\n\n  private async runClairScan(imageRef: string): Promise<ContainerVulnerability[]> {\n    this.logger.debug('Running Clair scan');\n\n    // Implementation would integrate with Clair API\n    // This is a placeholder implementation\n    return [];\n  }\n\n  private async runComplianceChecks(imageRef: string): Promise<ContainerScanResult['compliance']> {\n    const checks = [\n      {\n        id: 'CIS-1.1',\n        title: 'Ensure container runs as non-root user',\n        severity: 'HIGH',\n        status: 'PASS' as const,\n        description: 'Container should not run as root user',\n      },\n      {\n        id: 'CIS-1.2',\n        title: 'Ensure container file system is read-only',\n        severity: 'MEDIUM',\n        status: 'WARN' as const,\n        description: 'Container file system should be mounted as read-only',\n      },\n    ];\n\n    const passed = checks.filter(c => c.status === 'PASS').length;\n    const failed = checks.filter(c => c.status === 'FAIL').length;\n\n    return {\n      passed,\n      failed,\n      checks,\n    };\n  }\n\n  private aggregateContainerVulnerabilities(\n    vulnerabilities: ContainerVulnerability[]\n  ): ContainerVulnerability[] {\n    // Deduplicate vulnerabilities\n    const seen = new Set<string>();\n    return vulnerabilities.filter(vuln => {\n      const key = `${vuln.packageName}:${vuln.vulnerability}`;\n      if (seen.has(key)) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n  }\n\n  private calculateContainerSummary(vulnerabilities: ContainerVulnerability[]) {\n    const summary = {\n      total: vulnerabilities.length,\n      critical: 0,\n      high: 0,\n      medium: 0,\n      low: 0,\n      negligible: 0,\n    };\n\n    for (const vuln of vulnerabilities) {\n      summary[vuln.severity]++;\n    }\n\n    return summary;\n  }\n\n  private extractImageId(imageRef: string): string {\n    // Extract image ID from reference\n    return imageRef.split('@')[0] || imageRef;\n  }\n\n  private extractRepository(imageRef: string): string {\n    // Extract repository name\n    return imageRef.split(':')[0];\n  }\n\n  private extractTag(imageRef: string): string {\n    // Extract tag\n    const parts = imageRef.split(':');\n    return parts.length > 1 ? parts[1].split('@')[0] : 'latest';\n  }\n\n  private async getImageDigest(imageRef: string): Promise<string> {\n    // Get image digest\n    return 'sha256:' + Array(64).fill(0).map(() => Math.floor(Math.random() * 16).toString(16)).join('');\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"security-scanning-cicd-integration",children:"Security Scanning CI/CD Integration"}),"\n",(0,r.jsx)(e.h3,{id:"github-actions-security-pipeline",children:"GitHub Actions Security Pipeline"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:"# .github/workflows/security-scanning.yml\nname: Security Scanning\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n  schedule:\n    - cron: '0 2 * * *' # Daily at 2 AM\n\nenv:\n  REGISTRY: ghcr.io\n\njobs:\n  sast-scan:\n    name: Static Application Security Testing\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n      with:\n        fetch-depth: 0\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'npm'\n\n    - name: Install dependencies\n      run: npm ci\n\n    - name: Run ESLint Security Plugin\n      run: npx eslint . --ext .js,.ts,.tsx --format json --output-file eslint-results.json\n      continue-on-error: true\n\n    - name: Run Semgrep\n      uses: returntocorp/semgrep-action@v1\n      with:\n        config: >-\n          p/security-audit\n          p/secrets\n          p/typescript\n          p/react\n          p/nodejs\n        generateSarif: \"1\"\n\n    - name: Run CodeQL Analysis\n      uses: github/codeql-action/init@v3\n      with:\n        languages: javascript,typescript\n        queries: security-and-quality,security-extended\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v3\n\n    - name: Upload SAST Results\n      uses: actions/upload-artifact@v4\n      with:\n        name: sast-results\n        path: |\n          eslint-results.json\n          semgrep.sarif\n        if-no-files-found: warn\n\n  dependency-scan:\n    name: Dependency Vulnerability Scanning\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'npm'\n\n    - name: Run npm audit\n      run: |\n        npm audit --audit-level=moderate --json > npm-audit.json || true\n        \n    - name: Run Snyk to check for vulnerabilities\n      uses: snyk/actions/node@master\n      env:\n        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n      with:\n        args: --severity-threshold=high --json-file-output=snyk-results.json\n      continue-on-error: true\n\n    - name: Run OWASP Dependency Check\n      uses: dependency-check/Dependency-Check_Action@main\n      with:\n        project: 'microservice-app'\n        path: '.'\n        format: 'JSON'\n        out: 'dependency-check-report'\n\n    - name: Upload Dependency Scan Results\n      uses: actions/upload-artifact@v4\n      with:\n        name: dependency-scan-results\n        path: |\n          npm-audit.json\n          snyk-results.json\n          dependency-check-report/\n        if-no-files-found: warn\n\n  container-scan:\n    name: Container Security Scanning\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Build Docker image\n      run: |\n        docker build -t test-image:${{ github.sha }} .\n\n    - name: Run Trivy vulnerability scanner\n      uses: aquasecurity/trivy-action@master\n      with:\n        image-ref: 'test-image:${{ github.sha }}'\n        format: 'sarif'\n        output: 'trivy-results.sarif'\n\n    - name: Run Docker Bench Security\n      run: |\n        git clone https://github.com/docker/docker-bench-security.git\n        cd docker-bench-security\n        sudo sh docker-bench-security.sh -c container_images | tee ../docker-bench-results.txt\n\n    - name: Upload Container Scan Results\n      uses: actions/upload-artifact@v4\n      with:\n        name: container-scan-results\n        path: |\n          trivy-results.sarif\n          docker-bench-results.txt\n        if-no-files-found: warn\n\n  dast-scan:\n    name: Dynamic Application Security Testing\n    runs-on: ubuntu-latest\n    needs: [sast-scan]\n    if: github.event_name == 'schedule' || github.ref == 'refs/heads/main'\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'npm'\n\n    - name: Install dependencies and build\n      run: |\n        npm ci\n        npm run build\n\n    - name: Start application\n      run: |\n        npm start &\n        sleep 30\n        curl -f http://localhost:3000/health || exit 1\n\n    - name: Run OWASP ZAP Baseline Scan\n      uses: zaproxy/action-baseline@v0.10.0\n      with:\n        target: 'http://localhost:3000'\n        rules_file_name: '.zap/rules.tsv'\n        cmd_options: '-a'\n\n    - name: Upload DAST Results\n      uses: actions/upload-artifact@v4\n      with:\n        name: dast-results\n        path: report_html.html\n        if-no-files-found: warn\n\n  secrets-scan:\n    name: Secrets Detection\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n      with:\n        fetch-depth: 0\n\n    - name: Run TruffleHog\n      uses: trufflesecurity/trufflehog@main\n      with:\n        path: ./\n        base: main\n        head: HEAD\n        extra_args: --debug --only-verified\n\n    - name: Run GitLeaks\n      uses: gitleaks/gitleaks-action@v2\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n  security-report:\n    name: Generate Security Report\n    runs-on: ubuntu-latest\n    needs: [sast-scan, dependency-scan, container-scan, dast-scan, secrets-scan]\n    if: always()\n    \n    steps:\n    - name: Download all artifacts\n      uses: actions/download-artifact@v4\n\n    - name: Generate consolidated security report\n      run: |\n        echo \"# Security Scan Report\" > security-report.md\n        echo \"Generated on: $(date)\" >> security-report.md\n        echo \"\" >> security-report.md\n        \n        echo \"## Summary\" >> security-report.md\n        # Add logic to parse and summarize all scan results\n        \n        echo \"## SAST Results\" >> security-report.md\n        if [ -f sast-results/eslint-results.json ]; then\n          echo \"ESLint issues found:\" >> security-report.md\n          jq '.length' sast-results/eslint-results.json >> security-report.md\n        fi\n        \n        echo \"## Dependency Scan Results\" >> security-report.md\n        if [ -f dependency-scan-results/npm-audit.json ]; then\n          echo \"npm audit vulnerabilities:\" >> security-report.md\n          jq '.metadata.vulnerabilities | length' dependency-scan-results/npm-audit.json >> security-report.md\n        fi\n\n    - name: Upload Security Report\n      uses: actions/upload-artifact@v4\n      with:\n        name: security-report\n        path: security-report.md\n\n    - name: Comment PR with security results\n      if: github.event_name == 'pull_request'\n      uses: actions/github-script@v7\n      with:\n        script: |\n          const fs = require('fs');\n          const report = fs.readFileSync('security-report.md', 'utf8');\n          \n          github.rest.issues.createComment({\n            issue_number: context.issue.number,\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            body: report\n          });\n"})}),"\n",(0,r.jsx)(e.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-validation/code-review-process",children:"Code Review Process"})})," - Security-focused code reviews"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline",children:"CI/CD Pipeline"})})," - Integration with security scanning"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/infrastructure-monitoring",children:"Infrastructure Monitoring"})})," - Runtime security monitoring"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.p,{children:"This security scanning guide should be regularly updated to incorporate new security tools and threat detection techniques."})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}},7814:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>c});var i=t(9729);const r={},s=i.createContext(r);function a(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);