"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[2146],{7814:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(9729);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}},9827:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"architecture-practices/architecture-management/pdca-meetings","title":"PDCA Meetings Management","description":"This guide establishes comprehensive Plan-Do-Check-Act (PDCA) meeting frameworks for NestJS microservices and Next.js microfrontend projects, covering systematic architecture review cycles, continuous improvement processes, and collaborative problem-solving methodologies for sustained technical excellence.","source":"@site/docs/architecture-practices/architecture-management/pdca-meetings.md","sourceDirName":"architecture-practices/architecture-management","slug":"/architecture-practices/architecture-management/pdca-meetings","permalink":"/fullstack-dev/docs/architecture-practices/architecture-management/pdca-meetings","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-management/pdca-meetings.md","tags":[],"version":"current","frontMatter":{}}');var i=t(5813),a=t(7814);const r={},o="PDCA Meetings Management",c={},m=[{value:"Overview",id:"overview",level:2},{value:"PDCA Framework",id:"pdca-framework",level:2},{value:"Complete PDCA Process",id:"complete-pdca-process",level:3},{value:"PDCA Meeting Management System",id:"pdca-meeting-management-system",level:2},{value:"Meeting Orchestrator",id:"meeting-orchestrator",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"pdca-meetings-management",children:"PDCA Meetings Management"})}),"\n",(0,i.jsx)(n.p,{children:"This guide establishes comprehensive Plan-Do-Check-Act (PDCA) meeting frameworks for NestJS microservices and Next.js microfrontend projects, covering systematic architecture review cycles, continuous improvement processes, and collaborative problem-solving methodologies for sustained technical excellence."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"PDCA meetings provide structured forums for regular architecture review, improvement planning, and collaborative problem-solving. This framework ensures systematic evaluation of technical progress, identification of improvement opportunities, and implementation of effective solutions through disciplined continuous improvement cycles."}),"\n",(0,i.jsx)(n.h2,{id:"pdca-framework",children:"PDCA Framework"}),"\n",(0,i.jsx)(n.h3,{id:"complete-pdca-process",children:"Complete PDCA Process"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Plan Phase] --\x3e B[Identify Issues]\n    B --\x3e C[Set Objectives]\n    C --\x3e D[Define Actions]\n    D --\x3e E[Allocate Resources]\n    \n    E --\x3e F[Do Phase]\n    F --\x3e G[Execute Actions]\n    G --\x3e H[Document Progress]\n    H --\x3e I[Collect Data]\n    \n    I --\x3e J[Check Phase]\n    J --\x3e K[Measure Results]\n    K --\x3e L[Analyze Outcomes]\n    L --\x3e M[Identify Gaps]\n    \n    M --\x3e N[Act Phase]\n    N --\x3e O[Standardize Success]\n    O --\x3e P[Address Gaps]\n    P --\x3e Q[Plan Next Cycle]\n    \n    Q --\x3e A\n    \n    R[Meeting Types] --\x3e S[Monthly PDCA]\n    R --\x3e T[Sprint Retrospectives]\n    R --\x3e U[Quarterly Reviews]\n    R --\x3e V[Ad-hoc Sessions]\n    \n    W[Participants] --\x3e X[Architecture Team]\n    W --\x3e Y[Development Teams]\n    W --\x3e Z[Stakeholders]\n    W --\x3e AA[Subject Experts]\n    \n    BB[Artifacts] --\x3e CC[Action Plans]\n    BB --\x3e DD[Progress Reports]\n    BB --\x3e EE[Lessons Learned]\n    BB --\x3e FF[Best Practices]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"pdca-meeting-management-system",children:"PDCA Meeting Management System"}),"\n",(0,i.jsx)(n.h3,{id:"meeting-orchestrator",children:"Meeting Orchestrator"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// tools/pdca/meeting-manager.ts\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { Calendar } from './calendar-integration';\nimport { TicketSystem } from './ticket-integration';\nimport { ReportGenerator } from './report-generator';\n\nexport interface PDCAIssue {\n  id: string;\n  title: string;\n  description: string;\n  category: 'architecture' | 'process' | 'tooling' | 'performance' | 'quality' | 'security';\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  impact: 'high' | 'medium' | 'low';\n  effort: 'small' | 'medium' | 'large';\n  raisedBy: string;\n  raisedDate: Date;\n  status: 'identified' | 'planned' | 'in-progress' | 'completed' | 'deferred' | 'rejected';\n  assignee?: string;\n  targetDate?: Date;\n  completionDate?: Date;\n  tags: string[];\n}\n\nexport interface ActionItem {\n  id: string;\n  issueId: string;\n  description: string;\n  assignee: string;\n  dueDate: Date;\n  status: 'pending' | 'in-progress' | 'completed' | 'overdue';\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  estimatedEffort: number; // hours\n  actualEffort?: number; // hours\n  blockers: string[];\n  dependencies: string[];\n  notes: string[];\n  ticketId?: string;\n}\n\nexport interface PDCAMeeting {\n  id: string;\n  date: Date;\n  type: 'monthly' | 'sprint-retro' | 'quarterly' | 'adhoc';\n  attendees: string[];\n  facilitator: string;\n  agenda: AgendaItem[];\n  issues: PDCAIssue[];\n  actionItems: ActionItem[];\n  decisions: Decision[];\n  metrics: MeetingMetrics;\n  duration: number; // minutes\n  nextMeetingDate?: Date;\n  notes: string;\n}\n\nexport interface AgendaItem {\n  id: string;\n  title: string;\n  description: string;\n  timeAllocation: number; // minutes\n  presenter: string;\n  type: 'review' | 'discussion' | 'decision' | 'planning';\n  materials: string[];\n}\n\nexport interface Decision {\n  id: string;\n  title: string;\n  description: string;\n  rationale: string;\n  alternatives: string[];\n  decisionMaker: string;\n  impactedTeams: string[];\n  implementationPlan: string;\n  reviewDate?: Date;\n}\n\nexport interface MeetingMetrics {\n  issuesRaised: number;\n  issuesResolved: number;\n  actionItemsCreated: number;\n  actionItemsCompleted: number;\n  decisionsMade: number;\n  attendanceRate: number;\n  satisfactionScore?: number;\n}\n\nexport class PDCAMeetingManager {\n  private meetings: Map<string, PDCAMeeting> = new Map();\n  private issues: Map<string, PDCAIssue> = new Map();\n  private actionItems: Map<string, ActionItem> = new Map();\n  private calendar: Calendar;\n  private ticketSystem: TicketSystem;\n  private reportGenerator: ReportGenerator;\n\n  constructor() {\n    this.calendar = new Calendar();\n    this.ticketSystem = new TicketSystem();\n    this.reportGenerator = new ReportGenerator();\n    this.loadPersistedData();\n  }\n\n  async scheduleMeeting(\n    type: PDCAMeeting['type'],\n    date: Date,\n    facilitator: string,\n    attendees: string[]\n  ): Promise<string> {\n    const meetingId = this.generateMeetingId(type, date);\n    \n    const agenda = await this.generateAgenda(type);\n    const openIssues = this.getOpenIssues();\n    const overdueActions = this.getOverdueActionItems();\n\n    const meeting: PDCAMeeting = {\n      id: meetingId,\n      date,\n      type,\n      attendees,\n      facilitator,\n      agenda,\n      issues: openIssues,\n      actionItems: overdueActions,\n      decisions: [],\n      metrics: this.initializeMetrics(),\n      duration: this.getDefaultDuration(type),\n      notes: '',\n    };\n\n    this.meetings.set(meetingId, meeting);\n    \n    // Schedule in calendar\n    await this.calendar.createEvent({\n      title: `PDCA Meeting - ${type}`,\n      date,\n      duration: meeting.duration,\n      attendees,\n      description: this.generateMeetingDescription(meeting),\n    });\n\n    await this.persistData();\n    return meetingId;\n  }\n\n  async addIssue(issue: Omit<PDCAIssue, 'id' | 'raisedDate' | 'status'>): Promise<string> {\n    const issueId = this.generateIssueId();\\n    const pdcaIssue: PDCAIssue = {\\n      ...issue,\\n      id: issueId,\\n      raisedDate: new Date(),\\n      status: 'identified',\\n    };\\n\\n    this.issues.set(issueId, pdcaIssue);\\n    await this.persistData();\\n    \\n    // Auto-assign to next meeting if appropriate\\n    const nextMeeting = this.getNextScheduledMeeting();\\n    if (nextMeeting && this.shouldIncludeInNextMeeting(pdcaIssue)) {\\n      nextMeeting.issues.push(pdcaIssue);\\n    }\\n\\n    return issueId;\\n  }\\n\\n  async createActionItem(\\n    issueId: string,\\n    actionItem: Omit<ActionItem, 'id' | 'issueId' | 'status'>\\n  ): Promise<string> {\\n    const actionId = this.generateActionId();\\n    const action: ActionItem = {\\n      ...actionItem,\\n      id: actionId,\\n      issueId,\\n      status: 'pending',\\n    };\\n\\n    this.actionItems.set(actionId, action);\\n    \\n    // Create ticket in external system\\n    if (action.priority === 'critical' || action.priority === 'high') {\\n      action.ticketId = await this.ticketSystem.createTicket({\\n        title: action.description,\\n        assignee: action.assignee,\\n        dueDate: action.dueDate,\\n        priority: action.priority,\\n        labels: ['pdca', 'action-item'],\\n      });\\n    }\\n\\n    await this.persistData();\\n    return actionId;\\n  }\\n\\n  async updateActionItemStatus(\\n    actionId: string,\\n    status: ActionItem['status'],\\n    notes?: string,\\n    actualEffort?: number\\n  ): Promise<void> {\\n    const action = this.actionItems.get(actionId);\\n    if (!action) {\\n      throw new Error(`Action item ${actionId} not found`);\\n    }\\n\\n    action.status = status;\\n    if (notes) {\\n      action.notes.push(`${new Date().toISOString()}: ${notes}`);\\n    }\\n    if (actualEffort !== undefined) {\\n      action.actualEffort = actualEffort;\\n    }\\n    if (status === 'completed') {\\n      action.completionDate = new Date();\\n    }\\n\\n    // Update external ticket\\n    if (action.ticketId) {\\n      await this.ticketSystem.updateTicket(action.ticketId, {\\n        status: this.mapStatusToTicketSystem(status),\\n        notes,\\n      });\\n    }\\n\\n    await this.persistData();\\n  }\\n\\n  async conductMeeting(meetingId: string): Promise<void> {\\n    const meeting = this.meetings.get(meetingId);\\n    if (!meeting) {\\n      throw new Error(`Meeting ${meetingId} not found`);\\n    }\\n\\n    console.log(`\\\\n\ud83c\udfaf Starting PDCA Meeting: ${meeting.type}`);\\n    console.log(`\ud83d\udcc5 Date: ${meeting.date.toISOString()}`);\\n    console.log(`\ud83d\udc65 Facilitator: ${meeting.facilitator}`);\\n    console.log(`\ud83d\udccb Attendees: ${meeting.attendees.join(', ')}\\\\n`);\\n\\n    // Execute agenda items\\n    for (const agendaItem of meeting.agenda) {\\n      await this.executeAgendaItem(meeting, agendaItem);\\n    }\\n\\n    // Generate meeting summary\\n    const summary = await this.generateMeetingSummary(meeting);\\n    console.log(summary);\\n\\n    // Schedule next meeting if needed\\n    if (meeting.type === 'monthly') {\\n      const nextDate = new Date(meeting.date);\\n      nextDate.setMonth(nextDate.getMonth() + 1);\\n      meeting.nextMeetingDate = nextDate;\\n      \\n      await this.scheduleMeeting(meeting.type, nextDate, meeting.facilitator, meeting.attendees);\\n    }\\n\\n    await this.persistData();\\n  }\\n\\n  async generateProgressReport(): Promise<{\\n    summary: any;\\n    issueAnalysis: any;\\n    actionItemAnalysis: any;\\n    trends: any;\\n  }> {\\n    const allIssues = Array.from(this.issues.values());\\n    const allActions = Array.from(this.actionItems.values());\\n    const recentMeetings = Array.from(this.meetings.values())\\n      .filter(m => m.date > new Date(Date.now() - 90 * 24 * 60 * 60 * 1000)) // Last 90 days\\n      .sort((a, b) => b.date.getTime() - a.date.getTime());\\n\\n    const summary = {\\n      totalIssues: allIssues.length,\\n      resolvedIssues: allIssues.filter(i => i.status === 'completed').length,\\n      totalActionItems: allActions.length,\\n      completedActionItems: allActions.filter(a => a.status === 'completed').length,\\n      recentMeetings: recentMeetings.length,\\n      averageMeetingDuration: recentMeetings.reduce((sum, m) => sum + m.duration, 0) / recentMeetings.length,\\n    };\\n\\n    const issueAnalysis = {\\n      byCategory: this.groupByCategory(allIssues),\\n      byPriority: this.groupByPriority(allIssues),\\n      byStatus: this.groupByStatus(allIssues),\\n      resolutionTime: this.calculateAverageResolutionTime(allIssues),\\n    };\\n\\n    const actionItemAnalysis = {\\n      byAssignee: this.groupActionsByAssignee(allActions),\\n      byPriority: this.groupByPriority(allActions),\\n      completionRate: this.calculateCompletionRate(allActions),\\n      averageEffort: this.calculateAverageEffort(allActions),\\n      overdueItems: allActions.filter(a => a.status !== 'completed' && a.dueDate < new Date()),\\n    };\\n\\n    const trends = {\\n      issueCreationTrend: this.calculateIssueCreationTrend(allIssues),\\n      resolutionTrend: this.calculateResolutionTrend(allIssues),\\n      meetingEffectiveness: this.calculateMeetingEffectiveness(recentMeetings),\\n    };\\n\\n    return {\\n      summary,\\n      issueAnalysis,\\n      actionItemAnalysis,\\n      trends,\\n    };\\n  }\\n\\n  private async generateAgenda(type: PDCAMeeting['type']): Promise<AgendaItem[]> {\\n    const baseAgenda: AgendaItem[] = [\\n      {\\n        id: 'welcome',\\n        title: 'Welcome & Introductions',\\n        description: 'Meeting opening and participant introductions',\\n        timeAllocation: 5,\\n        presenter: 'facilitator',\\n        type: 'review',\\n        materials: [],\\n      },\\n      {\\n        id: 'previous-actions',\\n        title: 'Previous Action Items Review',\\n        description: 'Review progress on action items from previous meeting',\\n        timeAllocation: 15,\\n        presenter: 'facilitator',\\n        type: 'review',\\n        materials: ['action-items-report'],\\n      },\\n    ];\\n\\n    // Add type-specific agenda items\\n    if (type === 'monthly') {\\n      baseAgenda.push(\\n        {\\n          id: 'architecture-health',\\n          title: 'Architecture Health Review',\\n          description: 'Review current architecture metrics and health indicators',\\n          timeAllocation: 20,\\n          presenter: 'architect',\\n          type: 'review',\\n          materials: ['architecture-dashboard', 'metrics-report'],\\n        },\\n        {\\n          id: 'issue-discussion',\\n          title: 'Issue Discussion & Planning',\\n          description: 'Discuss new issues and plan solutions',\\n          timeAllocation: 30,\\n          presenter: 'facilitator',\\n          type: 'discussion',\\n          materials: ['issue-list', 'impact-analysis'],\\n        },\\n        {\\n          id: 'improvement-planning',\\n          title: 'Improvement Planning',\\n          description: 'Plan improvement initiatives and assign action items',\\n          timeAllocation: 20,\\n          presenter: 'facilitator',\\n          type: 'planning',\\n          materials: ['improvement-backlog'],\\n        }\\n      );\\n    } else if (type === 'sprint-retro') {\\n      baseAgenda.push(\\n        {\\n          id: 'sprint-review',\\n          title: 'Sprint Review',\\n          description: 'Review sprint outcomes and learnings',\\n          timeAllocation: 15,\\n          presenter: 'scrum-master',\\n          type: 'review',\\n          materials: ['sprint-report'],\\n        },\\n        {\\n          id: 'what-went-well',\\n          title: 'What Went Well',\\n          description: 'Identify and celebrate successes',\\n          timeAllocation: 10,\\n          presenter: 'team',\\n          type: 'discussion',\\n          materials: [],\\n        },\\n        {\\n          id: 'what-could-improve',\\n          title: 'What Could Be Improved',\\n          description: 'Identify improvement opportunities',\\n          timeAllocation: 15,\\n          presenter: 'team',\\n          type: 'discussion',\\n          materials: [],\\n        }\\n      );\\n    }\\n\\n    baseAgenda.push(\\n      {\\n        id: 'next-steps',\\n        title: 'Next Steps & Action Items',\\n        description: 'Define action items and next steps',\\n        timeAllocation: 15,\\n        presenter: 'facilitator',\\n        type: 'planning',\\n        materials: [],\\n      },\\n      {\\n        id: 'closing',\\n        title: 'Meeting Closing',\\n        description: 'Meeting summary and closing',\\n        timeAllocation: 5,\\n        presenter: 'facilitator',\\n        type: 'review',\\n        materials: [],\\n      }\\n    );\\n\\n    return baseAgenda;\\n  }\\n\\n  private async executeAgendaItem(meeting: PDCAMeeting, agendaItem: AgendaItem): Promise<void> {\\n    console.log(`\\\\n\ud83d\udccb ${agendaItem.title} (${agendaItem.timeAllocation} min)`);\\n    console.log(`   ${agendaItem.description}`);\\n    \\n    // Simulate agenda item execution based on type\\n    switch (agendaItem.id) {\\n      case 'previous-actions':\\n        await this.reviewPreviousActions(meeting);\\n        break;\\n      case 'architecture-health':\\n        await this.reviewArchitectureHealth(meeting);\\n        break;\\n      case 'issue-discussion':\\n        await this.discussIssues(meeting);\\n        break;\\n      case 'improvement-planning':\\n        await this.planImprovements(meeting);\\n        break;\\n      default:\\n        console.log(`   \u2705 Agenda item completed`);\\n    }\\n  }\\n\\n  private async reviewPreviousActions(meeting: PDCAMeeting): Promise<void> {\\n    const previousActions = Array.from(this.actionItems.values())\\n      .filter(a => a.dueDate <= meeting.date);\\n\\n    console.log(`   \ud83d\udcca Reviewing ${previousActions.length} action items:`);\\n    \\n    for (const action of previousActions) {\\n      const status = action.status === 'completed' ? '\u2705' : \\n                    action.status === 'in-progress' ? '\ud83d\udd04' : \\n                    action.dueDate < meeting.date ? '\ud83d\udd34' : '\u23f3';\\n      \\n      console.log(`     ${status} ${action.description} (${action.assignee})`);\\n      \\n      if (action.status === 'completed') {\\n        meeting.metrics.actionItemsCompleted++;\\n      }\\n    }\\n  }\\n\\n  private async reviewArchitectureHealth(meeting: PDCAMeeting): Promise<void> {\\n    // This would integrate with actual architecture monitoring\\n    console.log(`   \ud83d\udcc8 Architecture Health Metrics:`);\\n    console.log(`     \u2022 Code Quality Score: 85/100`);\\n    console.log(`     \u2022 Technical Debt: 12 hours`);\\n    console.log(`     \u2022 Test Coverage: 87%`);\\n    console.log(`     \u2022 Performance Score: 92/100`);\\n    console.log(`     \u2022 Security Score: 89/100`);\\n  }\\n\\n  private async discussIssues(meeting: PDCAMeeting): Promise<void> {\\n    console.log(`   \ud83d\udd0d Discussing ${meeting.issues.length} issues:`);\\n    \\n    for (const issue of meeting.issues) {\\n      console.log(`     \u2022 ${issue.title} (${issue.priority} priority)`);\\n      \\n      // Simulate issue discussion and action planning\\n      if (issue.status === 'identified') {\\n        issue.status = 'planned';\\n        meeting.metrics.issuesRaised++;\\n        \\n        // Create action item for high priority issues\\n        if (issue.priority === 'critical' || issue.priority === 'high') {\\n          await this.createActionItem(issue.id, {\\n            description: `Resolve: ${issue.title}`,\\n            assignee: issue.assignee || 'to-be-assigned',\\n            dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 1 week\\n            priority: issue.priority,\\n            estimatedEffort: this.estimateEffort(issue),\\n            blockers: [],\\n            dependencies: [],\\n            notes: [`Created from PDCA meeting ${meeting.id}`],\\n          });\\n          \\n          meeting.metrics.actionItemsCreated++;\\n        }\\n      }\\n    }\\n  }\\n\\n  private async planImprovements(meeting: PDCAMeeting): Promise<void> {\\n    console.log(`   \ud83d\udccb Planning improvement initiatives:`);\\n    \\n    const improvementAreas = [\\n      'Automated testing coverage',\\n      'CI/CD pipeline optimization',\\n      'Documentation updates',\\n      'Performance monitoring',\\n      'Security scanning automation',\\n    ];\\n    \\n    for (const area of improvementAreas) {\\n      console.log(`     \u2022 ${area}`);\\n    }\\n  }\\n\\n  private async generateMeetingSummary(meeting: PDCAMeeting): Promise<string> {\\n    const summary = `\\n\ud83d\udccb PDCA Meeting Summary\\n=====================\\nDate: ${meeting.date.toISOString()}\\nType: ${meeting.type}\\nDuration: ${meeting.duration} minutes\\nAttendees: ${meeting.attendees.length}\\n\\n\ud83d\udcca Metrics:\\n\u2022 Issues Raised: ${meeting.metrics.issuesRaised}\\n\u2022 Issues Resolved: ${meeting.metrics.issuesResolved}\\n\u2022 Action Items Created: ${meeting.metrics.actionItemsCreated}\\n\u2022 Action Items Completed: ${meeting.metrics.actionItemsCompleted}\\n\u2022 Decisions Made: ${meeting.metrics.decisionsMade}\\n\\n\ud83c\udfaf Next Meeting: ${meeting.nextMeetingDate?.toISOString() || 'TBD'}\\n`;\\n    \\n    return summary;\\n  }\\n\\n  private getOpenIssues(): PDCAIssue[] {\\n    return Array.from(this.issues.values())\\n      .filter(issue => issue.status !== 'completed' && issue.status !== 'rejected');\\n  }\\n\\n  private getOverdueActionItems(): ActionItem[] {\\n    return Array.from(this.actionItems.values())\\n      .filter(action => \\n        action.status !== 'completed' && \\n        action.dueDate < new Date()\\n      );\\n  }\\n\\n  private getNextScheduledMeeting(): PDCAMeeting | undefined {\\n    return Array.from(this.meetings.values())\\n      .filter(meeting => meeting.date > new Date())\\n      .sort((a, b) => a.date.getTime() - b.date.getTime())[0];\\n  }\\n\\n  private shouldIncludeInNextMeeting(issue: PDCAIssue): boolean {\\n    return issue.priority === 'critical' || issue.priority === 'high';\\n  }\\n\\n  private generateMeetingId(type: string, date: Date): string {\\n    return `pdca-${type}-${date.toISOString().split('T')[0]}`;\\n  }\\n\\n  private generateIssueId(): string {\\n    return `issue-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\\n  }\\n\\n  private generateActionId(): string {\\n    return `action-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\\n  }\\n\\n  private initializeMetrics(): MeetingMetrics {\\n    return {\\n      issuesRaised: 0,\\n      issuesResolved: 0,\\n      actionItemsCreated: 0,\\n      actionItemsCompleted: 0,\\n      decisionsMade: 0,\\n      attendanceRate: 100,\\n    };\\n  }\\n\\n  private getDefaultDuration(type: PDCAMeeting['type']): number {\\n    switch (type) {\\n      case 'monthly': return 90;\\n      case 'sprint-retro': return 60;\\n      case 'quarterly': return 120;\\n      case 'adhoc': return 45;\\n      default: return 60;\\n    }\\n  }\\n\\n  private generateMeetingDescription(meeting: PDCAMeeting): string {\\n    return `PDCA Meeting - ${meeting.type}\\\\n\\\\nAgenda:\\\\n${meeting.agenda.map(item => `\u2022 ${item.title} (${item.timeAllocation}min)`).join('\\\\n')}`;\\n  }\\n\\n  private mapStatusToTicketSystem(status: ActionItem['status']): string {\\n    switch (status) {\\n      case 'pending': return 'Open';\\n      case 'in-progress': return 'In Progress';\\n      case 'completed': return 'Done';\\n      case 'overdue': return 'Blocked';\\n      default: return 'Open';\\n    }\\n  }\\n\\n  private estimateEffort(issue: PDCAIssue): number {\\n    const effortMap = {\\n      small: 4,\\n      medium: 16,\\n      large: 40,\\n    };\\n    return effortMap[issue.effort] || 8;\\n  }\\n\\n  private groupByCategory<T extends { category: string }>(items: T[]) {\\n    return items.reduce((acc, item) => {\\n      acc[item.category] = (acc[item.category] || 0) + 1;\\n      return acc;\\n    }, {} as Record<string, number>);\\n  }\\n\\n  private groupByPriority<T extends { priority: string }>(items: T[]) {\\n    return items.reduce((acc, item) => {\\n      acc[item.priority] = (acc[item.priority] || 0) + 1;\\n      return acc;\\n    }, {} as Record<string, number>);\\n  }\\n\\n  private groupByStatus<T extends { status: string }>(items: T[]) {\\n    return items.reduce((acc, item) => {\\n      acc[item.status] = (acc[item.status] || 0) + 1;\\n      return acc;\\n    }, {} as Record<string, number>);\\n  }\\n\\n  private groupActionsByAssignee(actions: ActionItem[]) {\\n    return actions.reduce((acc, action) => {\\n      acc[action.assignee] = (acc[action.assignee] || 0) + 1;\\n      return acc;\\n    }, {} as Record<string, number>);\\n  }\\n\\n  private calculateAverageResolutionTime(issues: PDCAIssue[]): number {\\n    const resolvedIssues = issues.filter(i => i.status === 'completed' && i.completionDate);\\n    if (resolvedIssues.length === 0) return 0;\\n    \\n    const totalTime = resolvedIssues.reduce((sum, issue) => {\\n      const resolutionTime = issue.completionDate!.getTime() - issue.raisedDate.getTime();\\n      return sum + resolutionTime;\\n    }, 0);\\n    \\n    return totalTime / resolvedIssues.length / (24 * 60 * 60 * 1000); // Convert to days\\n  }\\n\\n  private calculateCompletionRate(actions: ActionItem[]): number {\\n    if (actions.length === 0) return 0;\\n    const completed = actions.filter(a => a.status === 'completed').length;\\n    return (completed / actions.length) * 100;\\n  }\\n\\n  private calculateAverageEffort(actions: ActionItem[]): number {\\n    const actionsWithEffort = actions.filter(a => a.actualEffort !== undefined);\\n    if (actionsWithEffort.length === 0) return 0;\\n    \\n    const totalEffort = actionsWithEffort.reduce((sum, action) => sum + action.actualEffort!, 0);\\n    return totalEffort / actionsWithEffort.length;\\n  }\\n\\n  private calculateIssueCreationTrend(issues: PDCAIssue[]): any[] {\\n    // Group issues by month for trend analysis\\n    const monthlyData = new Map<string, number>();\\n    \\n    for (const issue of issues) {\\n      const monthKey = issue.raisedDate.toISOString().substr(0, 7); // YYYY-MM\\n      monthlyData.set(monthKey, (monthlyData.get(monthKey) || 0) + 1);\\n    }\\n    \\n    return Array.from(monthlyData.entries())\\n      .sort(([a], [b]) => a.localeCompare(b))\\n      .map(([month, count]) => ({ month, count }));\\n  }\\n\\n  private calculateResolutionTrend(issues: PDCAIssue[]): any[] {\\n    const resolvedIssues = issues.filter(i => i.status === 'completed' && i.completionDate);\\n    const monthlyData = new Map<string, number>();\\n    \\n    for (const issue of resolvedIssues) {\\n      const monthKey = issue.completionDate!.toISOString().substr(0, 7);\\n      monthlyData.set(monthKey, (monthlyData.get(monthKey) || 0) + 1);\\n    }\\n    \\n    return Array.from(monthlyData.entries())\\n      .sort(([a], [b]) => a.localeCompare(b))\\n      .map(([month, count]) => ({ month, count }));\\n  }\\n\\n  private calculateMeetingEffectiveness(meetings: PDCAMeeting[]): number {\\n    if (meetings.length === 0) return 0;\\n    \\n    const totalEffectiveness = meetings.reduce((sum, meeting) => {\\n      const actionItemsRatio = meeting.metrics.actionItemsCompleted / Math.max(meeting.metrics.actionItemsCreated, 1);\\n      const issueResolutionRatio = meeting.metrics.issuesResolved / Math.max(meeting.metrics.issuesRaised, 1);\\n      const attendanceScore = meeting.metrics.attendanceRate / 100;\\n      \\n      return sum + (actionItemsRatio + issueResolutionRatio + attendanceScore) / 3;\\n    }, 0);\\n    \\n    return (totalEffectiveness / meetings.length) * 100;\\n  }\\n\\n  private async loadPersistedData(): Promise<void> {\\n    try {\\n      const dataPath = './data/pdca-data.json';\\n      if (fs.existsSync(dataPath)) {\\n        const data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));\\n        \\n        // Load meetings\\n        if (data.meetings) {\\n          for (const meeting of data.meetings) {\\n            this.meetings.set(meeting.id, {\\n              ...meeting,\\n              date: new Date(meeting.date),\\n              nextMeetingDate: meeting.nextMeetingDate ? new Date(meeting.nextMeetingDate) : undefined,\\n            });\\n          }\\n        }\\n        \\n        // Load issues\\n        if (data.issues) {\\n          for (const issue of data.issues) {\\n            this.issues.set(issue.id, {\\n              ...issue,\\n              raisedDate: new Date(issue.raisedDate),\\n              targetDate: issue.targetDate ? new Date(issue.targetDate) : undefined,\\n              completionDate: issue.completionDate ? new Date(issue.completionDate) : undefined,\\n            });\\n          }\\n        }\\n        \\n        // Load action items\\n        if (data.actionItems) {\\n          for (const action of data.actionItems) {\\n            this.actionItems.set(action.id, {\\n              ...action,\\n              dueDate: new Date(action.dueDate),\\n              completionDate: action.completionDate ? new Date(action.completionDate) : undefined,\\n            });\\n          }\\n        }\\n      }\\n    } catch (error) {\\n      console.warn('Failed to load persisted PDCA data:', error);\\n    }\\n  }\\n\\n  private async persistData(): Promise<void> {\\n    try {\\n      const data = {\\n        meetings: Array.from(this.meetings.values()),\\n        issues: Array.from(this.issues.values()),\\n        actionItems: Array.from(this.actionItems.values()),\\n        lastUpdated: new Date().toISOString(),\\n      };\\n      \\n      const dataPath = './data/pdca-data.json';\\n      const dir = path.dirname(dataPath);\\n      \\n      if (!fs.existsSync(dir)) {\\n        fs.mkdirSync(dir, { recursive: true });\\n      }\\n      \\n      fs.writeFileSync(dataPath, JSON.stringify(data, null, 2));\\n    } catch (error) {\\n      console.error('Failed to persist PDCA data:', error);\\n    }\\n  }\\n}\\n```\\n\\n## NestJS Integration\\n\\n### Backend PDCA Service\\n\\n```typescript\\n// src/pdca/pdca.service.ts\\nimport { Injectable, Logger } from '@nestjs/common';\\nimport { Cron, CronExpression } from '@nestjs/schedule';\\nimport { PDCAMeetingManager } from '../tools/pdca/meeting-manager';\\nimport { MetricsService } from '../monitoring/metrics.service';\\nimport { NotificationService } from '../notification/notification.service';\\n\\n@Injectable()\\nexport class PDCAService {\\n  private readonly logger = new Logger(PDCAService.name);\\n  private meetingManager: PDCAMeetingManager;\\n\\n  constructor(\\n    private metricsService: MetricsService,\\n    private notificationService: NotificationService\\n  ) {\\n    this.meetingManager = new PDCAMeetingManager();\\n  }\\n\\n  @Cron(CronExpression.EVERY_1ST_DAY_OF_MONTH_AT_MIDNIGHT)\\n  async scheduleMonthlyMeeting(): Promise<void> {\\n    this.logger.log('Scheduling monthly PDCA meeting');\\n    \\n    try {\\n      const firstMonday = this.getFirstMondayOfMonth(new Date());\\n      const meetingDate = new Date(firstMonday);\\n      meetingDate.setHours(14, 0, 0, 0); // 2 PM\\n      \\n      const attendees = await this.getArchitectureTeamMembers();\\n      const facilitator = await this.getNextFacilitator();\\n      \\n      const meetingId = await this.meetingManager.scheduleMeeting(\\n        'monthly',\\n        meetingDate,\\n        facilitator,\\n        attendees\\n      );\\n      \\n      // Send notifications\\n      await this.notificationService.sendMeetingInvitation({\\n        meetingId,\\n        attendees,\\n        subject: 'Monthly PDCA Meeting Scheduled',\\n        date: meetingDate,\\n      });\\n      \\n      this.logger.log(`Monthly PDCA meeting scheduled: ${meetingId}`);\\n    } catch (error) {\\n      this.logger.error('Failed to schedule monthly PDCA meeting', error);\\n    }\\n  }\\n\\n  @Cron(CronExpression.EVERY_WEEK_ON_FRIDAY_AT_10AM)\\n  async sendWeeklyReminders(): Promise<void> {\\n    this.logger.log('Sending weekly action item reminders');\\n    \\n    try {\\n      const overdueActions = await this.getOverdueActionItems();\\n      const upcomingActions = await this.getUpcomingActionItems();\\n      \\n      for (const action of overdueActions) {\\n        await this.notificationService.sendActionItemReminder({\\n          actionId: action.id,\\n          assignee: action.assignee,\\n          description: action.description,\\n          dueDate: action.dueDate,\\n          isOverdue: true,\\n        });\\n      }\\n      \\n      for (const action of upcomingActions) {\\n        await this.notificationService.sendActionItemReminder({\\n          actionId: action.id,\\n          assignee: action.assignee,\\n          description: action.description,\\n          dueDate: action.dueDate,\\n          isOverdue: false,\\n        });\\n      }\\n      \\n      this.logger.log(`Sent reminders for ${overdueActions.length} overdue and ${upcomingActions.length} upcoming action items`);\\n    } catch (error) {\\n      this.logger.error('Failed to send weekly reminders', error);\\n    }\\n  }\\n\\n  async collectArchitectureMetrics(): Promise<any> {\\n    return {\\n      codeQuality: await this.metricsService.getCodeQualityMetrics(),\\n      testCoverage: await this.metricsService.getTestCoverageMetrics(),\\n      performance: await this.metricsService.getPerformanceMetrics(),\\n      security: await this.metricsService.getSecurityMetrics(),\\n      technicalDebt: await this.metricsService.getTechnicalDebtMetrics(),\\n    };\\n  }\\n\\n  async raiseIssue(issueData: any): Promise<string> {\\n    return this.meetingManager.addIssue(issueData);\\n  }\\n\\n  async updateActionItem(actionId: string, updateData: any): Promise<void> {\\n    return this.meetingManager.updateActionItemStatus(\\n      actionId,\\n      updateData.status,\\n      updateData.notes,\\n      updateData.actualEffort\\n    );\\n  }\\n\\n  async generateProgressReport(): Promise<any> {\\n    return this.meetingManager.generateProgressReport();\\n  }\\n\\n  private getFirstMondayOfMonth(date: Date): Date {\\n    const firstDay = new Date(date.getFullYear(), date.getMonth(), 1);\\n    const dayOfWeek = firstDay.getDay();\\n    const daysUntilMonday = dayOfWeek === 0 ? 1 : (8 - dayOfWeek) % 7;\\n    return new Date(firstDay.getTime() + daysUntilMonday * 24 * 60 * 60 * 1000);\\n  }\\n\\n  private async getArchitectureTeamMembers(): Promise<string[]> {\\n    // This would typically fetch from a user service or configuration\\n    return [\\n      'chief-architect',\\n      'senior-backend-developer',\\n      'senior-frontend-developer',\\n      'devops-engineer',\\n      'qa-lead',\\n    ];\\n  }\\n\\n  private async getNextFacilitator(): Promise<string> {\\n    // Rotate facilitator responsibility\\n    const facilitators = await this.getArchitectureTeamMembers();\\n    const lastMeetings = Array.from(this.meetingManager['meetings'].values())\\n      .filter(m => m.type === 'monthly')\\n      .sort((a, b) => b.date.getTime() - a.date.getTime());\\n    \\n    if (lastMeetings.length === 0) {\\n      return facilitators[0];\\n    }\\n    \\n    const lastFacilitator = lastMeetings[0].facilitator;\\n    const currentIndex = facilitators.indexOf(lastFacilitator);\\n    return facilitators[(currentIndex + 1) % facilitators.length];\\n  }\\n\\n  private async getOverdueActionItems(): Promise<any[]> {\\n    // Implementation would retrieve overdue action items\\n    return [];\\n  }\\n\\n  private async getUpcomingActionItems(): Promise<any[]> {\\n    // Implementation would retrieve action items due in the next week\\n    return [];\\n  }\\n}\\n```\\n\\n## Next.js Dashboard\\n\\n### PDCA Dashboard Component\\n\\n```typescript\\n// components/PDCADashboard.tsx\\nimport React, { useState, useEffect } from 'react';\\nimport { Calendar, Clock, CheckCircle, AlertTriangle, Users, TrendingUp } from 'lucide-react';\\n\\ninterface PDCADashboardProps {\\n  className?: string;\\n}\\n\\nexport const PDCADashboard: React.FC<PDCADashboardProps> = ({ className }) => {\\n  const [data, setData] = useState<any>(null);\\n  const [loading, setLoading] = useState(true);\\n  const [selectedTab, setSelectedTab] = useState('overview');\\n\\n  useEffect(() => {\\n    fetchPDCAData();\\n  }, []);\\n\\n  const fetchPDCAData = async () => {\\n    try {\\n      setLoading(true);\\n      const response = await fetch('/api/pdca/progress-report');\\n      const result = await response.json();\\n      setData(result);\\n    } catch (error) {\\n      console.error('Failed to fetch PDCA data:', error);\\n    } finally {\\n      setLoading(false);\\n    }\\n  };\\n\\n  const raiseIssue = async (issueData: any) => {\\n    try {\\n      await fetch('/api/pdca/issues', {\\n        method: 'POST',\\n        headers: { 'Content-Type': 'application/json' },\\n        body: JSON.stringify(issueData),\\n      });\\n      \\n      await fetchPDCAData(); // Refresh data\\n    } catch (error) {\\n      console.error('Failed to raise issue:', error);\\n    }\\n  };\\n\\n  if (loading) {\\n    return (\\n      <div className=\\\"flex items-center justify-center h-64\\\">\\n        <div className=\\\"animate-spin rounded-full h-32 w-32 border-b-2 border-blue-500\\\"></div>\\n      </div>\\n    );\\n  }\\n\\n  if (!data) {\\n    return (\\n      <div className=\\\"text-center py-8\\\">\\n        <p className=\\\"text-gray-500\\\">Failed to load PDCA data</p>\\n      </div>\\n    );\\n  }\\n\\n  return (\\n    <div className={`bg-white rounded-lg shadow-lg ${className}`}>\\n      {/* Header */}\\n      <div className=\\\"p-6 border-b border-gray-200\\\">\\n        <div className=\\\"flex justify-between items-center\\\">\\n          <div>\\n            <h2 className=\\\"text-2xl font-bold text-gray-900\\\">PDCA Dashboard</h2>\\n            <p className=\\\"text-gray-600\\\">Plan-Do-Check-Act Management</p>\\n          </div>\\n          <button\\n            onClick={() => raiseIssue({\\n              title: 'New Issue',\\n              description: 'Issue description',\\n              category: 'architecture',\\n              priority: 'medium',\\n              impact: 'medium',\\n              effort: 'medium',\\n              raisedBy: 'current-user',\\n              tags: [],\\n            })}\\n            className=\\\"bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors\\\"\\n          >\\n            Raise Issue\\n          </button>\\n        </div>\\n      </div>\\n\\n      {/* Tabs */}\\n      <div className=\\\"border-b border-gray-200\\\">\\n        <nav className=\\\"-mb-px flex space-x-8 px-6\\\">\\n          {['overview', 'issues', 'actions', 'meetings', 'trends'].map((tab) => (\\n            <button\\n              key={tab}\\n              onClick={() => setSelectedTab(tab)}\\n              className={`py-4 px-1 border-b-2 font-medium text-sm capitalize ${\\n                selectedTab === tab\\n                  ? 'border-blue-500 text-blue-600'\\n                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'\\n              }`}\\n            >\\n              {tab}\\n            </button>\\n          ))}\\n        </nav>\\n      </div>\\n\\n      {/* Content */}\\n      <div className=\\\"p-6\\\">\\n        {selectedTab === 'overview' && (\\n          <div className=\\\"space-y-6\\\">\\n            {/* Summary Cards */}\\n            <div className=\\\"grid grid-cols-1 md:grid-cols-4 gap-6\\\">\\n              <div className=\\\"bg-blue-50 p-4 rounded-lg\\\">\\n                <div className=\\\"flex items-center\\\">\\n                  <CheckCircle className=\\\"h-8 w-8 text-blue-600\\\" />\\n                  <div className=\\\"ml-3\\\">\\n                    <p className=\\\"text-sm font-medium text-blue-600\\\">Total Issues</p>\\n                    <p className=\\\"text-2xl font-bold text-blue-900\\\">{data.summary.totalIssues}</p>\\n                  </div>\\n                </div>\\n              </div>\\n              \\n              <div className=\\\"bg-green-50 p-4 rounded-lg\\\">\\n                <div className=\\\"flex items-center\\\">\\n                  <CheckCircle className=\\\"h-8 w-8 text-green-600\\\" />\\n                  <div className=\\\"ml-3\\\">\\n                    <p className=\\\"text-sm font-medium text-green-600\\\">Resolved Issues</p>\\n                    <p className=\\\"text-2xl font-bold text-green-900\\\">{data.summary.resolvedIssues}</p>\\n                  </div>\\n                </div>\\n              </div>\\n              \\n              <div className=\\\"bg-yellow-50 p-4 rounded-lg\\\">\\n                <div className=\\\"flex items-center\\\">\\n                  <Clock className=\\\"h-8 w-8 text-yellow-600\\\" />\\n                  <div className=\\\"ml-3\\\">\\n                    <p className=\\\"text-sm font-medium text-yellow-600\\\">Action Items</p>\\n                    <p className=\\\"text-2xl font-bold text-yellow-900\\\">{data.summary.totalActionItems}</p>\\n                  </div>\\n                </div>\\n              </div>\\n              \\n              <div className=\\\"bg-purple-50 p-4 rounded-lg\\\">\\n                <div className=\\\"flex items-center\\\">\\n                  <Users className=\\\"h-8 w-8 text-purple-600\\\" />\\n                  <div className=\\\"ml-3\\\">\\n                    <p className=\\\"text-sm font-medium text-purple-600\\\">Recent Meetings</p>\\n                    <p className=\\\"text-2xl font-bold text-purple-900\\\">{data.summary.recentMeetings}</p>\\n                  </div>\\n                </div>\\n              </div>\\n            </div>\\n\\n            {/* Charts and Analysis */}\\n            <div className=\\\"grid grid-cols-1 lg:grid-cols-2 gap-6\\\">\\n              {/* Issue Analysis */}\\n              <div className=\\\"bg-gray-50 p-4 rounded-lg\\\">\\n                <h3 className=\\\"text-lg font-semibold text-gray-900 mb-4\\\">Issue Analysis</h3>\\n                <div className=\\\"space-y-3\\\">\\n                  <div>\\n                    <h4 className=\\\"font-medium text-gray-700\\\">By Category</h4>\\n                    <div className=\\\"mt-2 space-y-2\\\">\\n                      {Object.entries(data.issueAnalysis.byCategory).map(([category, count]) => (\\n                        <div key={category} className=\\\"flex justify-between\\\">\\n                          <span className=\\\"text-sm text-gray-600 capitalize\\\">{category}</span>\\n                          <span className=\\\"text-sm font-medium\\\">{count as number}</span>\\n                        </div>\\n                      ))}\\n                    </div>\\n                  </div>\\n                  \\n                  <div>\\n                    <h4 className=\\\"font-medium text-gray-700\\\">By Priority</h4>\\n                    <div className=\\\"mt-2 space-y-2\\\">\\n                      {Object.entries(data.issueAnalysis.byPriority).map(([priority, count]) => (\\n                        <div key={priority} className=\\\"flex justify-between\\\">\\n                          <span className={`text-sm capitalize ${\\n                            priority === 'critical' ? 'text-red-600' :\\n                            priority === 'high' ? 'text-orange-600' :\\n                            priority === 'medium' ? 'text-yellow-600' :\\n                            'text-gray-600'\\n                          }`}>{priority}</span>\\n                          <span className=\\\"text-sm font-medium\\\">{count as number}</span>\\n                        </div>\\n                      ))}\\n                    </div>\\n                  </div>\\n                </div>\\n              </div>\\n\\n              {/* Action Item Analysis */}\\n              <div className=\\\"bg-gray-50 p-4 rounded-lg\\\">\\n                <h3 className=\\\"text-lg font-semibold text-gray-900 mb-4\\\">Action Items</h3>\\n                <div className=\\\"space-y-3\\\">\\n                  <div className=\\\"flex justify-between items-center\\\">\\n                    <span className=\\\"text-sm text-gray-600\\\">Completion Rate</span>\\n                    <span className=\\\"text-lg font-bold text-green-600\\\">\\n                      {data.actionItemAnalysis.completionRate.toFixed(1)}%\\n                    </span>\\n                  </div>\\n                  \\n                  <div className=\\\"flex justify-between items-center\\\">\\n                    <span className=\\\"text-sm text-gray-600\\\">Average Effort</span>\\n                    <span className=\\\"text-sm font-medium\\\">\\n                      {data.actionItemAnalysis.averageEffort.toFixed(1)}h\\n                    </span>\\n                  </div>\\n                  \\n                  <div className=\\\"flex justify-between items-center\\\">\\n                    <span className=\\\"text-sm text-red-600\\\">Overdue Items</span>\\n                    <span className=\\\"text-sm font-medium text-red-600\\\">\\n                      {data.actionItemAnalysis.overdueItems.length}\\n                    </span>\\n                  </div>\\n\\n                  {data.actionItemAnalysis.overdueItems.length > 0 && (\\n                    <div className=\\\"mt-4\\\">\\n                      <h4 className=\\\"font-medium text-gray-700 mb-2\\\">Overdue Items</h4>\\n                      <div className=\\\"space-y-2\\\">\\n                        {data.actionItemAnalysis.overdueItems.slice(0, 3).map((item: any) => (\\n                          <div key={item.id} className=\\\"text-xs bg-red-50 p-2 rounded\\\">\\n                            <div className=\\\"font-medium\\\">{item.description}</div>\\n                            <div className=\\\"text-gray-600\\\">{item.assignee} \u2022 Due: {new Date(item.dueDate).toLocaleDateString()}</div>\\n                          </div>\\n                        ))}\\n                      </div>\\n                    </div>\\n                  )}\\n                </div>\\n              </div>\\n            </div>\\n          </div>\\n        )}\\n\\n        {selectedTab === 'trends' && (\\n          <div className=\\\"space-y-6\\\">\\n            <div className=\\\"flex items-center\\\">\\n              <TrendingUp className=\\\"h-6 w-6 text-blue-600 mr-2\\\" />\\n              <h3 className=\\\"text-lg font-semibold text-gray-900\\\">Trends & Analytics</h3>\\n            </div>\\n            \\n            {/* Trend charts would go here */}\\n            <div className=\\\"bg-gray-50 p-8 rounded-lg text-center\\\">\\n              <p className=\\\"text-gray-500\\\">Trend visualization components would be implemented here</p>\\n              <p className=\\\"text-sm text-gray-400 mt-2\\\">Charts showing issue creation, resolution trends, and meeting effectiveness</p>\\n            </div>\\n          </div>\\n        )}\\n\\n        {/* Other tab content would be implemented similarly */}\\n        {selectedTab !== 'overview' && selectedTab !== 'trends' && (\\n          <div className=\\\"bg-gray-50 p-8 rounded-lg text-center\\\">\\n            <p className=\\\"text-gray-500 capitalize\\\">{selectedTab} content coming soon</p>\\n          </div>\\n        )}\\n      </div>\\n    </div>\\n  );\\n};\\n```\\n\\n## Integration with Development Workflow\\n\\n### GitHub Actions Integration\\n\\n```yaml\\n# .github/workflows/pdca-automation.yml\\nname: PDCA Automation\\n\\non:\\n  schedule:\\n    - cron: '0 9 * * MON' # Every Monday at 9 AM\\n  issues:\\n    types: [opened, closed]\\n  pull_request:\\n    types: [opened, closed, merged]\\n  workflow_dispatch:\\n    inputs:\\n      action:\\n        description: 'PDCA action to perform'\\n        required: true\\n        type: choice\\n        options:\\n          - 'generate-report'\\n          - 'check-overdue-actions'\\n          - 'schedule-meeting'\\n          - 'send-reminders'\\n\\njobs:\\n  pdca-automation:\\n    name: PDCA Automation\\n    runs-on: ubuntu-latest\\n    \\n    steps:\\n    - name: Checkout\\n      uses: actions/checkout@v4\\n\\n    - name: Setup Node.js\\n      uses: actions/setup-node@v4\\n      with:\\n        node-version: '18'\\n        cache: 'npm'\\n\\n    - name: Install dependencies\\n      run: npm ci\\n\\n    - name: Auto-raise Issues from Failures\\n      if: github.event_name == 'issues' && github.event.action == 'opened'\\n      run: |\\n        npm run pdca:auto-raise-issue\\n      env:\\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n        ISSUE_NUMBER: ${{ github.event.issue.number }}\\n\\n    - name: Update Action Items from PR\\n      if: github.event_name == 'pull_request'\\n      run: |\\n        npm run pdca:update-from-pr\\n      env:\\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n        PR_NUMBER: ${{ github.event.pull_request.number }}\\n\\n    - name: Generate Weekly Report\\n      if: github.event_name == 'schedule' || github.event.inputs.action == 'generate-report'\\n      run: |\\n        npm run pdca:generate-report\\n        npm run pdca:analyze-trends\\n\\n    - name: Check Overdue Actions\\n      if: github.event.inputs.action == 'check-overdue-actions' || github.event_name == 'schedule'\\n      run: |\\n        npm run pdca:check-overdue\\n        npm run pdca:send-reminders\\n\\n    - name: Schedule Next Meeting\\n      if: github.event.inputs.action == 'schedule-meeting'\\n      run: |\\n        npm run pdca:schedule-meeting\\n\\n    - name: Upload Reports\\n      if: github.event_name == 'schedule'\\n      uses: actions/upload-artifact@v4\\n      with:\\n        name: pdca-reports\\n        path: |\\n          reports/pdca-*.json\\n          reports/pdca-*.html\\n\\n    - name: Post Weekly Summary\\n      if: github.event_name == 'schedule'\\n      uses: actions/github-script@v7\\n      with:\\n        script: |\\n          const fs = require('fs');\\n          \\n          if (fs.existsSync('reports/pdca-weekly-summary.json')) {\\n            const report = JSON.parse(fs.readFileSync('reports/pdca-weekly-summary.json', 'utf8'));\\n            \\n            const summary = `\\n            ## \ud83d\udccb Weekly PDCA Summary\\n            \\n            **Period:** ${report.period}\\n            \\n            ### \ud83d\udcca Metrics\\n            - **Issues Raised:** ${report.metrics.issuesRaised}\\n            - **Issues Resolved:** ${report.metrics.issuesResolved}\\n            - **Action Items Completed:** ${report.metrics.actionItemsCompleted}\\n            - **Overdue Actions:** ${report.metrics.overdueActions}\\n            \\n            ### \ud83c\udfaf This Week's Focus\\n            ${report.focus.map(item => `- ${item}`).join('\\\\n')}\\n            \\n            ### \u26a0\ufe0f Risks & Blockers\\n            ${report.risks.map(risk => `- ${risk.description} (${risk.priority})`).join('\\\\n')}\\n            \\n            ### \ud83d\udcc5 Upcoming\\n            - Next PDCA Meeting: ${report.nextMeetingDate}\\n            - Pending Reviews: ${report.pendingReviews}\\n            \\n            [View Full Report](${report.reportUrl})\\n            `;\\n            \\n            // Create or update pinned issue\\n            const issues = await github.rest.issues.listForRepo({\\n              owner: context.repo.owner,\\n              repo: context.repo.repo,\\n              labels: 'pdca-weekly-summary',\\n              state: 'open'\\n            });\\n            \\n            if (issues.data.length > 0) {\\n              await github.rest.issues.update({\\n                owner: context.repo.owner,\\n                repo: context.repo.repo,\\n                issue_number: issues.data[0].number,\\n                title: `\ud83d\udccb PDCA Weekly Summary - ${new Date().toISOString().split('T')[0]}`,\\n                body: summary\\n              });\\n            } else {\\n              await github.rest.issues.create({\\n                owner: context.repo.owner,\\n                repo: context.repo.repo,\\n                title: `\ud83d\udccb PDCA Weekly Summary - ${new Date().toISOString().split('T')[0]}`,\\n                body: summary,\\n                labels: ['pdca-weekly-summary', 'pinned']\\n              });\\n            }\\n          }\\n```\\n\\n## Related Documentation\\n\\n- **[Skills Assessment](./skills-assessment.md)** - Team capability evaluation\\n- **[Architecture Roadmap](./architecture-roadmap.md)** - Strategic planning\\n- **[Solution Review Process](./solution-review-process.md)** - Peer architecture reviews\\n\\n---\\n\\nThis PDCA meetings guide should be regularly updated to reflect evolving team needs and organizational practices.\n"})})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);