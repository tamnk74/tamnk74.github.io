"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[9264],{7737:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"security-practices/security-implementation/compliance-automation","title":"Security Compliance Automation Implementation Guide","description":"Overview","source":"@site/docs/security-practices/security-implementation/compliance-automation.md","sourceDirName":"security-practices/security-implementation","slug":"/security-practices/security-implementation/compliance-automation","permalink":"/fullstack-dev/docs/security-practices/security-implementation/compliance-automation","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/security-practices/security-implementation/compliance-automation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Security Monitoring & Observability Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/security-monitoring"},"next":{"title":"Network Security Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/network-security"}}');var i=t(5813),s=t(7814);const r={},o="Security Compliance Automation Implementation Guide",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Compliance Framework Overview",id:"compliance-framework-overview",level:2},{value:"Architecture Components",id:"architecture-components",level:3},{value:"GDPR Compliance Automation",id:"gdpr-compliance-automation",level:2},{value:"1. Data Discovery &amp; Classification Service",id:"1-data-discovery--classification-service",level:3},{value:"2. Automated Consent Management",id:"2-automated-consent-management",level:3},{value:"3. Data Subject Rights Automation",id:"3-data-subject-rights-automation",level:3},{value:"PCI DSS Compliance Automation",id:"pci-dss-compliance-automation",level:2},{value:"1. Card Data Discovery &amp; Protection",id:"1-card-data-discovery--protection",level:3},{value:"2. Access Control Monitoring",id:"2-access-control-monitoring",level:3},{value:"Automated Policy Enforcement",id:"automated-policy-enforcement",level:2},{value:"1. Policy Engine Service",id:"1-policy-engine-service",level:3},{value:"Compliance Reporting &amp; Dashboards",id:"compliance-reporting--dashboards",level:2},{value:"1. Automated Compliance Reporting",id:"1-automated-compliance-reporting",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Implementation Guidelines",id:"1-implementation-guidelines",level:3},{value:"2. Data Management",id:"2-data-management",level:3},{value:"3. Privacy by Design",id:"3-privacy-by-design",level:3},{value:"4. Security Integration",id:"4-security-integration",level:3},{value:"Related Guides",id:"related-guides",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"security-compliance-automation-implementation-guide",children:"Security Compliance Automation Implementation Guide"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"This guide provides comprehensive instructions for implementing automated security compliance monitoring and reporting in NestJS/Next.js applications deployed on Google Cloud Platform (GCP) Kubernetes, focusing on GDPR, PCI DSS, HIPAA, and SOC 2 compliance automation."}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#compliance-framework-overview",children:"Compliance Framework Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#gdpr-compliance-automation",children:"GDPR Compliance Automation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#pci-dss-compliance-automation",children:"PCI DSS Compliance Automation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#automated-policy-enforcement",children:"Automated Policy Enforcement"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#compliance-reporting--dashboards",children:"Compliance Reporting & Dashboards"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"compliance-framework-overview",children:"Compliance Framework Overview"}),"\n",(0,i.jsx)(n.h3,{id:"architecture-components",children:"Architecture Components"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Compliance automation architecture\ninterface ComplianceFramework {\n  dataGovernance: {\n    dataClassification: 'Automated data discovery and classification',\n    dataInventory: 'Real-time data inventory management',\n    dataLineage: 'Automated data flow tracking',\n    dataRetention: 'Policy-based data lifecycle management'\n  },\n  accessControl: {\n    identityManagement: 'Automated identity provisioning/deprovisioning',\n    accessReviews: 'Automated access reviews and certification',\n    privilegedAccess: 'Just-in-time privileged access management',\n    segregationOfDuties: 'Automated SoD policy enforcement'\n  },\n  monitoring: {\n    continuousCompliance: 'Real-time compliance monitoring',\n    violationDetection: 'Automated compliance violation detection',\n    riskAssessment: 'Continuous risk assessment automation',\n    alerting: 'Compliance-based alerting and escalation'\n  },\n  reporting: {\n    automaticReports: 'Scheduled compliance reports',\n    dashboards: 'Real-time compliance dashboards',\n    auditSupport: 'Automated audit evidence collection',\n    remediation: 'Automated remediation tracking'\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"gdpr-compliance-automation",children:"GDPR Compliance Automation"}),"\n",(0,i.jsx)(n.h3,{id:"1-data-discovery--classification-service",children:"1. Data Discovery & Classification Service"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/compliance/gdpr/data-discovery.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\n\ninterface PersonalDataField {\n  table: string;\n  column: string;\n  dataType: 'PII' | 'SENSITIVE_PII' | 'SPECIAL_CATEGORY';\n  classification: string;\n  retentionPeriod: number; // in days\n  lawfulBasis: string;\n  processingPurpose: string;\n}\n\n@Injectable()\nexport class DataDiscoveryService {\n  private readonly logger = new Logger(DataDiscoveryService.name);\n  \n  private readonly personalDataPatterns = [\n    { pattern: /email/i, type: 'PII', classification: 'Contact Information' },\n    { pattern: /phone|mobile/i, type: 'PII', classification: 'Contact Information' },\n    { pattern: /address|street|city|postal|zip/i, type: 'PII', classification: 'Address Information' },\n    { pattern: /birth|dob|age/i, type: 'PII', classification: 'Demographic Information' },\n    { pattern: /ssn|social_security|national_id/i, type: 'SENSITIVE_PII', classification: 'Identity Numbers' },\n    { pattern: /passport|driver_license|id_number/i, type: 'SENSITIVE_PII', classification: 'Identity Documents' },\n    { pattern: /medical|health|diagnosis/i, type: 'SPECIAL_CATEGORY', classification: 'Health Data' },\n    { pattern: /religion|belief|political/i, type: 'SPECIAL_CATEGORY', classification: 'Belief/Opinion Data' },\n    { pattern: /biometric|fingerprint|facial/i, type: 'SPECIAL_CATEGORY', classification: 'Biometric Data' }\n  ];\n\n  async discoverPersonalData(): Promise<PersonalDataField[]> {\n    const discoveredFields: PersonalDataField[] = [];\n    \n    // Get database schema information\n    const tables = await this.getDatabaseTables();\n    \n    for (const table of tables) {\n      const columns = await this.getTableColumns(table);\n      \n      for (const column of columns) {\n        const classification = this.classifyColumn(column.name, column.type);\n        \n        if (classification) {\n          discoveredFields.push({\n            table: table.name,\n            column: column.name,\n            dataType: classification.type,\n            classification: classification.classification,\n            retentionPeriod: this.getRetentionPeriod(classification.type),\n            lawfulBasis: this.determineLawfulBasis(classification.type),\n            processingPurpose: this.determineProcessingPurpose(classification.classification)\n          });\n        }\n      }\n    }\n\n    // Store discovered data in compliance database\n    await this.storeDataInventory(discoveredFields);\n    \n    this.logger.log(`Discovered ${discoveredFields.length} personal data fields`);\n    return discoveredFields;\n  }\n\n  private classifyColumn(columnName: string, columnType: string) {\n    for (const pattern of this.personalDataPatterns) {\n      if (pattern.pattern.test(columnName)) {\n        return {\n          type: pattern.type,\n          classification: pattern.classification\n        };\n      }\n    }\n    return null;\n  }\n\n  private getRetentionPeriod(dataType: string): number {\n    switch (dataType) {\n      case 'SPECIAL_CATEGORY': return 365; // 1 year\n      case 'SENSITIVE_PII': return 2555; // 7 years\n      case 'PII': return 1095; // 3 years\n      default: return 365;\n    }\n  }\n\n  private determineLawfulBasis(dataType: string): string {\n    switch (dataType) {\n      case 'SPECIAL_CATEGORY': return 'Explicit consent';\n      case 'SENSITIVE_PII': return 'Legal obligation';\n      case 'PII': return 'Legitimate interest';\n      default: return 'Consent';\n    }\n  }\n\n  private determineProcessingPurpose(classification: string): string {\n    switch (classification) {\n      case 'Contact Information': return 'Customer communication';\n      case 'Address Information': return 'Service delivery';\n      case 'Identity Numbers': return 'Legal compliance';\n      case 'Health Data': return 'Healthcare services';\n      default: return 'Business operations';\n    }\n  }\n\n  private async getDatabaseTables() {\n    // Implementation to get database tables\n    // This would use your database connection to get schema information\n    return [];\n  }\n\n  private async getTableColumns(table: any) {\n    // Implementation to get table columns\n    return [];\n  }\n\n  private async storeDataInventory(fields: PersonalDataField[]) {\n    // Store in compliance database for tracking\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-automated-consent-management",children:"2. Automated Consent Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/compliance/gdpr/consent-management.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\ninterface ConsentRecord {\n  userId: string;\n  consentId: string;\n  purpose: string;\n  lawfulBasis: string;\n  consentGiven: boolean;\n  consentDate: Date;\n  withdrawalDate?: Date;\n  consentSource: 'website' | 'api' | 'email' | 'phone';\n  ipAddress: string;\n  userAgent: string;\n  version: string;\n}\n\n@Injectable()\nexport class ConsentManagementService {\n  private readonly logger = new Logger(ConsentManagementService.name);\n\n  async recordConsent(consentData: Omit<ConsentRecord, 'consentId' | 'consentDate'>) {\n    const consentRecord: ConsentRecord = {\n      ...consentData,\n      consentId: this.generateConsentId(),\n      consentDate: new Date(),\n    };\n\n    // Store consent record\n    await this.storeConsentRecord(consentRecord);\n\n    // Update user's consent status\n    await this.updateUserConsentStatus(consentData.userId, consentData.purpose, true);\n\n    // Log consent for audit trail\n    this.logger.log(`Consent recorded for user ${consentData.userId} for purpose: ${consentData.purpose}`);\n\n    return consentRecord;\n  }\n\n  async withdrawConsent(userId: string, purpose: string, withdrawalReason?: string) {\n    // Update consent record\n    await this.updateConsentWithdrawal(userId, purpose, withdrawalReason);\n\n    // Update user's consent status\n    await this.updateUserConsentStatus(userId, purpose, false);\n\n    // Trigger data deletion if required\n    await this.triggerDataDeletion(userId, purpose);\n\n    this.logger.log(`Consent withdrawn for user ${userId} for purpose: ${purpose}`);\n  }\n\n  async checkConsentValidity(userId: string, purpose: string): Promise<boolean> {\n    const consent = await this.getLatestConsent(userId, purpose);\n    \n    if (!consent || !consent.consentGiven || consent.withdrawalDate) {\n      return false;\n    }\n\n    // Check if consent has expired (GDPR recommends re-consent every 2 years)\n    const consentAge = Date.now() - consent.consentDate.getTime();\n    const maxAge = 2 * 365 * 24 * 60 * 60 * 1000; // 2 years in milliseconds\n\n    return consentAge < maxAge;\n  }\n\n  async generateConsentReport(startDate: Date, endDate: Date) {\n    const consents = await this.getConsentsInPeriod(startDate, endDate);\n    \n    return {\n      totalConsents: consents.length,\n      consentsByPurpose: this.groupConsentsByPurpose(consents),\n      withdrawalRate: this.calculateWithdrawalRate(consents),\n      complianceMetrics: await this.calculateComplianceMetrics(consents)\n    };\n  }\n\n  private generateConsentId(): string {\n    return `consent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async storeConsentRecord(record: ConsentRecord) {\n    // Store in tamper-proof storage (e.g., blockchain or immutable database)\n  }\n\n  private async updateUserConsentStatus(userId: string, purpose: string, status: boolean) {\n    // Update user's active consent status in application database\n  }\n\n  private async updateConsentWithdrawal(userId: string, purpose: string, reason?: string) {\n    // Update consent record with withdrawal information\n  }\n\n  private async triggerDataDeletion(userId: string, purpose: string) {\n    // Trigger right to erasure process if consent withdrawal requires data deletion\n  }\n\n  private async getLatestConsent(userId: string, purpose: string) {\n    // Get the most recent consent record for user and purpose\n    return null;\n  }\n\n  private async getConsentsInPeriod(startDate: Date, endDate: Date) {\n    // Get all consent records in the specified period\n    return [];\n  }\n\n  private groupConsentsByPurpose(consents: ConsentRecord[]) {\n    // Group consents by processing purpose\n    return {};\n  }\n\n  private calculateWithdrawalRate(consents: ConsentRecord[]) {\n    // Calculate percentage of withdrawn consents\n    return 0;\n  }\n\n  private async calculateComplianceMetrics(consents: ConsentRecord[]) {\n    // Calculate various compliance metrics\n    return {};\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-data-subject-rights-automation",children:"3. Data Subject Rights Automation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/compliance/gdpr/data-subject-rights.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\ninterface DataSubjectRequest {\n  requestId: string;\n  userId: string;\n  requestType: 'ACCESS' | 'RECTIFICATION' | 'ERASURE' | 'PORTABILITY' | 'RESTRICTION' | 'OBJECTION';\n  requestDate: Date;\n  verificationStatus: 'PENDING' | 'VERIFIED' | 'REJECTED';\n  fulfillmentStatus: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'REJECTED';\n  completionDate?: Date;\n  rejectionReason?: string;\n  requestDetails: any;\n}\n\n@Injectable()\nexport class DataSubjectRightsService {\n  private readonly logger = new Logger(DataSubjectRightsService.name);\n\n  async submitDataSubjectRequest(\n    userId: string,\n    requestType: DataSubjectRequest['requestType'],\n    requestDetails: any\n  ): Promise<DataSubjectRequest> {\n    const request: DataSubjectRequest = {\n      requestId: this.generateRequestId(),\n      userId,\n      requestType,\n      requestDate: new Date(),\n      verificationStatus: 'PENDING',\n      fulfillmentStatus: 'PENDING',\n      requestDetails\n    };\n\n    await this.storeRequest(request);\n    \n    // Trigger verification process\n    await this.initiateVerificationProcess(request);\n\n    this.logger.log(`Data subject request submitted: ${request.requestId}`);\n    return request;\n  }\n\n  async fulfillAccessRequest(requestId: string): Promise<any> {\n    const request = await this.getRequest(requestId);\n    \n    if (request.verificationStatus !== 'VERIFIED') {\n      throw new Error('Request not verified');\n    }\n\n    // Collect all personal data for the user\n    const personalData = await this.collectPersonalData(request.userId);\n    \n    // Generate data export\n    const exportData = await this.generateDataExport(personalData);\n    \n    // Update request status\n    await this.updateRequestStatus(requestId, 'COMPLETED');\n    \n    this.logger.log(`Access request fulfilled: ${requestId}`);\n    return exportData;\n  }\n\n  async fulfillErasureRequest(requestId: string): Promise<void> {\n    const request = await this.getRequest(requestId);\n    \n    if (request.verificationStatus !== 'VERIFIED') {\n      throw new Error('Request not verified');\n    }\n\n    // Check if erasure is legally possible\n    const canErase = await this.checkErasureLegality(request.userId);\n    \n    if (!canErase.allowed) {\n      await this.rejectRequest(requestId, canErase.reason);\n      return;\n    }\n\n    // Perform data erasure\n    await this.performDataErasure(request.userId, request.requestDetails);\n    \n    // Update request status\n    await this.updateRequestStatus(requestId, 'COMPLETED');\n    \n    this.logger.log(`Erasure request fulfilled: ${requestId}`);\n  }\n\n  async fulfillPortabilityRequest(requestId: string): Promise<any> {\n    const request = await this.getRequest(requestId);\n    \n    if (request.verificationStatus !== 'VERIFIED') {\n      throw new Error('Request not verified');\n    }\n\n    // Collect portable data (data provided by the data subject or generated by their use of the service)\n    const portableData = await this.collectPortableData(request.userId);\n    \n    // Generate structured data export (JSON, CSV, XML)\n    const exportFormat = request.requestDetails.format || 'JSON';\n    const structuredExport = await this.generateStructuredExport(portableData, exportFormat);\n    \n    // Update request status\n    await this.updateRequestStatus(requestId, 'COMPLETED');\n    \n    this.logger.log(`Portability request fulfilled: ${requestId}`);\n    return structuredExport;\n  }\n\n  async generateComplianceReport(): Promise<any> {\n    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n    const requests = await this.getRequestsSince(thirtyDaysAgo);\n    \n    return {\n      totalRequests: requests.length,\n      requestsByType: this.groupRequestsByType(requests),\n      averageResponseTime: await this.calculateAverageResponseTime(requests),\n      complianceRate: this.calculateComplianceRate(requests),\n      overdueRequests: this.getOverdueRequests(requests)\n    };\n  }\n\n  private generateRequestId(): string {\n    return `dsr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async storeRequest(request: DataSubjectRequest) {\n    // Store request in secure database\n  }\n\n  private async initiateVerificationProcess(request: DataSubjectRequest) {\n    // Implement identity verification process\n  }\n\n  private async getRequest(requestId: string): Promise<DataSubjectRequest> {\n    // Retrieve request from database\n    return null as any;\n  }\n\n  private async collectPersonalData(userId: string) {\n    // Collect all personal data associated with the user\n    return {};\n  }\n\n  private async generateDataExport(personalData: any) {\n    // Generate human-readable data export\n    return {};\n  }\n\n  private async updateRequestStatus(requestId: string, status: DataSubjectRequest['fulfillmentStatus']) {\n    // Update request status in database\n  }\n\n  private async rejectRequest(requestId: string, reason: string) {\n    // Reject request with reason\n  }\n\n  private async checkErasureLegality(userId: string) {\n    // Check if data can be legally erased (e.g., no legal retention requirements)\n    return { allowed: true, reason: '' };\n  }\n\n  private async performDataErasure(userId: string, requestDetails: any) {\n    // Perform actual data erasure across all systems\n  }\n\n  private async collectPortableData(userId: string) {\n    // Collect data that should be portable under GDPR\n    return {};\n  }\n\n  private async generateStructuredExport(data: any, format: string) {\n    // Generate structured data export in requested format\n    return {};\n  }\n\n  private async getRequestsSince(date: Date) {\n    // Get all requests since the specified date\n    return [];\n  }\n\n  private groupRequestsByType(requests: DataSubjectRequest[]) {\n    // Group requests by type for reporting\n    return {};\n  }\n\n  private async calculateAverageResponseTime(requests: DataSubjectRequest[]) {\n    // Calculate average time to fulfill requests\n    return 0;\n  }\n\n  private calculateComplianceRate(requests: DataSubjectRequest[]) {\n    // Calculate percentage of requests fulfilled within legal timeframe (30 days)\n    const completedOnTime = requests.filter(r => {\n      if (!r.completionDate) return false;\n      const daysDiff = (r.completionDate.getTime() - r.requestDate.getTime()) / (1000 * 60 * 60 * 24);\n      return daysDiff <= 30;\n    }).length;\n    \n    return requests.length > 0 ? (completedOnTime / requests.length) * 100 : 100;\n  }\n\n  private getOverdueRequests(requests: DataSubjectRequest[]) {\n    // Get requests that are overdue (> 30 days and not completed)\n    const now = new Date();\n    return requests.filter(r => {\n      if (r.fulfillmentStatus === 'COMPLETED') return false;\n      const daysDiff = (now.getTime() - r.requestDate.getTime()) / (1000 * 60 * 60 * 24);\n      return daysDiff > 30;\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"pci-dss-compliance-automation",children:"PCI DSS Compliance Automation"}),"\n",(0,i.jsx)(n.h3,{id:"1-card-data-discovery--protection",children:"1. Card Data Discovery & Protection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/compliance/pci/card-data-protection.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\n@Injectable()\nexport class CardDataProtectionService {\n  private readonly logger = new Logger(CardDataProtectionService.name);\n  \n  private readonly cardDataPatterns = [\n    /\\b4[0-9]{12}(?:[0-9]{3})?\\b/, // Visa\n    /\\b5[1-5][0-9]{14}\\b/, // MasterCard\n    /\\b3[47][0-9]{13}\\b/, // American Express\n    /\\b3[0-9]{4}[\\s\\-]?[0-9]{6}[\\s\\-]?[0-9]{5}\\b/, // Diners Club\n    /\\b6(?:011|5[0-9]{2})[0-9]{12}\\b/ // Discover\n  ];\n\n  async scanForCardData(text: string): Promise<{ found: boolean; violations: string[] }> {\n    const violations: string[] = [];\n    \n    for (const pattern of this.cardDataPatterns) {\n      const matches = text.match(pattern);\n      if (matches) {\n        violations.push(`Potential card data found: ${this.maskCardNumber(matches[0])}`);\n      }\n    }\n\n    if (violations.length > 0) {\n      await this.reportPCIViolation('CARD_DATA_EXPOSURE', violations);\n    }\n\n    return {\n      found: violations.length > 0,\n      violations\n    };\n  }\n\n  async enforceDataRetentionPolicies(): Promise<void> {\n    // PCI DSS Requirement 3.1: Keep cardholder data storage to a minimum\n    const retentionPolicies = [\n      { dataType: 'CARDHOLDER_DATA', maxRetentionDays: 365 },\n      { dataType: 'SENSITIVE_AUTH_DATA', maxRetentionDays: 0 }, // Should not be stored\n      { dataType: 'TRANSACTION_LOGS', maxRetentionDays: 365 * 3 } // 3 years\n    ];\n\n    for (const policy of retentionPolicies) {\n      await this.enforceRetentionPolicy(policy);\n    }\n  }\n\n  async validateEncryptionCompliance(): Promise<{ compliant: boolean; issues: string[] }> {\n    const issues: string[] = [];\n    \n    // Check encryption at rest\n    const encryptionAtRest = await this.checkEncryptionAtRest();\n    if (!encryptionAtRest.compliant) {\n      issues.push(...encryptionAtRest.issues);\n    }\n\n    // Check encryption in transit\n    const encryptionInTransit = await this.checkEncryptionInTransit();\n    if (!encryptionInTransit.compliant) {\n      issues.push(...encryptionInTransit.issues);\n    }\n\n    // Check key management\n    const keyManagement = await this.checkKeyManagement();\n    if (!keyManagement.compliant) {\n      issues.push(...keyManagement.issues);\n    }\n\n    return {\n      compliant: issues.length === 0,\n      issues\n    };\n  }\n\n  private maskCardNumber(cardNumber: string): string {\n    // Show only last 4 digits\n    return `****-****-****-${cardNumber.slice(-4)}`;\n  }\n\n  private async reportPCIViolation(violationType: string, details: string[]) {\n    // Report PCI DSS violation to security team\n    this.logger.error(`PCI DSS Violation: ${violationType}`, details);\n  }\n\n  private async enforceRetentionPolicy(policy: any) {\n    // Implement data retention policy enforcement\n  }\n\n  private async checkEncryptionAtRest() {\n    // Verify that cardholder data is encrypted at rest\n    return { compliant: true, issues: [] };\n  }\n\n  private async checkEncryptionInTransit() {\n    // Verify that cardholder data is encrypted in transit\n    return { compliant: true, issues: [] };\n  }\n\n  private async checkKeyManagement() {\n    // Verify proper key management practices\n    return { compliant: true, issues: [] };\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-access-control-monitoring",children:"2. Access Control Monitoring"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/compliance/pci/access-control.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\n@Injectable()\nexport class PCIAccessControlService {\n  private readonly logger = new Logger(PCIAccessControlService.name);\n\n  async monitorCardholderDataAccess(userId: string, resource: string, action: string) {\n    // PCI DSS Requirement 7: Restrict access to cardholder data by business need to know\n    \n    const accessDecision = await this.evaluateAccess(userId, resource, action);\n    \n    // Log all access attempts\n    await this.logAccessAttempt({\n      userId,\n      resource,\n      action,\n      allowed: accessDecision.allowed,\n      reason: accessDecision.reason,\n      timestamp: new Date(),\n      riskLevel: this.calculateRiskLevel(userId, resource, action)\n    });\n\n    if (!accessDecision.allowed) {\n      await this.reportAccessViolation(userId, resource, action, accessDecision.reason);\n    }\n\n    return accessDecision;\n  }\n\n  async enforcePasswordPolicy(userId: string, password: string): Promise<{ compliant: boolean; violations: string[] }> {\n    // PCI DSS Requirement 8.2: Password requirements\n    const violations: string[] = [];\n    \n    if (password.length < 8) {\n      violations.push('Password must be at least 8 characters long');\n    }\n    \n    if (!/[A-Z]/.test(password)) {\n      violations.push('Password must contain uppercase letters');\n    }\n    \n    if (!/[a-z]/.test(password)) {\n      violations.push('Password must contain lowercase letters');\n    }\n    \n    if (!/[0-9]/.test(password)) {\n      violations.push('Password must contain numbers');\n    }\n    \n    if (!/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password)) {\n      violations.push('Password must contain special characters');\n    }\n\n    // Check against password history\n    const isReused = await this.checkPasswordHistory(userId, password);\n    if (isReused) {\n      violations.push('Password cannot be the same as any of the last 4 passwords');\n    }\n\n    return {\n      compliant: violations.length === 0,\n      violations\n    };\n  }\n\n  async monitorPrivilegedAccess(): Promise<void> {\n    // PCI DSS Requirement 8.5: Monitor privileged access\n    const privilegedUsers = await this.getPrivilegedUsers();\n    \n    for (const user of privilegedUsers) {\n      const recentActivity = await this.getRecentActivity(user.id);\n      \n      // Check for unusual activity patterns\n      const anomalies = await this.detectAccessAnomalies(user.id, recentActivity);\n      \n      if (anomalies.length > 0) {\n        await this.reportPrivilegedAccessAnomaly(user.id, anomalies);\n      }\n    }\n  }\n\n  private async evaluateAccess(userId: string, resource: string, action: string) {\n    // Implement business need-to-know access evaluation\n    const userRoles = await this.getUserRoles(userId);\n    const requiredPermissions = await this.getRequiredPermissions(resource, action);\n    \n    const hasAccess = userRoles.some(role => \n      requiredPermissions.some(permission => role.permissions.includes(permission))\n    );\n\n    return {\n      allowed: hasAccess,\n      reason: hasAccess ? 'Access granted based on role permissions' : 'Insufficient permissions'\n    };\n  }\n\n  private calculateRiskLevel(userId: string, resource: string, action: string): 'LOW' | 'MEDIUM' | 'HIGH' {\n    // Calculate risk level based on user, resource, and action\n    if (resource.includes('cardholder') && action === 'export') {\n      return 'HIGH';\n    }\n    if (resource.includes('payment') && action === 'modify') {\n      return 'MEDIUM';\n    }\n    return 'LOW';\n  }\n\n  private async logAccessAttempt(accessLog: any) {\n    // Log access attempt for audit trail\n  }\n\n  private async reportAccessViolation(userId: string, resource: string, action: string, reason: string) {\n    // Report access violation to security team\n  }\n\n  private async checkPasswordHistory(userId: string, password: string): Promise<boolean> {\n    // Check if password was used in the last 4 passwords\n    return false;\n  }\n\n  private async getPrivilegedUsers() {\n    // Get list of users with privileged access\n    return [];\n  }\n\n  private async getRecentActivity(userId: string) {\n    // Get recent activity for user\n    return [];\n  }\n\n  private async detectAccessAnomalies(userId: string, activity: any[]) {\n    // Detect unusual access patterns\n    return [];\n  }\n\n  private async reportPrivilegedAccessAnomaly(userId: string, anomalies: any[]) {\n    // Report privileged access anomaly\n  }\n\n  private async getUserRoles(userId: string) {\n    // Get user roles and permissions\n    return [];\n  }\n\n  private async getRequiredPermissions(resource: string, action: string) {\n    // Get required permissions for resource and action\n    return [];\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"automated-policy-enforcement",children:"Automated Policy Enforcement"}),"\n",(0,i.jsx)(n.h3,{id:"1-policy-engine-service",children:"1. Policy Engine Service"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/compliance/policy-engine.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\ninterface CompliancePolicy {\n  id: string;\n  name: string;\n  framework: 'GDPR' | 'PCI_DSS' | 'HIPAA' | 'SOC2';\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  condition: string; // OPA Rego policy\n  action: 'ALLOW' | 'DENY' | 'WARN' | 'AUDIT';\n  remediation?: string;\n  enabled: boolean;\n}\n\n@Injectable()\nexport class PolicyEngineService {\n  private readonly logger = new Logger(PolicyEngineService.name);\n  private policies: CompliancePolicy[] = [];\n\n  async loadPolicies(): Promise<void> {\n    // Load compliance policies from configuration\n    this.policies = [\n      {\n        id: 'gdpr-consent-required',\n        name: 'GDPR Consent Required for Data Processing',\n        framework: 'GDPR',\n        severity: 'HIGH',\n        condition: 'data.processing_purpose != null and data.consent_status != \"given\"',\n        action: 'DENY',\n        remediation: 'Obtain explicit consent before processing personal data',\n        enabled: true\n      },\n      {\n        id: 'pci-card-data-access',\n        name: 'PCI Restrict Card Data Access',\n        framework: 'PCI_DSS',\n        severity: 'CRITICAL',\n        condition: 'resource.type == \"cardholder_data\" and user.business_justification == null',\n        action: 'DENY',\n        remediation: 'Provide business justification for cardholder data access',\n        enabled: true\n      },\n      {\n        id: 'hipaa-phi-access',\n        name: 'HIPAA Restrict PHI Access',\n        framework: 'HIPAA',\n        severity: 'HIGH',\n        condition: 'resource.type == \"phi\" and user.minimum_necessary_determination == null',\n        action: 'DENY',\n        remediation: 'Document minimum necessary determination for PHI access',\n        enabled: true\n      }\n    ];\n  }\n\n  async evaluatePolicy(policyId: string, context: any): Promise<{ allowed: boolean; violations: string[] }> {\n    const policy = this.policies.find(p => p.id === policyId);\n    \n    if (!policy || !policy.enabled) {\n      return { allowed: true, violations: [] };\n    }\n\n    const violations: string[] = [];\n    const allowed = await this.evaluateCondition(policy.condition, context);\n\n    if (!allowed) {\n      violations.push(`Policy violation: ${policy.name}`);\n      \n      // Execute policy action\n      await this.executePolicyAction(policy, context);\n    }\n\n    return { allowed, violations };\n  }\n\n  async evaluateAllPolicies(context: any): Promise<{ allowed: boolean; violations: string[] }> {\n    const allViolations: string[] = [];\n    let overallAllowed = true;\n\n    for (const policy of this.policies.filter(p => p.enabled)) {\n      const result = await this.evaluatePolicy(policy.id, context);\n      \n      if (!result.allowed) {\n        allViolations.push(...result.violations);\n        \n        if (policy.action === 'DENY') {\n          overallAllowed = false;\n        }\n      }\n    }\n\n    return {\n      allowed: overallAllowed,\n      violations: allViolations\n    };\n  }\n\n  async generatePolicyReport(): Promise<any> {\n    const now = new Date();\n    const last30Days = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    \n    const violations = await this.getPolicyViolations(last30Days, now);\n    \n    return {\n      totalViolations: violations.length,\n      violationsByFramework: this.groupViolationsByFramework(violations),\n      violationsBySeverity: this.groupViolationsBySeverity(violations),\n      topViolatedPolicies: this.getTopViolatedPolicies(violations),\n      remediationStatus: await this.getRemediationStatus(violations)\n    };\n  }\n\n  private async evaluateCondition(condition: string, context: any): Promise<boolean> {\n    // Use OPA (Open Policy Agent) or similar policy engine to evaluate condition\n    // For simplicity, this is a basic implementation\n    try {\n      // This would integrate with OPA or implement a simple expression evaluator\n      return this.basicConditionEvaluator(condition, context);\n    } catch (error) {\n      this.logger.error(`Error evaluating policy condition: ${condition}`, error);\n      return false; // Fail closed\n    }\n  }\n\n  private basicConditionEvaluator(condition: string, context: any): boolean {\n    // Basic condition evaluator (in production, use OPA or similar)\n    // This is a simplified implementation for demonstration\n    return true;\n  }\n\n  private async executePolicyAction(policy: CompliancePolicy, context: any) {\n    switch (policy.action) {\n      case 'DENY':\n        await this.logPolicyViolation(policy, context, 'ACCESS_DENIED');\n        break;\n      case 'WARN':\n        await this.logPolicyViolation(policy, context, 'WARNING_ISSUED');\n        break;\n      case 'AUDIT':\n        await this.logPolicyViolation(policy, context, 'AUDIT_LOGGED');\n        break;\n    }\n  }\n\n  private async logPolicyViolation(policy: CompliancePolicy, context: any, actionTaken: string) {\n    // Log policy violation for compliance reporting\n    this.logger.warn(`Policy violation: ${policy.name}`, {\n      policyId: policy.id,\n      framework: policy.framework,\n      severity: policy.severity,\n      context,\n      actionTaken,\n      timestamp: new Date()\n    });\n  }\n\n  private async getPolicyViolations(startDate: Date, endDate: Date) {\n    // Get policy violations from audit logs\n    return [];\n  }\n\n  private groupViolationsByFramework(violations: any[]) {\n    // Group violations by compliance framework\n    return {};\n  }\n\n  private groupViolationsBySeverity(violations: any[]) {\n    // Group violations by severity level\n    return {};\n  }\n\n  private getTopViolatedPolicies(violations: any[]) {\n    // Get most frequently violated policies\n    return [];\n  }\n\n  private async getRemediationStatus(violations: any[]) {\n    // Get remediation status for violations\n    return {};\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"compliance-reporting--dashboards",children:"Compliance Reporting & Dashboards"}),"\n",(0,i.jsx)(n.h3,{id:"1-automated-compliance-reporting",children:"1. Automated Compliance Reporting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/compliance/reporting.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\n@Injectable()\nexport class ComplianceReportingService {\n  private readonly logger = new Logger(ComplianceReportingService.name);\n\n  async generateComplianceReport(\n    framework: 'GDPR' | 'PCI_DSS' | 'HIPAA' | 'SOC2',\n    reportType: 'MONTHLY' | 'QUARTERLY' | 'ANNUAL' | 'AUDIT',\n    startDate: Date,\n    endDate: Date\n  ): Promise<any> {\n    \n    switch (framework) {\n      case 'GDPR':\n        return await this.generateGDPRReport(reportType, startDate, endDate);\n      case 'PCI_DSS':\n        return await this.generatePCIReport(reportType, startDate, endDate);\n      case 'HIPAA':\n        return await this.generateHIPAAReport(reportType, startDate, endDate);\n      case 'SOC2':\n        return await this.generateSOC2Report(reportType, startDate, endDate);\n      default:\n        throw new Error(`Unsupported compliance framework: ${framework}`);\n    }\n  }\n\n  private async generateGDPRReport(reportType: string, startDate: Date, endDate: Date) {\n    return {\n      framework: 'GDPR',\n      reportType,\n      period: { startDate, endDate },\n      summary: {\n        dataSubjectRequests: await this.getDataSubjectRequestsMetrics(startDate, endDate),\n        consentManagement: await this.getConsentMetrics(startDate, endDate),\n        dataBreaches: await this.getDataBreachMetrics(startDate, endDate),\n        dataProcessingActivities: await this.getDataProcessingMetrics(startDate, endDate)\n      },\n      complianceScore: await this.calculateGDPRComplianceScore(),\n      recommendations: await this.generateGDPRRecommendations()\n    };\n  }\n\n  private async generatePCIReport(reportType: string, startDate: Date, endDate: Date) {\n    return {\n      framework: 'PCI_DSS',\n      reportType,\n      period: { startDate, endDate },\n      summary: {\n        cardholderDataAccess: await this.getCardholderDataAccessMetrics(startDate, endDate),\n        vulnerabilityScans: await this.getVulnerabilityMetrics(startDate, endDate),\n        accessControlViolations: await this.getAccessControlMetrics(startDate, endDate),\n        networkSecurity: await this.getNetworkSecurityMetrics(startDate, endDate)\n      },\n      complianceScore: await this.calculatePCIComplianceScore(),\n      recommendations: await this.generatePCIRecommendations()\n    };\n  }\n\n  async scheduleAutomaticReports(): Promise<void> {\n    // Schedule automatic compliance reports\n    const reportSchedules = [\n      { framework: 'GDPR', frequency: 'MONTHLY', recipients: ['dpo@company.com'] },\n      { framework: 'PCI_DSS', frequency: 'QUARTERLY', recipients: ['security@company.com'] },\n      { framework: 'HIPAA', frequency: 'MONTHLY', recipients: ['privacy@company.com'] },\n      { framework: 'SOC2', frequency: 'QUARTERLY', recipients: ['audit@company.com'] }\n    ];\n\n    for (const schedule of reportSchedules) {\n      await this.scheduleReport(schedule);\n    }\n  }\n\n  private async getDataSubjectRequestsMetrics(startDate: Date, endDate: Date) {\n    // Get data subject request metrics for GDPR reporting\n    return {};\n  }\n\n  private async getConsentMetrics(startDate: Date, endDate: Date) {\n    // Get consent management metrics\n    return {};\n  }\n\n  private async getDataBreachMetrics(startDate: Date, endDate: Date) {\n    // Get data breach metrics\n    return {};\n  }\n\n  private async getDataProcessingMetrics(startDate: Date, endDate: Date) {\n    // Get data processing activity metrics\n    return {};\n  }\n\n  private async calculateGDPRComplianceScore() {\n    // Calculate overall GDPR compliance score\n    return 85; // Example score\n  }\n\n  private async generateGDPRRecommendations() {\n    // Generate GDPR compliance recommendations\n    return [];\n  }\n\n  private async getCardholderDataAccessMetrics(startDate: Date, endDate: Date) {\n    // Get cardholder data access metrics\n    return {};\n  }\n\n  private async getVulnerabilityMetrics(startDate: Date, endDate: Date) {\n    // Get vulnerability scan metrics\n    return {};\n  }\n\n  private async getAccessControlMetrics(startDate: Date, endDate: Date) {\n    // Get access control metrics\n    return {};\n  }\n\n  private async getNetworkSecurityMetrics(startDate: Date, endDate: Date) {\n    // Get network security metrics\n    return {};\n  }\n\n  private async calculatePCIComplianceScore() {\n    // Calculate PCI DSS compliance score\n    return 92; // Example score\n  }\n\n  private async generatePCIRecommendations() {\n    // Generate PCI DSS recommendations\n    return [];\n  }\n\n  private async generateHIPAAReport(reportType: string, startDate: Date, endDate: Date) {\n    // Generate HIPAA compliance report\n    return {};\n  }\n\n  private async generateSOC2Report(reportType: string, startDate: Date, endDate: Date) {\n    // Generate SOC 2 compliance report\n    return {};\n  }\n\n  private async scheduleReport(schedule: any) {\n    // Schedule automatic report generation\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-implementation-guidelines",children:"1. Implementation Guidelines"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Risk-Based Approach"}),": Prioritize compliance controls based on risk assessment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automation First"}),": Automate compliance checks and reporting wherever possible"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Continuous Monitoring"}),": Implement real-time compliance monitoring and alerting"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Evidence Collection"}),": Automatically collect and preserve compliance evidence"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-data-management",children:"2. Data Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Classification"}),": Implement automated data discovery and classification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Retention Policies"}),": Enforce automated data retention and deletion policies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Access Controls"}),": Implement least-privilege access with automated reviews"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Audit Trails"}),": Maintain comprehensive, tamper-proof audit trails"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-privacy-by-design",children:"3. Privacy by Design"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Default Privacy"}),": Implement privacy-friendly defaults in all systems"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Minimization"}),": Collect and process only necessary data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consent Management"}),": Implement granular, auditable consent management"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transparency"}),": Provide clear, accessible privacy information to users"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-security-integration",children:"4. Security Integration"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Defense in Depth"}),": Layer security controls throughout the system"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Incident Response"}),": Integrate compliance requirements into incident response"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Vulnerability Management"}),": Regular security assessments and remediation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Encryption"}),": Implement strong encryption for data at rest and in transit"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-guides",children:"Related Guides"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/security-practices/security-implementation/security-monitoring",children:"Security Monitoring Implementation Guide"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/security-practices/security-implementation/incident-management",children:"Incident Management Guide"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/security-practices/security-implementation/pii-protection",children:"PII Protection Guide"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/security-practices/security-implementation/sensitive-data-protection",children:"Sensitive Data Protection Guide"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},7814:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(9729);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);