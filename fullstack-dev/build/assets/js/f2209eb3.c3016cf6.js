"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[5714],{574:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>g,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var o=t(8477),r=t(5813),i=t(5741);const a={slug:"geo-targeting-implementation-nodejs-react",title:"Building Smart Location-Aware Applications: Complete Geo-targeting Implementation with Node.js and React",authors:["tam"],tags:["geo-targeting","geolocation","nodejs","nestjs","react","nextjs","ip-geolocation","location-based-services","personalization"]},s=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Why Geo-targeting Matters",id:"why-geo-targeting-matters",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Step 1: Backend Implementation with NestJS",id:"step-1-backend-implementation-with-nestjs",level:2},{value:"Geo-targeting Service",id:"geo-targeting-service",level:3},{value:"Geo-targeting Middleware",id:"geo-targeting-middleware",level:3},{value:"Geo-targeting Controller",id:"geo-targeting-controller",level:3},{value:"Parameter Decorator",id:"parameter-decorator",level:3},{value:"Step 2: Frontend Implementation with React",id:"step-2-frontend-implementation-with-react",level:2},{value:"Geolocation Hook",id:"geolocation-hook",level:3},{value:"Geo-targeted Components",id:"geo-targeted-components",level:3},{value:"Currency Display Component",id:"currency-display-component",level:4},{value:"Location Restriction Component",id:"location-restriction-component",level:4},{value:"Geo-targeted Pricing Component",id:"geo-targeted-pricing-component",level:4},{value:"Step 3: Advanced Features Implementation",id:"step-3-advanced-features-implementation",level:2},{value:"Location-based A/B Testing",id:"location-based-ab-testing",level:3},{value:"Geo-fencing Implementation",id:"geo-fencing-implementation",level:3},{value:"Step 4: Privacy and Compliance",id:"step-4-privacy-and-compliance",level:2},{value:"GDPR Compliance Implementation",id:"gdpr-compliance-implementation",level:3},{value:"Privacy-aware Frontend Component",id:"privacy-aware-frontend-component",level:3},{value:"Step 5: Performance Optimization",id:"step-5-performance-optimization",level:2},{value:"Caching Strategy with Redis",id:"caching-strategy-with-redis",level:3},{value:"Step 6: Testing Your Implementation",id:"step-6-testing-your-implementation",level:2},{value:"Unit Tests for Geo-targeting Service",id:"unit-tests-for-geo-targeting-service",level:3},{value:"React Testing Library Tests",id:"react-testing-library-tests",level:3},{value:"Production Deployment Considerations",id:"production-deployment-considerations",level:2},{value:"Environment Configuration",id:"environment-configuration",level:3},{value:"CDN Integration",id:"cdn-integration",level:3},{value:"Best Practices and Security",id:"best-practices-and-security",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Modern applications need to deliver personalized experiences based on user location. Whether you're implementing regional pricing, content localization, compliance restrictions, or location-based features, geo-targeting is essential for creating relevant user experiences."}),"\n",(0,r.jsx)(n.p,{children:"This comprehensive guide demonstrates how to implement robust geo-targeting functionality in a Node.js/NestJS backend with React/Next.js frontend, covering everything from basic location detection to advanced geo-fencing and privacy compliance."}),"\n",(0,r.jsx)(n.h2,{id:"why-geo-targeting-matters",children:"Why Geo-targeting Matters"}),"\n",(0,r.jsx)(n.p,{children:"Geo-targeting enables applications to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Personalize Content"}),": Show relevant information based on location"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement Regional Pricing"}),": Different pricing for different markets"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ensure Compliance"}),": GDPR, data residency, and regional regulations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimize Performance"}),": Route users to nearest servers/CDN"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enhance Security"}),": Detect suspicious location changes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Improve Conversions"}),": Location-specific offers and content"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsx)(n.p,{children:"Our geo-targeting system consists of multiple layers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[User Request] --\x3e B[CDN/Load Balancer]\n    B --\x3e C[Geo Detection Middleware]\n    C --\x3e D[Location Cache]\n    C --\x3e E[IP Geolocation APIs]\n    C --\x3e F[Browser Geolocation]\n    \n    G[Geo Context Service] --\x3e H[Database Rules]\n    G --\x3e I[Content Personalization]\n    G --\x3e J[Restriction Checking]\n    \n    C --\x3e G\n    I --\x3e K[Cached Response]\n    K --\x3e L[User Experience]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"step-1-backend-implementation-with-nestjs",children:"Step 1: Backend Implementation with NestJS"}),"\n",(0,r.jsx)(n.h3,{id:"geo-targeting-service",children:"Geo-targeting Service"}),"\n",(0,r.jsx)(n.p,{children:"Let's start with a comprehensive geolocation service that handles multiple detection methods:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/geotargeting/geotargeting.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Request } from 'express';\nimport geoip from 'geoip-lite';\n\nexport interface LocationInfo {\n  ip: string;\n  country: string;\n  countryCode: string;\n  region: string;\n  city: string;\n  latitude: number;\n  longitude: number;\n  timezone: string;\n  accuracy: 'high' | 'medium' | 'low';\n  source: 'browser' | 'ip' | 'header' | 'default';\n}\n\n@Injectable()\nexport class GeotargetingService {\n  private readonly logger = new Logger(GeotargetingService.name);\n\n  constructor(private configService: ConfigService) {}\n\n  async detectLocationFromRequest(request: Request): Promise<LocationInfo> {\n    const ip = this.extractIP(request);\n    \n    // Try CDN headers first (most accurate)\n    const headerLocation = this.getLocationFromHeaders(request);\n    if (headerLocation) {\n      return {\n        ...headerLocation,\n        ip,\n        accuracy: 'high',\n        source: 'header',\n      };\n    }\n\n    // Fallback to IP geolocation\n    const geoData = geoip.lookup(ip);\n    if (geoData) {\n      return {\n        ip,\n        country: geoData.country,\n        countryCode: geoData.country,\n        region: geoData.region,\n        city: geoData.city,\n        latitude: geoData.ll[0],\n        longitude: geoData.ll[1],\n        timezone: geoData.timezone,\n        accuracy: 'medium',\n        source: 'ip',\n      };\n    }\n\n    return this.getDefaultLocation(ip);\n  }\n\n  private extractIP(request: Request): string {\n    const forwarded = request.headers['x-forwarded-for'] as string;\n    const realIP = request.headers['x-real-ip'] as string;\n    \n    if (forwarded) {\n      return forwarded.split(',')[0].trim();\n    }\n    \n    return realIP || request.connection?.remoteAddress || '127.0.0.1';\n  }\n\n  private getLocationFromHeaders(request: Request): Partial<LocationInfo> | null {\n    // Cloudflare headers\n    const cfCountry = request.headers['cf-ipcountry'] as string;\n    const cfRegion = request.headers['cf-region'] as string;\n    const cfCity = request.headers['cf-city'] as string;\n\n    if (cfCountry && cfCountry !== 'XX') {\n      return {\n        country: cfCountry,\n        countryCode: cfCountry,\n        region: cfRegion || '',\n        city: cfCity || '',\n        latitude: 0,\n        longitude: 0,\n        timezone: '',\n      };\n    }\n\n    return null;\n  }\n\n  getGeoContent(location: LocationInfo): any {\n    return {\n      currency: this.getCurrencyForCountry(location.countryCode),\n      language: this.getLanguageForCountry(location.countryCode),\n      timezone: location.timezone,\n      pricing: this.getPricingTier(location.countryCode),\n    };\n  }\n\n  private getCurrencyForCountry(countryCode: string): string {\n    const currencyMap: Record<string, string> = {\n      'US': 'USD', 'GB': 'GBP', 'DE': 'EUR', 'FR': 'EUR',\n      'JP': 'JPY', 'CA': 'CAD', 'AU': 'AUD', 'IN': 'INR',\n    };\n    return currencyMap[countryCode] || 'USD';\n  }\n\n  private getLanguageForCountry(countryCode: string): string {\n    const languageMap: Record<string, string> = {\n      'US': 'en', 'GB': 'en', 'DE': 'de', 'FR': 'fr',\n      'ES': 'es', 'JP': 'ja', 'CN': 'zh', 'IN': 'en',\n    };\n    return languageMap[countryCode] || 'en';\n  }\n\n  private getPricingTier(countryCode: string): string {\n    const developedCountries = ['US', 'GB', 'DE', 'FR', 'CA', 'AU', 'JP'];\n    const emergingMarkets = ['IN', 'BR', 'MX', 'TH', 'PL'];\n    \n    if (developedCountries.includes(countryCode)) {\n      return 'premium';\n    } else if (emergingMarkets.includes(countryCode)) {\n      return 'standard';\n    }\n    return 'basic';\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"geo-targeting-middleware",children:"Geo-targeting Middleware"}),"\n",(0,r.jsx)(n.p,{children:"Create middleware to automatically detect and attach location data to requests:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/geotargeting/middleware/geo-targeting.middleware.ts\nimport { Injectable, NestMiddleware } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport { GeotargetingService } from '../geotargeting.service';\n\n@Injectable()\nexport class GeoTargetingMiddleware implements NestMiddleware {\n  constructor(private readonly geotargetingService: GeotargetingService) {}\n\n  async use(req: Request, res: Response, next: NextFunction) {\n    try {\n      const location = await this.geotargetingService.detectLocationFromRequest(req);\n      const geoContent = this.geotargetingService.getGeoContent(location);\n      \n      req['geoLocation'] = location;\n      req['geoContent'] = geoContent;\n      \n      // Set response headers for client-side access\n      res.setHeader('X-User-Country', location.countryCode);\n      res.setHeader('X-User-Currency', geoContent.currency);\n      res.setHeader('X-User-Language', geoContent.language);\n      \n      next();\n    } catch (error) {\n      console.error('Geo-targeting middleware error:', error);\n      next(); // Continue without geo-targeting\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"geo-targeting-controller",children:"Geo-targeting Controller"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/geotargeting/geotargeting.controller.ts\nimport { Controller, Get, Post, Body, Param, UseGuards } from '@nestjs/common';\nimport { ApiTags, ApiOperation } from '@nestjs/swagger';\nimport { GeotargetingService, LocationInfo } from './geotargeting.service';\nimport { GeoLocation } from './decorators/geo-targeting.decorator';\n\n@ApiTags('Geo-targeting')\n@Controller('api/geo')\nexport class GeotargetingController {\n  constructor(private readonly geotargetingService: GeotargetingService) {}\n\n  @Get('location')\n  @ApiOperation({ summary: 'Get current user location' })\n  async getCurrentLocation(@GeoLocation() location: LocationInfo) {\n    return {\n      success: true,\n      data: location,\n    };\n  }\n\n  @Get('content')\n  @ApiOperation({ summary: 'Get geo-specific content' })\n  async getGeoContent(@GeoLocation() location: LocationInfo) {\n    const content = this.geotargetingService.getGeoContent(location);\n    return {\n      success: true,\n      data: content,\n    };\n  }\n\n  @Get('pricing/:product')\n  @ApiOperation({ summary: 'Get geo-specific pricing' })\n  async getGeoPricing(\n    @Param('product') product: string,\n    @GeoLocation() location: LocationInfo\n  ) {\n    const pricing = await this.geotargetingService.getGeoPricing(\n      product,\n      location.countryCode\n    );\n    return {\n      success: true,\n      data: pricing,\n    };\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"parameter-decorator",children:"Parameter Decorator"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/geotargeting/decorators/geo-targeting.decorator.ts\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const GeoLocation = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return request['geoLocation'];\n  },\n);\n\nexport const GeoContent = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return request['geoContent'];\n  },\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"step-2-frontend-implementation-with-react",children:"Step 2: Frontend Implementation with React"}),"\n",(0,r.jsx)(n.h3,{id:"geolocation-hook",children:"Geolocation Hook"}),"\n",(0,r.jsx)(n.p,{children:"Create a comprehensive React hook for handling geolocation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// hooks/useGeoTargeting.ts\nimport { useState, useEffect, useCallback } from 'react';\n\nexport interface GeoTargetingData {\n  location: {\n    latitude?: number;\n    longitude?: number;\n    country?: string;\n    countryCode?: string;\n    region?: string;\n    city?: string;\n  } | null;\n  content: {\n    currency: string;\n    language: string;\n    pricing: string;\n  };\n  loading: boolean;\n  error: string | null;\n}\n\nexport const useGeoTargeting = () => {\n  const [geoData, setGeoData] = useState<GeoTargetingData>({\n    location: null,\n    content: {\n      currency: 'USD',\n      language: 'en',\n      pricing: 'standard',\n    },\n    loading: true,\n    error: null,\n  });\n\n  const fetchGeoData = useCallback(async () => {\n    try {\n      setGeoData(prev => ({ ...prev, loading: true, error: null }));\n\n      // Try browser geolocation first\n      let browserLocation = null;\n      try {\n        browserLocation = await getCurrentPosition();\n      } catch (error) {\n        console.warn('Browser geolocation failed:', error);\n      }\n\n      // Get server-side geo data\n      const response = await fetch('/api/geo/content');\n      const result = await response.json();\n\n      if (!response.ok) {\n        throw new Error(result.message || 'Failed to fetch geo data');\n      }\n\n      setGeoData({\n        location: {\n          ...result.data.location,\n          ...(browserLocation && {\n            latitude: browserLocation.latitude,\n            longitude: browserLocation.longitude,\n          }),\n        },\n        content: result.data.content,\n        loading: false,\n        error: null,\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setGeoData(prev => ({\n        ...prev,\n        loading: false,\n        error: errorMessage,\n      }));\n    }\n  }, []);\n\n  const getCurrentPosition = (): Promise<{ latitude: number; longitude: number }> => {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported'));\n        return;\n      }\n\n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          resolve({\n            latitude: position.coords.latitude,\n            longitude: position.coords.longitude,\n          });\n        },\n        (error) => {\n          reject(error);\n        },\n        {\n          enableHighAccuracy: true,\n          timeout: 10000,\n          maximumAge: 300000, // 5 minutes\n        }\n      );\n    });\n  };\n\n  useEffect(() => {\n    fetchGeoData();\n  }, [fetchGeoData]);\n\n  return {\n    ...geoData,\n    refresh: fetchGeoData,\n  };\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"geo-targeted-components",children:"Geo-targeted Components"}),"\n",(0,r.jsx)(n.h4,{id:"currency-display-component",children:"Currency Display Component"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// components/CurrencyDisplay.tsx\nimport React from 'react';\nimport { useGeoTargeting } from '../hooks/useGeoTargeting';\n\ninterface CurrencyDisplayProps {\n  amount: number;\n  className?: string;\n}\n\nconst CURRENCY_RATES: Record<string, number> = {\n  USD: 1,     EUR: 0.85,   GBP: 0.73,   JPY: 110,\n  CAD: 1.25,  AUD: 1.35,   INR: 74,     CNY: 6.45,\n};\n\nconst formatCurrency = (amount: number, currency: string): string => {\n  const convertedAmount = amount * (CURRENCY_RATES[currency] || 1);\n  \n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: currency,\n    minimumFractionDigits: currency === 'JPY' ? 0 : 2,\n  }).format(convertedAmount);\n};\n\nexport const CurrencyDisplay: React.FC<CurrencyDisplayProps> = ({\n  amount,\n  className = '',\n}) => {\n  const { content, loading } = useGeoTargeting();\n\n  if (loading) {\n    return <span className={`animate-pulse ${className}`}>$--</span>;\n  }\n\n  return (\n    <span className={className}>\n      {formatCurrency(amount, content.currency)}\n    </span>\n  );\n};\n"})}),"\n",(0,r.jsx)(n.h4,{id:"location-restriction-component",children:"Location Restriction Component"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// components/LocationRestriction.tsx\nimport React from \'react\';\nimport { useGeoTargeting } from \'../hooks/useGeoTargeting\';\n\ninterface LocationRestrictionProps {\n  children: React.ReactNode;\n  allowedCountries?: string[];\n  blockedCountries?: string[];\n  fallback?: React.ReactNode;\n  showMessage?: boolean;\n}\n\nexport const LocationRestriction: React.FC<LocationRestrictionProps> = ({\n  children,\n  allowedCountries,\n  blockedCountries,\n  fallback,\n  showMessage = true,\n}) => {\n  const { location, loading, error } = useGeoTargeting();\n\n  if (loading) {\n    return (\n      <div className="flex items-center justify-center p-4">\n        <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>\n        <span className="ml-2">Checking location...</span>\n      </div>\n    );\n  }\n\n  if (error || !location?.countryCode) {\n    return fallback || <>{children}</>;\n  }\n\n  const isAllowed = !allowedCountries || allowedCountries.includes(location.countryCode);\n  const isBlocked = blockedCountries && blockedCountries.includes(location.countryCode);\n\n  if (!isAllowed || isBlocked) {\n    if (!showMessage) return null;\n    \n    return (\n      <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-md">\n        <p className="text-yellow-800">\n          This content is not available in your region ({location.country || location.countryCode}).\n        </p>\n      </div>\n    );\n  }\n\n  return <>{children}</>;\n};\n'})}),"\n",(0,r.jsx)(n.h4,{id:"geo-targeted-pricing-component",children:"Geo-targeted Pricing Component"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// components/GeoPricing.tsx\nimport React, { useState, useEffect } from \'react\';\nimport { useGeoTargeting } from \'../hooks/useGeoTargeting\';\nimport { CurrencyDisplay } from \'./CurrencyDisplay\';\n\ninterface GeoPricingProps {\n  productId: string;\n  basePrice: number;\n  className?: string;\n}\n\ninterface PricingData {\n  price: number;\n  discount?: number;\n  promotional?: boolean;\n  message?: string;\n}\n\nexport const GeoPricing: React.FC<GeoPricingProps> = ({\n  productId,\n  basePrice,\n  className = \'\',\n}) => {\n  const { location, content, loading } = useGeoTargeting();\n  const [pricing, setPricing] = useState<PricingData>({ price: basePrice });\n\n  useEffect(() => {\n    if (!loading && location?.countryCode) {\n      fetchGeoPricing();\n    }\n  }, [location, loading]);\n\n  const fetchGeoPricing = async () => {\n    try {\n      const response = await fetch(`/api/geo/pricing/${productId}`);\n      const result = await response.json();\n      \n      if (result.success) {\n        setPricing(result.data);\n      }\n    } catch (error) {\n      console.error(\'Error fetching geo pricing:\', error);\n    }\n  };\n\n  if (loading) {\n    return (\n      <div className={`animate-pulse ${className}`}>\n        <div className="h-6 bg-gray-200 rounded w-20"></div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={className}>\n      <div className="flex items-center gap-2">\n        {pricing.discount && (\n          <span className="text-sm text-gray-500 line-through">\n            <CurrencyDisplay amount={basePrice} />\n          </span>\n        )}\n        <span className="text-lg font-bold">\n          <CurrencyDisplay amount={pricing.price} />\n        </span>\n        {pricing.discount && (\n          <span className="text-sm text-green-600 bg-green-100 px-2 py-1 rounded">\n            {pricing.discount}% off\n          </span>\n        )}\n      </div>\n      \n      {pricing.promotional && (\n        <p className="text-sm text-blue-600 mt-1">\n          {pricing.message || `Special pricing for ${location?.country}!`}\n        </p>\n      )}\n      \n      {content.pricing !== \'premium\' && (\n        <p className="text-xs text-gray-500 mt-1">\n          Price adjusted for your region\n        </p>\n      )}\n    </div>\n  );\n};\n'})}),"\n",(0,r.jsx)(n.h2,{id:"step-3-advanced-features-implementation",children:"Step 3: Advanced Features Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"location-based-ab-testing",children:"Location-based A/B Testing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// services/geo-ab-testing.ts\nexport interface ABTestVariant {\n  id: string;\n  name: string;\n  config: any;\n  countries?: string[];\n  regions?: string[];\n}\n\nexport class GeoABTestingService {\n  private experiments: Map<string, ABTestVariant[]> = new Map();\n\n  addExperiment(experimentId: string, variants: ABTestVariant[]): void {\n    this.experiments.set(experimentId, variants);\n  }\n\n  getVariantForLocation(\n    experimentId: string,\n    countryCode: string,\n    region?: string,\n    userId?: string\n  ): ABTestVariant | null {\n    const variants = this.experiments.get(experimentId);\n    if (!variants) return null;\n\n    // Filter variants by geo restrictions\n    const eligibleVariants = variants.filter(variant => {\n      if (variant.countries && !variant.countries.includes(countryCode)) {\n        return false;\n      }\n      if (variant.regions && region && !variant.regions.includes(region)) {\n        return false;\n      }\n      return true;\n    });\n\n    if (eligibleVariants.length === 0) return null;\n\n    // Use consistent hashing for user assignment\n    const hash = this.hashString(`${userId || 'anonymous'}-${countryCode}`);\n    const index = hash % eligibleVariants.length;\n    \n    return eligibleVariants[index];\n  }\n\n  private hashString(str: string): number {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return Math.abs(hash);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"geo-fencing-implementation",children:"Geo-fencing Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// services/geofencing.service.ts\nexport interface GeofenceArea {\n  id: string;\n  name: string;\n  center: { lat: number; lng: number };\n  radius: number; // in meters\n  triggers: GeofenceTrigger[];\n}\n\nexport interface GeofenceTrigger {\n  type: 'enter' | 'exit' | 'dwell';\n  action: string;\n  data?: any;\n}\n\nexport class GeofencingService {\n  private geofences: Map<string, GeofenceArea> = new Map();\n  private userStates: Map<string, { inside: Set<string>; lastUpdate: number }> = new Map();\n\n  addGeofence(geofence: GeofenceArea): void {\n    this.geofences.set(geofence.id, geofence);\n  }\n\n  checkGeofences(\n    userId: string,\n    latitude: number,\n    longitude: number\n  ): GeofenceTrigger[] {\n    const triggers: GeofenceTrigger[] = [];\n    const currentState = this.userStates.get(userId) || { \n      inside: new Set(), \n      lastUpdate: 0 \n    };\n    \n    const currentlyInside = new Set<string>();\n\n    for (const [id, geofence] of this.geofences) {\n      const distance = this.calculateDistance(\n        latitude,\n        longitude,\n        geofence.center.lat,\n        geofence.center.lng\n      );\n\n      const isInside = distance <= geofence.radius;\n      const wasInside = currentState.inside.has(id);\n\n      if (isInside) {\n        currentlyInside.add(id);\n      }\n\n      // Check for enter/exit events\n      if (isInside && !wasInside) {\n        triggers.push(...geofence.triggers.filter(t => t.type === 'enter'));\n      } else if (!isInside && wasInside) {\n        triggers.push(...geofence.triggers.filter(t => t.type === 'exit'));\n      } else if (isInside && wasInside) {\n        // Check for dwell events\n        const dwellTime = Date.now() - currentState.lastUpdate;\n        const dwellTriggers = geofence.triggers.filter(\n          t => t.type === 'dwell' && dwellTime >= (t.data?.minDwellTime || 0)\n        );\n        triggers.push(...dwellTriggers);\n      }\n    }\n\n    // Update user state\n    this.userStates.set(userId, {\n      inside: currentlyInside,\n      lastUpdate: Date.now(),\n    });\n\n    return triggers;\n  }\n\n  private calculateDistance(\n    lat1: number,\n    lng1: number,\n    lat2: number,\n    lng2: number\n  ): number {\n    const R = 6371e3; // Earth's radius in meters\n    const \u03c61 = (lat1 * Math.PI) / 180;\n    const \u03c62 = (lat2 * Math.PI) / 180;\n    const \u0394\u03c6 = ((lat2 - lat1) * Math.PI) / 180;\n    const \u0394\u03bb = ((lng2 - lng1) * Math.PI) / 180;\n\n    const a =\n      Math.sin(\u0394\u03c6 / 2) * Math.sin(\u0394\u03c6 / 2) +\n      Math.cos(\u03c61) * Math.cos(\u03c62) * Math.sin(\u0394\u03bb / 2) * Math.sin(\u0394\u03bb / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"step-4-privacy-and-compliance",children:"Step 4: Privacy and Compliance"}),"\n",(0,r.jsx)(n.h3,{id:"gdpr-compliance-implementation",children:"GDPR Compliance Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// services/geo-privacy.service.ts\n@Injectable()\nexport class GeoPrivacyService {\n  async checkComplianceRequirements(countryCode: string): Promise<{\n    requiresConsent: boolean;\n    dataRetentionDays: number;\n    anonymizationRequired: boolean;\n  }> {\n    const gdprCountries = [\n      'AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR',\n      'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL',\n      'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'\n    ];\n\n    const ccpaStates = ['CA']; // California\n    const isGDPR = gdprCountries.includes(countryCode);\n    const isCCPA = ccpaStates.includes(countryCode);\n\n    return {\n      requiresConsent: isGDPR || isCCPA,\n      dataRetentionDays: isGDPR ? 90 : 365,\n      anonymizationRequired: isGDPR,\n    };\n  }\n\n  anonymizeLocationData(data: any): any {\n    return {\n      ...data,\n      ip: this.anonymizeIP(data.ip),\n      latitude: this.roundCoordinate(data.latitude, 1), // Reduce precision\n      longitude: this.roundCoordinate(data.longitude, 1),\n    };\n  }\n\n  private anonymizeIP(ip: string): string {\n    const parts = ip.split('.');\n    return parts.length === 4 ? `${parts[0]}.${parts[1]}.${parts[2]}.0` : ip;\n  }\n\n  private roundCoordinate(coord: number, precision: number): number {\n    const factor = Math.pow(10, precision);\n    return Math.round(coord * factor) / factor;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"privacy-aware-frontend-component",children:"Privacy-aware Frontend Component"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// components/LocationConsent.tsx\nimport React, { useState, useEffect } from \'react\';\n\ninterface LocationConsentProps {\n  onConsent: (granted: boolean) => void;\n  requiredForFeature?: string;\n}\n\nexport const LocationConsent: React.FC<LocationConsentProps> = ({\n  onConsent,\n  requiredForFeature,\n}) => {\n  const [showConsent, setShowConsent] = useState(false);\n\n  useEffect(() => {\n    const consent = localStorage.getItem(\'geo-consent\');\n    if (!consent) {\n      setShowConsent(true);\n    } else {\n      onConsent(consent === \'granted\');\n    }\n  }, [onConsent]);\n\n  const handleConsent = (granted: boolean) => {\n    localStorage.setItem(\'geo-consent\', granted ? \'granted\' : \'denied\');\n    setShowConsent(false);\n    onConsent(granted);\n  };\n\n  if (!showConsent) return null;\n\n  return (\n    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">\n      <div className="bg-white p-6 rounded-lg max-w-md mx-4">\n        <h3 className="text-lg font-semibold mb-4">Location Access</h3>\n        <p className="text-gray-600 mb-4">\n          {requiredForFeature \n            ? `${requiredForFeature} requires access to your location to provide personalized content and pricing.`\n            : \'We use your location to provide personalized content, pricing, and comply with regional regulations.\'\n          }\n        </p>\n        <p className="text-sm text-gray-500 mb-6">\n          Your location data is processed securely and in compliance with privacy regulations.\n          You can withdraw consent at any time in your privacy settings.\n        </p>\n        <div className="flex gap-3">\n          <button\n            onClick={() => handleConsent(true)}\n            className="flex-1 bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700"\n          >\n            Allow Location Access\n          </button>\n          <button\n            onClick={() => handleConsent(false)}\n            className="flex-1 bg-gray-300 text-gray-700 py-2 px-4 rounded hover:bg-gray-400"\n          >\n            Use Default Location\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n'})}),"\n",(0,r.jsx)(n.h2,{id:"step-5-performance-optimization",children:"Step 5: Performance Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"caching-strategy-with-redis",children:"Caching Strategy with Redis"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// services/geo-cache.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { InjectRedis } from '@nestjs-modules/ioredis';\nimport { Redis } from 'ioredis';\n\n@Injectable()\nexport class GeoCacheService {\n  constructor(@InjectRedis() private readonly redis: Redis) {}\n\n  async cacheLocationData(\n    ip: string,\n    data: any,\n    ttlSeconds: number = 3600\n  ): Promise<void> {\n    const key = `geo:location:${ip}`;\n    await this.redis.setex(key, ttlSeconds, JSON.stringify(data));\n  }\n\n  async getCachedLocation(ip: string): Promise<any | null> {\n    const key = `geo:location:${ip}`;\n    const cached = await this.redis.get(key);\n    return cached ? JSON.parse(cached) : null;\n  }\n\n  async cacheGeoContent(\n    countryCode: string,\n    content: any,\n    ttlSeconds: number = 1800\n  ): Promise<void> {\n    const key = `geo:content:${countryCode}`;\n    await this.redis.setex(key, ttlSeconds, JSON.stringify(content));\n  }\n\n  async getCachedContent(countryCode: string): Promise<any | null> {\n    const key = `geo:content:${countryCode}`;\n    const cached = await this.redis.get(key);\n    return cached ? JSON.parse(cached) : null;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"step-6-testing-your-implementation",children:"Step 6: Testing Your Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"unit-tests-for-geo-targeting-service",children:"Unit Tests for Geo-targeting Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// geotargeting.service.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { GeotargetingService } from './geotargeting.service';\nimport { ConfigService } from '@nestjs/config';\n\ndescribe('GeotargetingService', () => {\n  let service: GeotargetingService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        GeotargetingService,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn(),\n          },\n        },\n      ],\n    }).compile();\n\n    service = module.get<GeotargetingService>(GeotargetingService);\n  });\n\n  describe('detectLocationFromRequest', () => {\n    it('should detect location from Cloudflare headers', async () => {\n      const mockRequest = {\n        headers: {\n          'cf-ipcountry': 'US',\n          'cf-region': 'CA',\n          'cf-city': 'San Francisco',\n          'x-forwarded-for': '192.168.1.1',\n        },\n        connection: {},\n      } as any;\n\n      const location = await service.detectLocationFromRequest(mockRequest);\n\n      expect(location.countryCode).toBe('US');\n      expect(location.region).toBe('CA');\n      expect(location.city).toBe('San Francisco');\n      expect(location.source).toBe('header');\n      expect(location.accuracy).toBe('high');\n    });\n\n    it('should fallback to IP geolocation when headers are missing', async () => {\n      const mockRequest = {\n        headers: {},\n        connection: { remoteAddress: '8.8.8.8' },\n      } as any;\n\n      const location = await service.detectLocationFromRequest(mockRequest);\n\n      expect(location.ip).toBe('8.8.8.8');\n      expect(location.source).toBe('ip');\n    });\n  });\n\n  describe('getGeoContent', () => {\n    it('should return correct currency for US', () => {\n      const location = {\n        countryCode: 'US',\n        timezone: 'America/Los_Angeles',\n      } as any;\n\n      const content = service.getGeoContent(location);\n\n      expect(content.currency).toBe('USD');\n      expect(content.language).toBe('en');\n      expect(content.pricing).toBe('premium');\n    });\n\n    it('should return correct content for emerging markets', () => {\n      const location = {\n        countryCode: 'IN',\n        timezone: 'Asia/Kolkata',\n      } as any;\n\n      const content = service.getGeoContent(location);\n\n      expect(content.currency).toBe('INR');\n      expect(content.pricing).toBe('standard');\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"react-testing-library-tests",children:"React Testing Library Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// useGeoTargeting.test.ts\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { useGeoTargeting } from './useGeoTargeting';\n\n// Mock fetch\nglobal.fetch = jest.fn();\n\ndescribe('useGeoTargeting', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    // Mock geolocation\n    const mockGeolocation = {\n      getCurrentPosition: jest.fn(),\n    };\n    Object.defineProperty(global.navigator, 'geolocation', {\n      value: mockGeolocation,\n      writable: true,\n    });\n  });\n\n  it('should fetch geo data successfully', async () => {\n    const mockGeoData = {\n      success: true,\n      data: {\n        location: { countryCode: 'US', country: 'United States' },\n        content: { currency: 'USD', language: 'en', pricing: 'premium' },\n      },\n    };\n\n    (fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve(mockGeoData),\n    });\n\n    const { result } = renderHook(() => useGeoTargeting());\n\n    expect(result.current.loading).toBe(true);\n\n    await waitFor(() => {\n      expect(result.current.loading).toBe(false);\n    });\n\n    expect(result.current.location?.countryCode).toBe('US');\n    expect(result.current.content.currency).toBe('USD');\n    expect(result.current.error).toBeNull();\n  });\n\n  it('should handle fetch errors gracefully', async () => {\n    (fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));\n\n    const { result } = renderHook(() => useGeoTargeting());\n\n    await waitFor(() => {\n      expect(result.current.loading).toBe(false);\n    });\n\n    expect(result.current.error).toBe('Network error');\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"production-deployment-considerations",children:"Production Deployment Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"environment-configuration",children:"Environment Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// config/geo.config.ts\nexport default () => ({\n  geo: {\n    enableBrowserGeolocation: process.env.ENABLE_BROWSER_GEOLOCATION === 'true',\n    ipApiKey: process.env.IP_GEOLOCATION_API_KEY,\n    cacheTimeout: parseInt(process.env.GEO_CACHE_TIMEOUT || '3600'),\n    enableGeoFencing: process.env.ENABLE_GEOFENCING === 'true',\n    privacyMode: process.env.GEO_PRIVACY_MODE || 'standard', // strict, standard, minimal\n    maxLocationHistory: parseInt(process.env.MAX_LOCATION_HISTORY || '100'),\n  },\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"cdn-integration",children:"CDN Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-nginx",children:"# nginx.conf for CDN geo headers\nlocation / {\n    # Add geo headers for application use\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header X-Country-Code $geoip_country_code;\n    proxy_set_header X-Region $geoip_region;\n    proxy_set_header X-City $geoip_city;\n    \n    proxy_pass http://backend;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-and-security",children:"Best Practices and Security"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Privacy First"}),": Always request consent before accessing precise location data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fallback Strategy"}),": Implement graceful degradation when location detection fails"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cache Wisely"}),": Cache geo data appropriately to balance performance and accuracy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security"}),": Validate and sanitize all location data inputs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compliance"}),": Stay updated with regional privacy regulations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Use CDN geo headers when available for better performance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testing"}),": Test with VPNs and different IP ranges to ensure accuracy"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"This comprehensive geo-targeting implementation provides a solid foundation for building location-aware applications. The modular approach allows you to implement only the features you need while maintaining flexibility for future enhancements."}),"\n",(0,r.jsx)(n.p,{children:"Key benefits of this implementation:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multiple detection methods"})," for maximum accuracy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Privacy-compliant"})," data handling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance optimized"})," with caching strategies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexible"})," and extensible architecture"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Production-ready"})," with comprehensive error handling"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Start with the basic location detection and gradually add advanced features like geo-fencing and A/B testing as your application requirements grow."})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},5741:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(9729);const r={},i=o.createContext(r);function a(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:n},e.children)}},8477:e=>{e.exports=JSON.parse('{"permalink":"/fullstack-dev/blog/geo-targeting-implementation-nodejs-react","editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/blog/2025-10-07-geo-targeting-implementation-nodejs-react.md","source":"@site/blog/2025-10-07-geo-targeting-implementation-nodejs-react.md","title":"Building Smart Location-Aware Applications: Complete Geo-targeting Implementation with Node.js and React","description":"Modern applications need to deliver personalized experiences based on user location. Whether you\'re implementing regional pricing, content localization, compliance restrictions, or location-based features, geo-targeting is essential for creating relevant user experiences.","date":"2025-10-07T00:00:00.000Z","tags":[{"inline":false,"label":"Geo Targeting","permalink":"/fullstack-dev/blog/tags/geo-targeting","description":"Geographic targeting and location-based services"},{"inline":false,"label":"Geolocation","permalink":"/fullstack-dev/blog/tags/geolocation","description":"Geolocation services and APIs"},{"inline":false,"label":"Node.js","permalink":"/fullstack-dev/blog/tags/nodejs","description":"Node.js runtime and development"},{"inline":false,"label":"NestJS","permalink":"/fullstack-dev/blog/tags/nestjs","description":"NestJS framework for Node.js applications"},{"inline":false,"label":"React","permalink":"/fullstack-dev/blog/tags/react","description":"React framework and component development"},{"inline":false,"label":"Next.js","permalink":"/fullstack-dev/blog/tags/nextjs","description":"Next.js framework and related topics"},{"inline":false,"label":"IP Geolocation","permalink":"/fullstack-dev/blog/tags/ip-geolocation","description":"IP-based geolocation services"},{"inline":false,"label":"Location Based Services","permalink":"/fullstack-dev/blog/tags/location-based-services","description":"Location-aware application features"},{"inline":false,"label":"Personalization","permalink":"/fullstack-dev/blog/tags/personalization","description":"User personalization and customization"}],"readingTime":14.48,"hasTruncateMarker":true,"authors":[{"name":"Tam Nguyen","title":"Full Stack Developer, Next.js for Production Creator","url":"https://github.com/tamnk74","page":{"permalink":"/fullstack-dev/blog/authors/tam"},"socials":{"github":"https://github.com/tamnk74"},"imageURL":"https://github.com/tamnk74.png","key":"tam"}],"frontMatter":{"slug":"geo-targeting-implementation-nodejs-react","title":"Building Smart Location-Aware Applications: Complete Geo-targeting Implementation with Node.js and React","authors":["tam"],"tags":["geo-targeting","geolocation","nodejs","nestjs","react","nextjs","ip-geolocation","location-based-services","personalization"]},"unlisted":false,"prevItem":{"title":"Building Intelligent E-commerce Recommendations with RAG: Part 4 - Generation and Personalization Engine","permalink":"/fullstack-dev/blog/rag-ecommerce-recommendations-part4-generation-personalization"},"nextItem":{"title":"GitOps in Practice: Deploying Node.js Microservices to GCP GKE with ArgoCD and Kustomize","permalink":"/fullstack-dev/blog/gitops-microservices-nodejs-gcp-practical-guide"}}')}}]);