"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[7263],{218:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"coding-conventions/nodejs-best-practices","title":"Node.js Best Practices","description":"Comprehensive guidelines for building robust, scalable, and secure Node.js applications.","source":"@site/docs/coding-conventions/nodejs-best-practices.md","sourceDirName":"coding-conventions","slug":"/coding-conventions/nodejs-best-practices","permalink":"/fullstack-dev/docs/coding-conventions/nodejs-best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/coding-conventions/nodejs-best-practices.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Next.js Conventions","permalink":"/fullstack-dev/docs/coding-conventions/nextjs-conventions"},"next":{"title":"NestJS Guidelines","permalink":"/fullstack-dev/docs/coding-conventions/nestjs-guidelines"}}');var t=r(5813),a=r(7814);const i={},o="Node.js Best Practices",c={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Project Structure",id:"project-structure",level:2},{value:"Recommended Directory Structure",id:"recommended-directory-structure",level:3},{value:"Module Organization",id:"module-organization",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Custom Error Classes",id:"custom-error-classes",level:3},{value:"Global Error Handler",id:"global-error-handler",level:3},{value:"Process-Level Error Handling",id:"process-level-error-handling",level:3},{value:"Asynchronous Programming",id:"asynchronous-programming",level:2},{value:"Async/Await Best Practices",id:"asyncawait-best-practices",level:3},{value:"Promise Patterns",id:"promise-patterns",level:3},{value:"Rate Limiting and Throttling",id:"rate-limiting-and-throttling",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"Input Validation and Sanitization",id:"input-validation-and-sanitization",level:3},{value:"Authentication and Authorization",id:"authentication-and-authorization",level:3},{value:"Data Sanitization",id:"data-sanitization",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Caching Strategies",id:"caching-strategies",level:3},{value:"Database Optimization",id:"database-optimization",level:3},{value:"Testing Strategies",id:"testing-strategies",level:2},{value:"Unit Testing",id:"unit-testing",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Logging and Monitoring",id:"logging-and-monitoring",level:2},{value:"Structured Logging",id:"structured-logging",level:3},{value:"Health Checks and Monitoring",id:"health-checks-and-monitoring",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"nodejs-best-practices",children:"Node.js Best Practices"})}),"\n",(0,t.jsx)(n.p,{children:"Comprehensive guidelines for building robust, scalable, and secure Node.js applications."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#project-structure",children:"Project Structure"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#error-handling",children:"Error Handling"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#asynchronous-programming",children:"Asynchronous Programming"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#security-best-practices",children:"Security Best Practices"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#testing-strategies",children:"Testing Strategies"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#logging-and-monitoring",children:"Logging and Monitoring"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"project-structure",children:"Project Structure"}),"\n",(0,t.jsx)(n.h3,{id:"recommended-directory-structure",children:"Recommended Directory Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"my-nodejs-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 controllers/       # Route handlers\n\u2502   \u251c\u2500\u2500 services/         # Business logic\n\u2502   \u251c\u2500\u2500 models/           # Data models\n\u2502   \u251c\u2500\u2500 middleware/       # Custom middleware\n\u2502   \u251c\u2500\u2500 routes/           # Route definitions\n\u2502   \u251c\u2500\u2500 utils/            # Utility functions\n\u2502   \u251c\u2500\u2500 config/           # Configuration files\n\u2502   \u251c\u2500\u2500 types/            # TypeScript type definitions\n\u2502   \u2514\u2500\u2500 app.ts            # Express app setup\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 unit/\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 fixtures/\n\u251c\u2500\u2500 docs/\n\u251c\u2500\u2500 scripts/              # Build and deployment scripts\n\u251c\u2500\u2500 .env.example\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 tsconfig.json\n\u2514\u2500\u2500 README.md\n"})}),"\n",(0,t.jsx)(n.h3,{id:"module-organization",children:"Module Organization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/models/user.model.ts\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateUserRequest {\n  email: string;\n  name: string;\n  password: string;\n}\n\nexport interface UpdateUserRequest {\n  name?: string;\n  email?: string;\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/services/user.service.ts\nimport { User, CreateUserRequest, UpdateUserRequest } from '../models/user.model';\nimport { UserRepository } from '../repositories/user.repository';\nimport { hashPassword, validateEmail } from '../utils/auth.utils';\nimport { ValidationError, NotFoundError } from '../utils/errors';\n\nexport class UserService {\n  constructor(private userRepository: UserRepository) {}\n\n  async createUser(userData: CreateUserRequest): Promise<User> {\n    // Validate input\n    if (!validateEmail(userData.email)) {\n      throw new ValidationError('Invalid email format');\n    }\n\n    // Check if user already exists\n    const existingUser = await this.userRepository.findByEmail(userData.email);\n    if (existingUser) {\n      throw new ValidationError('User with this email already exists');\n    }\n\n    // Hash password\n    const hashedPassword = await hashPassword(userData.password);\n\n    // Create user\n    const user = await this.userRepository.create({\n      ...userData,\n      password: hashedPassword,\n    });\n\n    return user;\n  }\n\n  async getUserById(id: string): Promise<User> {\n    const user = await this.userRepository.findById(id);\n    if (!user) {\n      throw new NotFoundError(`User with id ${id} not found`);\n    }\n    return user;\n  }\n\n  async updateUser(id: string, updateData: UpdateUserRequest): Promise<User> {\n    const user = await this.getUserById(id);\n    \n    if (updateData.email && updateData.email !== user.email) {\n      if (!validateEmail(updateData.email)) {\n        throw new ValidationError('Invalid email format');\n      }\n      \n      const existingUser = await this.userRepository.findByEmail(updateData.email);\n      if (existingUser && existingUser.id !== id) {\n        throw new ValidationError('Email already in use');\n      }\n    }\n\n    return this.userRepository.update(id, updateData);\n  }\n\n  async deleteUser(id: string): Promise<void> {\n    const user = await this.getUserById(id);\n    await this.userRepository.delete(id);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/controllers/user.controller.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { UserService } from '../services/user.service';\nimport { CreateUserRequest, UpdateUserRequest } from '../models/user.model';\nimport { logger } from '../utils/logger';\n\nexport class UserController {\n  constructor(private userService: UserService) {}\n\n  createUser = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const userData: CreateUserRequest = req.body;\n      const user = await this.userService.createUser(userData);\n      \n      logger.info('User created successfully', { userId: user.id });\n      \n      res.status(201).json({\n        success: true,\n        data: {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          createdAt: user.createdAt,\n        },\n      });\n    } catch (error) {\n      next(error);\n    }\n  };\n\n  getUser = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { id } = req.params;\n      const user = await this.userService.getUserById(id);\n      \n      res.json({\n        success: true,\n        data: {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          createdAt: user.createdAt,\n          updatedAt: user.updatedAt,\n        },\n      });\n    } catch (error) {\n      next(error);\n    }\n  };\n\n  updateUser = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { id } = req.params;\n      const updateData: UpdateUserRequest = req.body;\n      \n      const user = await this.userService.updateUser(id, updateData);\n      \n      logger.info('User updated successfully', { userId: id });\n      \n      res.json({\n        success: true,\n        data: {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          updatedAt: user.updatedAt,\n        },\n      });\n    } catch (error) {\n      next(error);\n    }\n  };\n\n  deleteUser = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { id } = req.params;\n      await this.userService.deleteUser(id);\n      \n      logger.info('User deleted successfully', { userId: id });\n      \n      res.status(204).send();\n    } catch (error) {\n      next(error);\n    }\n  };\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.h3,{id:"custom-error-classes",children:"Custom Error Classes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/utils/errors.ts\nexport abstract class AppError extends Error {\n  abstract statusCode: number;\n  abstract type: string;\n  \n  constructor(message: string, public context?: Record<string, any>) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class ValidationError extends AppError {\n  statusCode = 400;\n  type = 'VALIDATION_ERROR';\n}\n\nexport class NotFoundError extends AppError {\n  statusCode = 404;\n  type = 'NOT_FOUND';\n}\n\nexport class UnauthorizedError extends AppError {\n  statusCode = 401;\n  type = 'UNAUTHORIZED';\n}\n\nexport class ForbiddenError extends AppError {\n  statusCode = 403;\n  type = 'FORBIDDEN';\n}\n\nexport class ConflictError extends AppError {\n  statusCode = 409;\n  type = 'CONFLICT';\n}\n\nexport class InternalServerError extends AppError {\n  statusCode = 500;\n  type = 'INTERNAL_SERVER_ERROR';\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"global-error-handler",children:"Global Error Handler"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/middleware/error.middleware.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { AppError } from '../utils/errors';\nimport { logger } from '../utils/logger';\n\nexport function errorHandler(\n  error: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  logger.error('Error occurred:', {\n    message: error.message,\n    stack: error.stack,\n    url: req.url,\n    method: req.method,\n    userAgent: req.get('User-Agent'),\n    ip: req.ip,\n  });\n\n  // Handle known application errors\n  if (error instanceof AppError) {\n    return res.status(error.statusCode).json({\n      success: false,\n      error: {\n        type: error.type,\n        message: error.message,\n        ...(process.env.NODE_ENV === 'development' && { context: error.context }),\n      },\n    });\n  }\n\n  // Handle validation errors from libraries like Joi, Yup\n  if (error.name === 'ValidationError') {\n    return res.status(400).json({\n      success: false,\n      error: {\n        type: 'VALIDATION_ERROR',\n        message: 'Invalid input data',\n        details: error.message,\n      },\n    });\n  }\n\n  // Handle MongoDB duplicate key errors\n  if (error.name === 'MongoError' && (error as any).code === 11000) {\n    return res.status(409).json({\n      success: false,\n      error: {\n        type: 'DUPLICATE_KEY',\n        message: 'Resource already exists',\n      },\n    });\n  }\n\n  // Default to 500 server error\n  res.status(500).json({\n    success: false,\n    error: {\n      type: 'INTERNAL_SERVER_ERROR',\n      message: process.env.NODE_ENV === 'production' \n        ? 'Internal server error' \n        : error.message,\n    },\n  });\n}\n\n// 404 handler\nexport function notFoundHandler(req: Request, res: Response) {\n  res.status(404).json({\n    success: false,\n    error: {\n      type: 'NOT_FOUND',\n      message: `Route ${req.originalUrl} not found`,\n    },\n  });\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"process-level-error-handling",children:"Process-Level Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/app.ts\nprocess.on('uncaughtException', (error: Error) => {\n  logger.error('Uncaught Exception:', error);\n  process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason: any, promise: Promise<any>) => {\n  logger.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  process.exit(1);\n});\n\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n  logger.info('SIGTERM received, shutting down gracefully');\n  server.close(() => {\n    logger.info('Process terminated');\n    process.exit(0);\n  });\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"asynchronous-programming",children:"Asynchronous Programming"}),"\n",(0,t.jsx)(n.h3,{id:"asyncawait-best-practices",children:"Async/Await Best Practices"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad - Not handling errors properly\nasync function fetchUserData(userId: string) {\n  const user = await userService.getUserById(userId);\n  const orders = await orderService.getOrdersByUserId(userId);\n  return { user, orders };\n}\n\n// \u2705 Good - Proper error handling\nasync function fetchUserData(userId: string): Promise<{ user: User; orders: Order[] }> {\n  try {\n    const [user, orders] = await Promise.all([\n      userService.getUserById(userId),\n      orderService.getOrdersByUserId(userId),\n    ]);\n    \n    return { user, orders };\n  } catch (error) {\n    logger.error('Failed to fetch user data', { userId, error });\n    throw new InternalServerError('Failed to fetch user data');\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"promise-patterns",children:"Promise Patterns"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Parallel execution with Promise.all\nasync function fetchUserProfile(userId: string) {\n  try {\n    const [user, profile, preferences] = await Promise.all([\n      userService.getUserById(userId),\n      profileService.getProfileByUserId(userId),\n      preferencesService.getPreferences(userId),\n    ]);\n    \n    return { user, profile, preferences };\n  } catch (error) {\n    // If any promise fails, all fail\n    throw error;\n  }\n}\n\n// Sequential execution with fallbacks\nasync function fetchUserWithFallback(userId: string) {\n  try {\n    // Try primary data source\n    return await primaryUserService.getUserById(userId);\n  } catch (primaryError) {\n    logger.warn('Primary service failed, trying backup', { userId, error: primaryError });\n    \n    try {\n      // Fallback to secondary data source\n      return await backupUserService.getUserById(userId);\n    } catch (backupError) {\n      logger.error('Both services failed', { userId, primaryError, backupError });\n      throw new InternalServerError('User service unavailable');\n    }\n  }\n}\n\n// Promise.allSettled for partial failures\nasync function fetchMultipleUsers(userIds: string[]) {\n  const results = await Promise.allSettled(\n    userIds.map(id => userService.getUserById(id))\n  );\n  \n  const users: User[] = [];\n  const errors: string[] = [];\n  \n  results.forEach((result, index) => {\n    if (result.status === 'fulfilled') {\n      users.push(result.value);\n    } else {\n      errors.push(`Failed to fetch user ${userIds[index]}: ${result.reason.message}`);\n    }\n  });\n  \n  return { users, errors };\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"rate-limiting-and-throttling",children:"Rate Limiting and Throttling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/utils/rate-limiter.ts\nimport { Request, Response, NextFunction } from 'express';\n\ninterface RateLimitOptions {\n  windowMs: number;\n  max: number;\n  message?: string;\n}\n\nconst store = new Map<string, { count: number; resetTime: number }>();\n\nexport function rateLimit(options: RateLimitOptions) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const key = req.ip || 'unknown';\n    const now = Date.now();\n    \n    let record = store.get(key);\n    \n    if (!record || now > record.resetTime) {\n      record = {\n        count: 1,\n        resetTime: now + options.windowMs,\n      };\n      store.set(key, record);\n      return next();\n    }\n    \n    if (record.count >= options.max) {\n      return res.status(429).json({\n        success: false,\n        error: {\n          type: 'RATE_LIMIT_EXCEEDED',\n          message: options.message || 'Too many requests',\n        },\n      });\n    }\n    \n    record.count++;\n    next();\n  };\n}\n\n// Usage\napp.use('/api', rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  message: 'Too many requests from this IP',\n}));\n"})}),"\n",(0,t.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"input-validation-and-sanitization",children:"Input Validation and Sanitization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/middleware/validation.middleware.ts\nimport { Request, Response, NextFunction } from 'express';\nimport Joi from 'joi';\nimport { ValidationError } from '../utils/errors';\n\nexport function validate(schema: Joi.ObjectSchema) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const { error, value } = schema.validate(req.body, { \n      abortEarly: false,\n      stripUnknown: true,\n    });\n    \n    if (error) {\n      const details = error.details.map(detail => ({\n        field: detail.path.join('.'),\n        message: detail.message,\n      }));\n      \n      throw new ValidationError('Validation failed', { details });\n    }\n    \n    req.body = value;\n    next();\n  };\n}\n\n// Validation schemas\nexport const createUserSchema = Joi.object({\n  email: Joi.string().email().required(),\n  name: Joi.string().min(2).max(50).required(),\n  password: Joi.string().min(8).pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/).required(),\n  age: Joi.number().integer().min(18).max(120).optional(),\n});\n\nexport const updateUserSchema = Joi.object({\n  email: Joi.string().email().optional(),\n  name: Joi.string().min(2).max(50).optional(),\n  age: Joi.number().integer().min(18).max(120).optional(),\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"authentication-and-authorization",children:"Authentication and Authorization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/middleware/auth.middleware.ts\nimport jwt from 'jsonwebtoken';\nimport { Request, Response, NextFunction } from 'express';\nimport { UnauthorizedError, ForbiddenError } from '../utils/errors';\n\ninterface AuthenticatedRequest extends Request {\n  user?: {\n    id: string;\n    email: string;\n    role: string;\n  };\n}\n\nexport function authenticate(req: AuthenticatedRequest, res: Response, next: NextFunction) {\n  const token = req.headers.authorization?.replace('Bearer ', '');\n  \n  if (!token) {\n    throw new UnauthorizedError('Access token required');\n  }\n  \n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;\n    req.user = decoded;\n    next();\n  } catch (error) {\n    throw new UnauthorizedError('Invalid or expired token');\n  }\n}\n\nexport function authorize(roles: string[]) {\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      throw new UnauthorizedError('Authentication required');\n    }\n    \n    if (!roles.includes(req.user.role)) {\n      throw new ForbiddenError('Insufficient permissions');\n    }\n    \n    next();\n  };\n}\n\n// Usage\nrouter.get('/admin/users', authenticate, authorize(['admin']), userController.getAllUsers);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"data-sanitization",children:"Data Sanitization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/utils/sanitization.ts\nimport DOMPurify from 'isomorphic-dompurify';\nimport validator from 'validator';\n\nexport function sanitizeHtml(input: string): string {\n  return DOMPurify.sanitize(input);\n}\n\nexport function sanitizeEmail(email: string): string {\n  return validator.normalizeEmail(email) || '';\n}\n\nexport function escapeHtml(unsafe: string): string {\n  return validator.escape(unsafe);\n}\n\nexport function sanitizeInput(input: any): any {\n  if (typeof input === 'string') {\n    return validator.escape(input.trim());\n  }\n  \n  if (Array.isArray(input)) {\n    return input.map(sanitizeInput);\n  }\n  \n  if (typeof input === 'object' && input !== null) {\n    const sanitized: any = {};\n    for (const [key, value] of Object.entries(input)) {\n      sanitized[key] = sanitizeInput(value);\n    }\n    return sanitized;\n  }\n  \n  return input;\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"caching-strategies",children:"Caching Strategies"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/utils/cache.ts\nimport NodeCache from 'node-cache';\nimport Redis from 'ioredis';\n\nclass CacheService {\n  private memoryCache: NodeCache;\n  private redisClient: Redis;\n  \n  constructor() {\n    this.memoryCache = new NodeCache({ \n      stdTTL: 600, // 10 minutes default TTL\n      checkperiod: 120 // Check for expired keys every 2 minutes\n    });\n    \n    this.redisClient = new Redis({\n      host: process.env.REDIS_HOST || 'localhost',\n      port: parseInt(process.env.REDIS_PORT || '6379'),\n      retryDelayOnFailover: 100,\n      maxRetriesPerRequest: 3,\n    });\n  }\n  \n  async get<T>(key: string): Promise<T | null> {\n    // Try memory cache first\n    const memoryResult = this.memoryCache.get<T>(key);\n    if (memoryResult !== undefined) {\n      return memoryResult;\n    }\n    \n    // Fallback to Redis\n    try {\n      const redisResult = await this.redisClient.get(key);\n      if (redisResult) {\n        const parsed = JSON.parse(redisResult);\n        // Store in memory cache for faster access\n        this.memoryCache.set(key, parsed, 300); // 5 minutes in memory\n        return parsed;\n      }\n    } catch (error) {\n      logger.warn('Redis cache error:', error);\n    }\n    \n    return null;\n  }\n  \n  async set<T>(key: string, value: T, ttl?: number): Promise<void> {\n    // Store in memory cache\n    this.memoryCache.set(key, value, ttl);\n    \n    // Store in Redis\n    try {\n      const serialized = JSON.stringify(value);\n      if (ttl) {\n        await this.redisClient.setex(key, ttl, serialized);\n      } else {\n        await this.redisClient.set(key, serialized);\n      }\n    } catch (error) {\n      logger.warn('Redis cache set error:', error);\n    }\n  }\n  \n  async del(key: string): Promise<void> {\n    this.memoryCache.del(key);\n    \n    try {\n      await this.redisClient.del(key);\n    } catch (error) {\n      logger.warn('Redis cache delete error:', error);\n    }\n  }\n  \n  async flush(): Promise<void> {\n    this.memoryCache.flushAll();\n    \n    try {\n      await this.redisClient.flushall();\n    } catch (error) {\n      logger.warn('Redis cache flush error:', error);\n    }\n  }\n}\n\nexport const cache = new CacheService();\n\n// Caching decorator\nexport function cacheable(ttl: number = 600) {\n  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const method = descriptor.value;\n    \n    descriptor.value = async function (...args: any[]) {\n      const cacheKey = `${target.constructor.name}:${propertyName}:${JSON.stringify(args)}`;\n      \n      const cached = await cache.get(cacheKey);\n      if (cached !== null) {\n        return cached;\n      }\n      \n      const result = await method.apply(this, args);\n      await cache.set(cacheKey, result, ttl);\n      \n      return result;\n    };\n    \n    return descriptor;\n  };\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"database-optimization",children:"Database Optimization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/repositories/user.repository.ts\nimport { User, CreateUserRequest, UpdateUserRequest } from '../models/user.model';\nimport { cache } from '../utils/cache';\n\nexport class UserRepository {\n  @cacheable(300) // Cache for 5 minutes\n  async findById(id: string): Promise<User | null> {\n    // First check cache\n    const cacheKey = `user:${id}`;\n    const cached = await cache.get<User>(cacheKey);\n    if (cached) {\n      return cached;\n    }\n    \n    const user = await this.db.collection('users').findOne({ _id: id });\n    \n    if (user) {\n      await cache.set(cacheKey, user, 300);\n    }\n    \n    return user;\n  }\n  \n  async create(userData: CreateUserRequest): Promise<User> {\n    const user = await this.db.collection('users').insertOne({\n      ...userData,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    });\n    \n    // Cache the new user\n    await cache.set(`user:${user.insertedId}`, user, 300);\n    \n    return user;\n  }\n  \n  async update(id: string, updateData: UpdateUserRequest): Promise<User> {\n    const user = await this.db.collection('users').findOneAndUpdate(\n      { _id: id },\n      { \n        $set: { \n          ...updateData, \n          updatedAt: new Date() \n        } \n      },\n      { returnDocument: 'after' }\n    );\n    \n    // Update cache\n    if (user.value) {\n      await cache.set(`user:${id}`, user.value, 300);\n    }\n    \n    return user.value!;\n  }\n  \n  async delete(id: string): Promise<void> {\n    await this.db.collection('users').deleteOne({ _id: id });\n    \n    // Remove from cache\n    await cache.del(`user:${id}`);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,t.jsx)(n.h3,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// tests/unit/services/user.service.test.ts\nimport { UserService } from '../../../src/services/user.service';\nimport { UserRepository } from '../../../src/repositories/user.repository';\nimport { ValidationError, NotFoundError } from '../../../src/utils/errors';\n\ndescribe('UserService', () => {\n  let userService: UserService;\n  let userRepository: jest.Mocked<UserRepository>;\n  \n  beforeEach(() => {\n    userRepository = {\n      findById: jest.fn(),\n      findByEmail: jest.fn(),\n      create: jest.fn(),\n      update: jest.fn(),\n      delete: jest.fn(),\n    } as any;\n    \n    userService = new UserService(userRepository);\n  });\n  \n  describe('createUser', () => {\n    const validUserData = {\n      email: 'test@example.com',\n      name: 'Test User',\n      password: 'SecurePass123!',\n    };\n    \n    it('should create a user with valid data', async () => {\n      // Arrange\n      userRepository.findByEmail.mockResolvedValue(null);\n      userRepository.create.mockResolvedValue({\n        id: '123',\n        email: validUserData.email,\n        name: validUserData.name,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      } as any);\n      \n      // Act\n      const result = await userService.createUser(validUserData);\n      \n      // Assert\n      expect(result).toHaveProperty('id');\n      expect(result.email).toBe(validUserData.email);\n      expect(userRepository.findByEmail).toHaveBeenCalledWith(validUserData.email);\n      expect(userRepository.create).toHaveBeenCalled();\n    });\n    \n    it('should throw ValidationError for invalid email', async () => {\n      // Arrange\n      const invalidData = { ...validUserData, email: 'invalid-email' };\n      \n      // Act & Assert\n      await expect(userService.createUser(invalidData))\n        .rejects\n        .toThrow(ValidationError);\n    });\n    \n    it('should throw ValidationError if user already exists', async () => {\n      // Arrange\n      userRepository.findByEmail.mockResolvedValue({\n        id: '456',\n        email: validUserData.email,\n      } as any);\n      \n      // Act & Assert\n      await expect(userService.createUser(validUserData))\n        .rejects\n        .toThrow(ValidationError);\n    });\n  });\n  \n  describe('getUserById', () => {\n    it('should return user when found', async () => {\n      // Arrange\n      const userId = '123';\n      const mockUser = {\n        id: userId,\n        email: 'test@example.com',\n        name: 'Test User',\n      };\n      userRepository.findById.mockResolvedValue(mockUser as any);\n      \n      // Act\n      const result = await userService.getUserById(userId);\n      \n      // Assert\n      expect(result).toEqual(mockUser);\n      expect(userRepository.findById).toHaveBeenCalledWith(userId);\n    });\n    \n    it('should throw NotFoundError when user not found', async () => {\n      // Arrange\n      const userId = '123';\n      userRepository.findById.mockResolvedValue(null);\n      \n      // Act & Assert\n      await expect(userService.getUserById(userId))\n        .rejects\n        .toThrow(NotFoundError);\n    });\n  });\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// tests/integration/user.controller.test.ts\nimport request from 'supertest';\nimport { app } from '../../src/app';\nimport { setupTestDatabase, cleanupTestDatabase } from '../helpers/database';\n\ndescribe('User Controller', () => {\n  beforeAll(async () => {\n    await setupTestDatabase();\n  });\n  \n  afterAll(async () => {\n    await cleanupTestDatabase();\n  });\n  \n  describe('POST /api/users', () => {\n    it('should create a new user', async () => {\n      const userData = {\n        email: 'test@example.com',\n        name: 'Test User',\n        password: 'SecurePass123!',\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(201);\n      \n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toHaveProperty('id');\n      expect(response.body.data.email).toBe(userData.email);\n      expect(response.body.data.name).toBe(userData.name);\n      expect(response.body.data).not.toHaveProperty('password');\n    });\n    \n    it('should return 400 for invalid email', async () => {\n      const userData = {\n        email: 'invalid-email',\n        name: 'Test User',\n        password: 'SecurePass123!',\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(400);\n      \n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('VALIDATION_ERROR');\n    });\n  });\n  \n  describe('GET /api/users/:id', () => {\n    it('should return user by id', async () => {\n      // First create a user\n      const createResponse = await request(app)\n        .post('/api/users')\n        .send({\n          email: 'gettest@example.com',\n          name: 'Get Test User',\n          password: 'SecurePass123!',\n        });\n      \n      const userId = createResponse.body.data.id;\n      \n      // Then get the user\n      const response = await request(app)\n        .get(`/api/users/${userId}`)\n        .expect(200);\n      \n      expect(response.body.success).toBe(true);\n      expect(response.body.data.id).toBe(userId);\n      expect(response.body.data.email).toBe('gettest@example.com');\n    });\n    \n    it('should return 404 for non-existent user', async () => {\n      const response = await request(app)\n        .get('/api/users/non-existent-id')\n        .expect(404);\n      \n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('NOT_FOUND');\n    });\n  });\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"logging-and-monitoring",children:"Logging and Monitoring"}),"\n",(0,t.jsx)(n.h3,{id:"structured-logging",children:"Structured Logging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/utils/logger.ts\nimport winston from 'winston';\n\nconst logFormat = winston.format.combine(\n  winston.format.timestamp(),\n  winston.format.errors({ stack: true }),\n  winston.format.json()\n);\n\nexport const logger = winston.createLogger({\n  level: process.env.LOG_LEVEL || 'info',\n  format: logFormat,\n  defaultMeta: {\n    service: process.env.SERVICE_NAME || 'api',\n    version: process.env.APP_VERSION || '1.0.0',\n  },\n  transports: [\n    new winston.transports.Console({\n      format: process.env.NODE_ENV === 'development'\n        ? winston.format.combine(\n            winston.format.colorize(),\n            winston.format.simple()\n          )\n        : logFormat,\n    }),\n    \n    // File transport for production\n    ...(process.env.NODE_ENV === 'production' ? [\n      new winston.transports.File({\n        filename: 'logs/error.log',\n        level: 'error',\n      }),\n      new winston.transports.File({\n        filename: 'logs/combined.log',\n      }),\n    ] : []),\n  ],\n});\n\n// Request logging middleware\nexport function requestLogger(req: Request, res: Response, next: NextFunction) {\n  const start = Date.now();\n  \n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    \n    logger.info('HTTP Request', {\n      method: req.method,\n      url: req.url,\n      statusCode: res.statusCode,\n      duration,\n      userAgent: req.get('User-Agent'),\n      ip: req.ip,\n    });\n  });\n  \n  next();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"health-checks-and-monitoring",children:"Health Checks and Monitoring"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/routes/health.routes.ts\nimport { Router, Request, Response } from 'express';\nimport { cache } from '../utils/cache';\nimport { database } from '../config/database';\n\nconst router = Router();\n\nrouter.get('/health', async (req: Request, res: Response) => {\n  const healthcheck = {\n    uptime: process.uptime(),\n    message: 'OK',\n    timestamp: Date.now(),\n    checks: {\n      database: await checkDatabase(),\n      cache: await checkCache(),\n      memory: checkMemory(),\n    },\n  };\n  \n  const isHealthy = Object.values(healthcheck.checks).every(check => check.status === 'ok');\n  \n  res.status(isHealthy ? 200 : 503).json(healthcheck);\n});\n\nasync function checkDatabase() {\n  try {\n    await database.ping();\n    return { status: 'ok', message: 'Database connection is healthy' };\n  } catch (error) {\n    return { status: 'error', message: 'Database connection failed' };\n  }\n}\n\nasync function checkCache() {\n  try {\n    await cache.set('health-check', 'ok', 10);\n    const result = await cache.get('health-check');\n    return result === 'ok' \n      ? { status: 'ok', message: 'Cache is working' }\n      : { status: 'error', message: 'Cache read/write failed' };\n  } catch (error) {\n    return { status: 'error', message: 'Cache connection failed' };\n  }\n}\n\nfunction checkMemory() {\n  const memUsage = process.memoryUsage();\n  const memoryUsageMB = {\n    rss: Math.round(memUsage.rss / 1024 / 1024),\n    heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),\n    heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),\n    external: Math.round(memUsage.external / 1024 / 1024),\n  };\n  \n  return {\n    status: memoryUsageMB.heapUsed < 512 ? 'ok' : 'warning',\n    usage: memoryUsageMB,\n  };\n}\n\nexport { router as healthRoutes };\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use TypeScript"})," for better type safety and developer experience"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implement proper error handling"})," with custom error classes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Follow async/await patterns"})," and handle promises correctly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validate and sanitize input"})," to prevent security vulnerabilities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implement authentication and authorization"})," properly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use caching strategies"})," to improve performance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Write comprehensive tests"})," for all components"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implement structured logging"})," for better debugging"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitor application health"})," with health checks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Follow security best practices"})," for production deployments"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},7814:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(9729);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);