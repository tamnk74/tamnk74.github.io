"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[2737],{5741:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(9729);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},7824:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"security-practices/security-implementation/log-data-security","title":"Log Data Security Implementation Guide","description":"This guide provides comprehensive log data security implementation for NestJS/Next.js applications on GCP Kubernetes, covering secure logging practices, log data protection, and compliance requirements.","source":"@site/docs/security-practices/security-implementation/log-data-security.md","sourceDirName":"security-practices/security-implementation","slug":"/security-practices/security-implementation/log-data-security","permalink":"/fullstack-dev/docs/security-practices/security-implementation/log-data-security","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/security-practices/security-implementation/log-data-security.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Sensitive System Data Protection Implementation","permalink":"/fullstack-dev/docs/security-practices/security-implementation/sensitive-data-protection"},"next":{"title":"Secure SDLC Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/secure-sdlc"}}');var s=t(5813),o=t(5741);const r={},a="Log Data Security Implementation Guide",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Secure Logging Architecture",id:"secure-logging-architecture",level:2},{value:"Centralized Logging Service",id:"centralized-logging-service",level:3},{value:"Log Data Classification",id:"log-data-classification",level:2},{value:"Log Classification Service",id:"log-classification-service",level:3},{value:"Log Protection &amp; Encryption",id:"log-protection--encryption",level:2},{value:"Log Encryption Service",id:"log-encryption-service",level:3},{value:"Access Controls &amp; Monitoring",id:"access-controls--monitoring",level:2},{value:"Log Access Control Service",id:"log-access-control-service",level:3},{value:"Retention &amp; Compliance",id:"retention--compliance",level:2},{value:"Log Retention Management",id:"log-retention-management",level:3}];function g(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"log-data-security-implementation-guide",children:"Log Data Security Implementation Guide"})}),"\n",(0,s.jsx)(n.p,{children:"This guide provides comprehensive log data security implementation for NestJS/Next.js applications on GCP Kubernetes, covering secure logging practices, log data protection, and compliance requirements."}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#secure-logging-architecture",children:"Secure Logging Architecture"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#log-data-classification",children:"Log Data Classification"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#log-protection--encryption",children:"Log Protection & Encryption"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#access-controls--monitoring",children:"Access Controls & Monitoring"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#retention--compliance",children:"Retention & Compliance"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"secure-logging-architecture",children:"Secure Logging Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"centralized-logging-service",children:"Centralized Logging Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/logging/secure-logger.service.ts\nimport { Injectable, LoggerService } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport * as winston from 'winston';\nimport { LoggingWinston } from '@google-cloud/logging-winston';\n\ninterface LogContext {\n  userId?: string;\n  sessionId?: string;\n  requestId?: string;\n  ipAddress?: string;\n  userAgent?: string;\n  action?: string;\n  resource?: string;\n  timestamp?: Date;\n  severity?: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'CRITICAL';\n}\n\ninterface SecurityEvent {\n  eventType: 'AUTHENTICATION' | 'AUTHORIZATION' | 'DATA_ACCESS' | 'CONFIGURATION_CHANGE' | 'SECURITY_VIOLATION';\n  eventCategory: 'SUCCESS' | 'FAILURE' | 'ATTEMPT';\n  description: string;\n  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  context: LogContext;\n  sensitiveData?: boolean;\n  complianceRelevant?: boolean;\n}\n\n@Injectable()\nexport class SecureLoggerService implements LoggerService {\n  private readonly logger: winston.Logger;\n  private readonly securityLogger: winston.Logger;\n  private readonly auditLogger: winston.Logger;\n  private readonly sensitiveDataPatterns: RegExp[];\n\n  constructor(private configService: ConfigService) {\n    this.sensitiveDataPatterns = this.initializeSensitivePatterns();\n    this.logger = this.createApplicationLogger();\n    this.securityLogger = this.createSecurityLogger();\n    this.auditLogger = this.createAuditLogger();\n  }\n\n  log(message: string, context?: LogContext): void {\n    const sanitizedMessage = this.sanitizeMessage(message);\n    const logEntry = this.createLogEntry('INFO', sanitizedMessage, context);\n    this.logger.info(logEntry);\n  }\n\n  error(message: string, trace?: string, context?: LogContext): void {\n    const sanitizedMessage = this.sanitizeMessage(message);\n    const sanitizedTrace = trace ? this.sanitizeMessage(trace) : undefined;\n    const logEntry = this.createLogEntry('ERROR', sanitizedMessage, context, sanitizedTrace);\n    this.logger.error(logEntry);\n  }\n\n  warn(message: string, context?: LogContext): void {\n    const sanitizedMessage = this.sanitizeMessage(message);\n    const logEntry = this.createLogEntry('WARN', sanitizedMessage, context);\n    this.logger.warn(logEntry);\n  }\n\n  debug(message: string, context?: LogContext): void {\n    if (this.configService.get('NODE_ENV') !== 'production') {\n      const sanitizedMessage = this.sanitizeMessage(message);\n      const logEntry = this.createLogEntry('DEBUG', sanitizedMessage, context);\n      this.logger.debug(logEntry);\n    }\n  }\n\n  verbose(message: string, context?: LogContext): void {\n    this.debug(message, context);\n  }\n\n  async logSecurityEvent(event: SecurityEvent): Promise<void> {\n    const sanitizedEvent = this.sanitizeSecurityEvent(event);\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      eventType: sanitizedEvent.eventType,\n      eventCategory: sanitizedEvent.eventCategory,\n      description: sanitizedEvent.description,\n      riskLevel: sanitizedEvent.riskLevel,\n      context: this.sanitizeContext(sanitizedEvent.context),\n      environment: this.configService.get('NODE_ENV'),\n      application: this.configService.get('APP_NAME'),\n      version: this.configService.get('APP_VERSION'),\n    };\n\n    this.securityLogger.info(logEntry);\n\n    // Alert on high-risk security events\n    if (event.riskLevel === 'HIGH' || event.riskLevel === 'CRITICAL') {\n      await this.alertSecurityIncident(logEntry);\n    }\n  }\n\n  async logAuditEvent(\n    action: string,\n    resource: string,\n    result: 'SUCCESS' | 'FAILURE',\n    context: LogContext,\n    details?: any\n  ): Promise<void> {\n    const auditEntry = {\n      timestamp: new Date().toISOString(),\n      action,\n      resource,\n      result,\n      userId: context.userId,\n      sessionId: context.sessionId,\n      ipAddress: context.ipAddress,\n      userAgent: this.sanitizeUserAgent(context.userAgent),\n      details: details ? this.sanitizeObject(details) : undefined,\n      environment: this.configService.get('NODE_ENV'),\n    };\n\n    this.auditLogger.info(auditEntry);\n  }\n\n  async logDataAccess(\n    dataType: string,\n    operation: 'READ' | 'WRITE' | 'DELETE',\n    recordIds: string[],\n    context: LogContext\n  ): Promise<void> {\n    const dataAccessEvent: SecurityEvent = {\n      eventType: 'DATA_ACCESS',\n      eventCategory: 'SUCCESS',\n      description: `${operation} operation on ${dataType}`,\n      riskLevel: this.calculateDataAccessRisk(dataType, operation),\n      context,\n      sensitiveData: this.isSensitiveDataType(dataType),\n      complianceRelevant: this.isComplianceRelevantData(dataType),\n    };\n\n    await this.logSecurityEvent(dataAccessEvent);\n\n    // Separate audit log for data access\n    await this.logAuditEvent(\n      `DATA_${operation}`,\n      dataType,\n      'SUCCESS',\n      context,\n      { recordCount: recordIds.length }\n    );\n  }\n\n  async logAuthenticationEvent(\n    eventType: 'LOGIN' | 'LOGOUT' | 'FAILED_LOGIN' | 'PASSWORD_CHANGE' | 'MFA_CHALLENGE',\n    userId: string,\n    result: 'SUCCESS' | 'FAILURE',\n    context: LogContext,\n    additionalInfo?: any\n  ): Promise<void> {\n    const authEvent: SecurityEvent = {\n      eventType: 'AUTHENTICATION',\n      eventCategory: result,\n      description: `${eventType} ${result.toLowerCase()}`,\n      riskLevel: this.calculateAuthRisk(eventType, result),\n      context: { ...context, userId },\n    };\n\n    await this.logSecurityEvent(authEvent);\n  }\n\n  async logAuthorizationEvent(\n    action: string,\n    resource: string,\n    decision: 'ALLOW' | 'DENY',\n    context: LogContext\n  ): Promise<void> {\n    const authzEvent: SecurityEvent = {\n      eventType: 'AUTHORIZATION',\n      eventCategory: decision === 'ALLOW' ? 'SUCCESS' : 'FAILURE',\n      description: `Authorization ${decision.toLowerCase()} for ${action} on ${resource}`,\n      riskLevel: decision === 'DENY' ? 'MEDIUM' : 'LOW',\n      context,\n    };\n\n    await this.logSecurityEvent(authzEvent);\n  }\n\n  async logConfigurationChange(\n    configType: string,\n    changeType: 'CREATE' | 'UPDATE' | 'DELETE',\n    context: LogContext,\n    oldValue?: any,\n    newValue?: any\n  ): Promise<void> {\n    const configEvent: SecurityEvent = {\n      eventType: 'CONFIGURATION_CHANGE',\n      eventCategory: 'SUCCESS',\n      description: `${changeType} configuration: ${configType}`,\n      riskLevel: 'MEDIUM',\n      context,\n      complianceRelevant: true,\n    };\n\n    await this.logSecurityEvent(configEvent);\n\n    // Detailed audit log for configuration changes\n    await this.logAuditEvent(\n      `CONFIG_${changeType}`,\n      configType,\n      'SUCCESS',\n      context,\n      {\n        oldValue: oldValue ? this.sanitizeObject(oldValue) : undefined,\n        newValue: newValue ? this.sanitizeObject(newValue) : undefined,\n      }\n    );\n  }\n\n  private createApplicationLogger(): winston.Logger {\n    const transports: winston.transport[] = [];\n\n    // Console transport for development\n    if (this.configService.get('NODE_ENV') !== 'production') {\n      transports.push(\n        new winston.transports.Console({\n          format: winston.format.combine(\n            winston.format.colorize(),\n            winston.format.timestamp(),\n            winston.format.printf(({ timestamp, level, message, ...meta }) => {\n              return `${timestamp} [${level}]: ${message} ${\n                Object.keys(meta).length ? JSON.stringify(meta, null, 2) : ''\n              }`;\n            })\n          ),\n        })\n      );\n    }\n\n    // Google Cloud Logging transport for production\n    if (this.configService.get('NODE_ENV') === 'production') {\n      transports.push(\n        new LoggingWinston({\n          projectId: this.configService.get('GCP_PROJECT_ID'),\n          logName: 'application-logs',\n          resource: {\n            type: 'k8s_container',\n            labels: {\n              cluster_name: this.configService.get('GKE_CLUSTER_NAME'),\n              namespace_name: this.configService.get('K8S_NAMESPACE'),\n            },\n          },\n        })\n      );\n    }\n\n    return winston.createLogger({\n      level: this.configService.get('LOG_LEVEL', 'info'),\n      format: winston.format.combine(\n        winston.format.timestamp(),\n        winston.format.errors({ stack: true }),\n        winston.format.json()\n      ),\n      transports,\n    });\n  }\n\n  private createSecurityLogger(): winston.Logger {\n    const transports: winston.transport[] = [];\n\n    if (this.configService.get('NODE_ENV') === 'production') {\n      transports.push(\n        new LoggingWinston({\n          projectId: this.configService.get('GCP_PROJECT_ID'),\n          logName: 'security-events',\n          resource: {\n            type: 'k8s_container',\n            labels: {\n              cluster_name: this.configService.get('GKE_CLUSTER_NAME'),\n              namespace_name: this.configService.get('K8S_NAMESPACE'),\n            },\n          },\n        })\n      );\n    } else {\n      transports.push(new winston.transports.Console());\n    }\n\n    return winston.createLogger({\n      level: 'info',\n      format: winston.format.combine(\n        winston.format.timestamp(),\n        winston.format.json()\n      ),\n      transports,\n    });\n  }\n\n  private createAuditLogger(): winston.Logger {\n    const transports: winston.transport[] = [];\n\n    if (this.configService.get('NODE_ENV') === 'production') {\n      transports.push(\n        new LoggingWinston({\n          projectId: this.configService.get('GCP_PROJECT_ID'),\n          logName: 'audit-logs',\n          resource: {\n            type: 'k8s_container',\n            labels: {\n              cluster_name: this.configService.get('GKE_CLUSTER_NAME'),\n              namespace_name: this.configService.get('K8S_NAMESPACE'),\n            },\n          },\n        })\n      );\n    } else {\n      transports.push(new winston.transports.Console());\n    }\n\n    return winston.createLogger({\n      level: 'info',\n      format: winston.format.combine(\n        winston.format.timestamp(),\n        winston.format.json()\n      ),\n      transports,\n    });\n  }\n\n  private createLogEntry(\n    level: string,\n    message: string,\n    context?: LogContext,\n    trace?: string\n  ): any {\n    return {\n      level,\n      message,\n      timestamp: new Date().toISOString(),\n      context: context ? this.sanitizeContext(context) : undefined,\n      trace,\n      environment: this.configService.get('NODE_ENV'),\n      application: this.configService.get('APP_NAME'),\n      version: this.configService.get('APP_VERSION'),\n    };\n  }\n\n  private sanitizeMessage(message: string): string {\n    let sanitized = message;\n    \n    for (const pattern of this.sensitiveDataPatterns) {\n      sanitized = sanitized.replace(pattern, '[REDACTED]');\n    }\n    \n    return sanitized;\n  }\n\n  private sanitizeContext(context: LogContext): LogContext {\n    const sanitized = { ...context };\n    \n    // Remove or hash sensitive context data\n    if (sanitized.userId) {\n      sanitized.userId = this.hashUserId(sanitized.userId);\n    }\n    \n    return sanitized;\n  }\n\n  private sanitizeSecurityEvent(event: SecurityEvent): SecurityEvent {\n    return {\n      ...event,\n      description: this.sanitizeMessage(event.description),\n      context: this.sanitizeContext(event.context),\n    };\n  }\n\n  private sanitizeObject(obj: any): any {\n    if (typeof obj !== 'object' || obj === null) {\n      return obj;\n    }\n\n    const sanitized = { ...obj };\n    const sensitiveKeys = ['password', 'token', 'secret', 'key', 'credential'];\n    \n    for (const key in sanitized) {\n      if (sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive))) {\n        sanitized[key] = '[REDACTED]';\n      } else if (typeof sanitized[key] === 'object') {\n        sanitized[key] = this.sanitizeObject(sanitized[key]);\n      }\n    }\n    \n    return sanitized;\n  }\n\n  private sanitizeUserAgent(userAgent?: string): string {\n    if (!userAgent) return '';\n    \n    // Remove potential sensitive information from user agent\n    return userAgent.substring(0, 200); // Limit length\n  }\n\n  private hashUserId(userId: string): string {\n    const crypto = require('crypto');\n    return crypto.createHash('sha256').update(userId).digest('hex').substring(0, 16);\n  }\n\n  private calculateDataAccessRisk(dataType: string, operation: string): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {\n    const sensitiveDataTypes = ['user', 'payment', 'pii', 'credential'];\n    const highRiskOperations = ['DELETE'];\n    \n    if (sensitiveDataTypes.some(type => dataType.toLowerCase().includes(type))) {\n      if (highRiskOperations.includes(operation)) {\n        return 'CRITICAL';\n      }\n      return 'HIGH';\n    }\n    \n    return operation === 'DELETE' ? 'MEDIUM' : 'LOW';\n  }\n\n  private calculateAuthRisk(eventType: string, result: string): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {\n    if (result === 'FAILURE') {\n      return eventType === 'FAILED_LOGIN' ? 'MEDIUM' : 'LOW';\n    }\n    \n    const highRiskEvents = ['PASSWORD_CHANGE', 'MFA_CHALLENGE'];\n    return highRiskEvents.includes(eventType) ? 'MEDIUM' : 'LOW';\n  }\n\n  private isSensitiveDataType(dataType: string): boolean {\n    const sensitiveTypes = ['user', 'payment', 'pii', 'credential', 'personal'];\n    return sensitiveTypes.some(type => dataType.toLowerCase().includes(type));\n  }\n\n  private isComplianceRelevantData(dataType: string): boolean {\n    const complianceTypes = ['payment', 'pii', 'health', 'financial'];\n    return complianceTypes.some(type => dataType.toLowerCase().includes(type));\n  }\n\n  private async alertSecurityIncident(logEntry: any): Promise<void> {\n    // Send alert to security team\n    this.logger.error('SECURITY INCIDENT ALERT', logEntry);\n    // Integration with alerting system would go here\n  }\n\n  private initializeSensitivePatterns(): RegExp[] {\n    return [\n      // Credit card numbers\n      /\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b/g,\n      // Social Security Numbers\n      /\\b\\d{3}-\\d{2}-\\d{4}\\b/g,\n      // Email addresses (partial masking)\n      /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g,\n      // Phone numbers\n      /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/g,\n      // Passwords in logs\n      /password[\"\\s]*[:=][\"\\s]*[^\"\\s,}]+/gi,\n      // API keys\n      /[\"\\s](sk|pk)_[a-zA-Z0-9]{20,}[\"\\s]/g,\n      // JWT tokens\n      /eyJ[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+/=]*/g,\n    ];\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"log-data-classification",children:"Log Data Classification"}),"\n",(0,s.jsx)(n.h3,{id:"log-classification-service",children:"Log Classification Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/logging/log-classification.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\ninterface LogClassification {\n  category: 'APPLICATION' | 'SECURITY' | 'AUDIT' | 'PERFORMANCE' | 'DEBUG';\n  sensitivity: 'PUBLIC' | 'INTERNAL' | 'CONFIDENTIAL' | 'RESTRICTED';\n  retention: {\n    period: number; // days\n    archiveAfter: number; // days\n    purgeAfter: number; // days\n  };\n  encryption: boolean;\n  accessControl: string[];\n  complianceRelevant: boolean;\n}\n\ninterface LogPolicy {\n  pattern: RegExp;\n  classification: LogClassification;\n  processingRules: string[];\n  monitoringRules: string[];\n}\n\n@Injectable()\nexport class LogClassificationService {\n  private readonly logger = new Logger(LogClassificationService.name);\n  private readonly logPolicies = new Map<string, LogPolicy>();\n\n  constructor() {\n    this.initializeLogPolicies();\n  }\n\n  classifyLog(logMessage: string, logLevel: string, source: string): LogClassification {\n    // Default classification\n    let classification: LogClassification = {\n      category: 'APPLICATION',\n      sensitivity: 'INTERNAL',\n      retention: { period: 30, archiveAfter: 90, purgeAfter: 365 },\n      encryption: false,\n      accessControl: ['developer', 'devops'],\n      complianceRelevant: false,\n    };\n\n    // Apply policy-based classification\n    for (const [policyId, policy] of this.logPolicies) {\n      if (policy.pattern.test(logMessage)) {\n        classification = { ...policy.classification };\n        break;\n      }\n    }\n\n    // Override based on log level\n    if (logLevel === 'ERROR' || logLevel === 'CRITICAL') {\n      classification.retention.period = Math.max(classification.retention.period, 90);\n    }\n\n    // Override based on source\n    if (source.includes('security') || source.includes('auth')) {\n      classification.category = 'SECURITY';\n      classification.retention.period = Math.max(classification.retention.period, 180);\n      classification.encryption = true;\n    }\n\n    return classification;\n  }\n\n  getRetentionPolicy(classification: LogClassification): {\n    retentionDays: number;\n    archiveDays: number;\n    purgeDays: number;\n  } {\n    return {\n      retentionDays: classification.retention.period,\n      archiveDays: classification.retention.archiveAfter,\n      purgeDays: classification.retention.purgeAfter,\n    };\n  }\n\n  shouldEncrypt(classification: LogClassification): boolean {\n    return classification.encryption || \n           classification.sensitivity === 'CONFIDENTIAL' || \n           classification.sensitivity === 'RESTRICTED';\n  }\n\n  getAccessControlList(classification: LogClassification): string[] {\n    return classification.accessControl;\n  }\n\n  isComplianceRelevant(classification: LogClassification): boolean {\n    return classification.complianceRelevant;\n  }\n\n  private initializeLogPolicies(): void {\n    const policies: Array<{ id: string; policy: LogPolicy }> = [\n      {\n        id: 'authentication_logs',\n        policy: {\n          pattern: /login|logout|authentication|password|credential/i,\n          classification: {\n            category: 'SECURITY',\n            sensitivity: 'CONFIDENTIAL',\n            retention: { period: 180, archiveAfter: 365, purgeAfter: 2555 }, // 7 years\n            encryption: true,\n            accessControl: ['security-team', 'compliance-officer'],\n            complianceRelevant: true,\n          },\n          processingRules: ['sanitize_credentials', 'hash_user_ids'],\n          monitoringRules: ['alert_failed_attempts', 'detect_anomalies'],\n        },\n      },\n      {\n        id: 'payment_logs',\n        policy: {\n          pattern: /payment|transaction|card|billing|purchase/i,\n          classification: {\n            category: 'AUDIT',\n            sensitivity: 'RESTRICTED',\n            retention: { period: 365, archiveAfter: 1095, purgeAfter: 3650 }, // 10 years\n            encryption: true,\n            accessControl: ['finance-team', 'compliance-officer', 'auditor'],\n            complianceRelevant: true,\n          },\n          processingRules: ['mask_payment_data', 'encrypt_sensitive_fields'],\n          monitoringRules: ['fraud_detection', 'compliance_monitoring'],\n        },\n      },\n      {\n        id: 'pii_logs',\n        policy: {\n          pattern: /email|phone|address|social|ssn|personal/i,\n          classification: {\n            category: 'AUDIT',\n            sensitivity: 'CONFIDENTIAL',\n            retention: { period: 90, archiveAfter: 365, purgeAfter: 2555 }, // 7 years\n            encryption: true,\n            accessControl: ['privacy-team', 'legal-team', 'compliance-officer'],\n            complianceRelevant: true,\n          },\n          processingRules: ['mask_pii', 'anonymize_data'],\n          monitoringRules: ['gdpr_compliance', 'data_breach_detection'],\n        },\n      },\n      {\n        id: 'application_errors',\n        policy: {\n          pattern: /error|exception|stack trace|failure/i,\n          classification: {\n            category: 'APPLICATION',\n            sensitivity: 'INTERNAL',\n            retention: { period: 90, archiveAfter: 180, purgeAfter: 365 },\n            encryption: false,\n            accessControl: ['developer', 'devops', 'support'],\n            complianceRelevant: false,\n          },\n          processingRules: ['sanitize_stack_traces', 'remove_sensitive_data'],\n          monitoringRules: ['error_rate_monitoring', 'alert_critical_errors'],\n        },\n      },\n      {\n        id: 'performance_logs',\n        policy: {\n          pattern: /performance|latency|response time|throughput/i,\n          classification: {\n            category: 'PERFORMANCE',\n            sensitivity: 'INTERNAL',\n            retention: { period: 30, archiveAfter: 90, purgeAfter: 180 },\n            encryption: false,\n            accessControl: ['developer', 'devops', 'sre'],\n            complianceRelevant: false,\n          },\n          processingRules: ['aggregate_metrics', 'compress_data'],\n          monitoringRules: ['performance_monitoring', 'capacity_planning'],\n        },\n      },\n    ];\n\n    policies.forEach(({ id, policy }) => {\n      this.logPolicies.set(id, policy);\n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"log-protection--encryption",children:"Log Protection & Encryption"}),"\n",(0,s.jsx)(n.h3,{id:"log-encryption-service",children:"Log Encryption Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/logging/log-encryption.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport * as crypto from 'crypto';\n\ninterface EncryptionConfig {\n  algorithm: string;\n  keyDerivation: string;\n  keyLength: number;\n  ivLength: number;\n  tagLength: number;\n}\n\ninterface EncryptedLog {\n  encryptedData: string;\n  iv: string;\n  tag: string;\n  keyId: string;\n  algorithm: string;\n  timestamp: string;\n}\n\n@Injectable()\nexport class LogEncryptionService {\n  private readonly logger = new Logger(LogEncryptionService.name);\n  private readonly encryptionConfig: EncryptionConfig;\n  private readonly encryptionKeys = new Map<string, Buffer>();\n\n  constructor(private configService: ConfigService) {\n    this.encryptionConfig = {\n      algorithm: 'aes-256-gcm',\n      keyDerivation: 'pbkdf2',\n      keyLength: 32,\n      ivLength: 12,\n      tagLength: 16,\n    };\n    this.initializeEncryptionKeys();\n  }\n\n  async encryptLog(logData: any, keyId: string = 'default'): Promise<EncryptedLog> {\n    const key = this.getEncryptionKey(keyId);\n    const iv = crypto.randomBytes(this.encryptionConfig.ivLength);\n    \n    const cipher = crypto.createCipher(this.encryptionConfig.algorithm, key);\n    cipher.setAAD(Buffer.from(keyId)); // Additional authenticated data\n    \n    const serializedData = JSON.stringify(logData);\n    const encrypted = Buffer.concat([\n      cipher.update(serializedData, 'utf8'),\n      cipher.final(),\n    ]);\n    \n    const tag = cipher.getAuthTag();\n    \n    return {\n      encryptedData: encrypted.toString('base64'),\n      iv: iv.toString('base64'),\n      tag: tag.toString('base64'),\n      keyId,\n      algorithm: this.encryptionConfig.algorithm,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async decryptLog(encryptedLog: EncryptedLog): Promise<any> {\n    const key = this.getEncryptionKey(encryptedLog.keyId);\n    const iv = Buffer.from(encryptedLog.iv, 'base64');\n    const tag = Buffer.from(encryptedLog.tag, 'base64');\n    const encryptedData = Buffer.from(encryptedLog.encryptedData, 'base64');\n    \n    const decipher = crypto.createDecipher(encryptedLog.algorithm, key);\n    decipher.setAAD(Buffer.from(encryptedLog.keyId));\n    decipher.setAuthTag(tag);\n    \n    const decrypted = Buffer.concat([\n      decipher.update(encryptedData),\n      decipher.final(),\n    ]);\n    \n    return JSON.parse(decrypted.toString('utf8'));\n  }\n\n  async encryptLogField(value: string, fieldType: 'PII' | 'CREDENTIAL' | 'SENSITIVE'): Promise<string> {\n    const keyId = this.getKeyIdForFieldType(fieldType);\n    const encrypted = await this.encryptLog({ value }, keyId);\n    return `ENC:${encrypted.keyId}:${encrypted.encryptedData}:${encrypted.iv}:${encrypted.tag}`;\n  }\n\n  async decryptLogField(encryptedValue: string): Promise<string> {\n    if (!encryptedValue.startsWith('ENC:')) {\n      return encryptedValue; // Not encrypted\n    }\n    \n    const parts = encryptedValue.substring(4).split(':');\n    if (parts.length !== 4) {\n      throw new Error('Invalid encrypted field format');\n    }\n    \n    const [keyId, encryptedData, iv, tag] = parts;\n    const encryptedLog: EncryptedLog = {\n      encryptedData,\n      iv,\n      tag,\n      keyId,\n      algorithm: this.encryptionConfig.algorithm,\n      timestamp: new Date().toISOString(),\n    };\n    \n    const decrypted = await this.decryptLog(encryptedLog);\n    return decrypted.value;\n  }\n\n  async rotateEncryptionKey(keyId: string): Promise<void> {\n    const newKey = this.generateEncryptionKey();\n    const oldKey = this.encryptionKeys.get(keyId);\n    \n    if (oldKey) {\n      // Store old key for decryption of existing logs\n      this.encryptionKeys.set(`${keyId}_old_${Date.now()}`, oldKey);\n    }\n    \n    this.encryptionKeys.set(keyId, newKey);\n    \n    this.logger.log(`Encryption key rotated for keyId: ${keyId}`);\n  }\n\n  async setupLogEncryption(): Promise<void> {\n    // Create encryption keys for different log types\n    await this.createEncryptionKey('audit_logs');\n    await this.createEncryptionKey('security_logs');\n    await this.createEncryptionKey('pii_logs');\n    await this.createEncryptionKey('payment_logs');\n    \n    this.logger.log('Log encryption setup completed');\n  }\n\n  private getEncryptionKey(keyId: string): Buffer {\n    const key = this.encryptionKeys.get(keyId);\n    if (!key) {\n      throw new Error(`Encryption key not found: ${keyId}`);\n    }\n    return key;\n  }\n\n  private generateEncryptionKey(): Buffer {\n    return crypto.randomBytes(this.encryptionConfig.keyLength);\n  }\n\n  private async createEncryptionKey(keyId: string): Promise<void> {\n    if (!this.encryptionKeys.has(keyId)) {\n      const key = this.generateEncryptionKey();\n      this.encryptionKeys.set(keyId, key);\n      \n      // In production, keys should be stored in a secure key management service\n      await this.storeKeySecurely(keyId, key);\n    }\n  }\n\n  private async storeKeySecurely(keyId: string, key: Buffer): Promise<void> {\n    // In production, integrate with Google Cloud KMS or similar\n    // For now, we'll just log that the key should be stored\n    this.logger.log(`Encryption key generated for ${keyId} - should be stored in KMS`);\n  }\n\n  private getKeyIdForFieldType(fieldType: string): string {\n    const keyMapping = {\n      'PII': 'pii_logs',\n      'CREDENTIAL': 'security_logs',\n      'SENSITIVE': 'audit_logs',\n    };\n    \n    return keyMapping[fieldType] || 'default';\n  }\n\n  private initializeEncryptionKeys(): void {\n    // Initialize default encryption key\n    const defaultKey = this.generateEncryptionKey();\n    this.encryptionKeys.set('default', defaultKey);\n    \n    // In production, load keys from secure storage\n    this.loadKeysFromSecureStorage();\n  }\n\n  private async loadKeysFromSecureStorage(): Promise<void> {\n    // Load encryption keys from Google Cloud KMS or similar\n    // For now, generate them locally\n    await this.setupLogEncryption();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"access-controls--monitoring",children:"Access Controls & Monitoring"}),"\n",(0,s.jsx)(n.h3,{id:"log-access-control-service",children:"Log Access Control Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/logging/log-access-control.service.ts\nimport { Injectable, Logger, UnauthorizedException } from '@nestjs/common';\n\ninterface LogAccessRequest {\n  userId: string;\n  logCategory: string;\n  logLevel: string;\n  timeRange: {\n    start: Date;\n    end: Date;\n  };\n  purpose: string;\n  requiredApproval?: boolean;\n}\n\ninterface LogAccessPolicy {\n  logCategory: string;\n  allowedRoles: string[];\n  restrictions: {\n    maxTimeRange: number; // days\n    requiresApproval: boolean;\n    approvalRoles: string[];\n    allowedOperations: ('READ' | 'SEARCH' | 'EXPORT')[];\n  };\n  auditRequired: boolean;\n}\n\n@Injectable()\nexport class LogAccessControlService {\n  private readonly logger = new Logger(LogAccessControlService.name);\n  private readonly accessPolicies = new Map<string, LogAccessPolicy>();\n\n  constructor() {\n    this.initializeAccessPolicies();\n  }\n\n  async requestLogAccess(request: LogAccessRequest): Promise<string> {\n    // Validate user permissions\n    await this.validateLogAccess(request);\n    \n    // Check if approval is required\n    const policy = this.getAccessPolicy(request.logCategory);\n    if (policy?.restrictions.requiresApproval) {\n      return await this.requestApproval(request);\n    }\n    \n    // Grant immediate access\n    const accessToken = this.generateAccessToken(request);\n    await this.auditLogAccess(request, 'GRANTED', accessToken);\n    \n    return accessToken;\n  }\n\n  async validateLogAccess(request: LogAccessRequest): Promise<void> {\n    const userRoles = await this.getUserRoles(request.userId);\n    const policy = this.getAccessPolicy(request.logCategory);\n    \n    if (!policy) {\n      throw new UnauthorizedException(`No access policy for log category: ${request.logCategory}`);\n    }\n    \n    // Check role permissions\n    const hasRequiredRole = policy.allowedRoles.some(role => userRoles.includes(role));\n    if (!hasRequiredRole) {\n      throw new UnauthorizedException(`Insufficient permissions for log category: ${request.logCategory}`);\n    }\n    \n    // Check time range restrictions\n    const requestedDays = this.calculateDaysBetween(request.timeRange.start, request.timeRange.end);\n    if (requestedDays > policy.restrictions.maxTimeRange) {\n      throw new UnauthorizedException(\n        `Requested time range (${requestedDays} days) exceeds maximum allowed (${policy.restrictions.maxTimeRange} days)`\n      );\n    }\n    \n    // Additional security checks\n    await this.performSecurityChecks(request);\n  }\n\n  async auditLogAccess(\n    request: LogAccessRequest,\n    result: 'GRANTED' | 'DENIED' | 'REVOKED',\n    accessToken?: string\n  ): Promise<void> {\n    const auditEntry = {\n      timestamp: new Date().toISOString(),\n      userId: request.userId,\n      action: 'LOG_ACCESS_REQUEST',\n      logCategory: request.logCategory,\n      logLevel: request.logLevel,\n      timeRange: request.timeRange,\n      purpose: request.purpose,\n      result,\n      accessToken: accessToken ? this.hashToken(accessToken) : undefined,\n    };\n    \n    this.logger.log(`Log access audit: ${JSON.stringify(auditEntry)}`);\n  }\n\n  async revokeLogAccess(accessToken: string, reason: string): Promise<void> {\n    // Revoke the access token\n    await this.invalidateAccessToken(accessToken);\n    \n    // Audit the revocation\n    const auditEntry = {\n      timestamp: new Date().toISOString(),\n      action: 'LOG_ACCESS_REVOKED',\n      accessToken: this.hashToken(accessToken),\n      reason,\n    };\n    \n    this.logger.log(`Log access revoked: ${JSON.stringify(auditEntry)}`);\n  }\n\n  async monitorLogAccess(): Promise<void> {\n    // Monitor for suspicious log access patterns\n    await this.detectAnomalousAccess();\n    await this.checkComplianceViolations();\n    await this.generateAccessReport();\n  }\n\n  private getAccessPolicy(logCategory: string): LogAccessPolicy | undefined {\n    return this.accessPolicies.get(logCategory);\n  }\n\n  private async getUserRoles(userId: string): Promise<string[]> {\n    // Get user roles from identity provider\n    // Placeholder implementation\n    return ['developer']; // This would be replaced with actual role lookup\n  }\n\n  private async requestApproval(request: LogAccessRequest): Promise<string> {\n    // Create approval request\n    const approvalId = this.generateApprovalId();\n    \n    // Send for approval\n    await this.sendForApproval(request, approvalId);\n    \n    return approvalId;\n  }\n\n  private generateAccessToken(request: LogAccessRequest): string {\n    const crypto = require('crypto');\n    const tokenData = {\n      userId: request.userId,\n      logCategory: request.logCategory,\n      timeRange: request.timeRange,\n      issuedAt: new Date().toISOString(),\n      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours\n    };\n    \n    return crypto.createHash('sha256').update(JSON.stringify(tokenData)).digest('hex');\n  }\n\n  private generateApprovalId(): string {\n    return `APPR-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`.toUpperCase();\n  }\n\n  private hashToken(token: string): string {\n    const crypto = require('crypto');\n    return crypto.createHash('sha256').update(token).digest('hex').substring(0, 16);\n  }\n\n  private calculateDaysBetween(start: Date, end: Date): number {\n    const diffTime = Math.abs(end.getTime() - start.getTime());\n    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n  }\n\n  private async performSecurityChecks(request: LogAccessRequest): Promise<void> {\n    // Check for unusual access patterns\n    const recentRequests = await this.getRecentLogAccessRequests(request.userId);\n    \n    if (recentRequests.length > 10) {\n      throw new UnauthorizedException('Too many log access requests in short period');\n    }\n    \n    // Check for high-risk log categories\n    const highRiskCategories = ['security_logs', 'audit_logs', 'payment_logs'];\n    if (highRiskCategories.includes(request.logCategory)) {\n      await this.performAdditionalVerification(request);\n    }\n  }\n\n  private async performAdditionalVerification(request: LogAccessRequest): Promise<void> {\n    // Additional verification for high-risk log access\n    this.logger.warn(`High-risk log access request: ${JSON.stringify(request)}`);\n  }\n\n  private async getRecentLogAccessRequests(userId: string): Promise<any[]> {\n    // Get recent log access requests for the user\n    return []; // Placeholder\n  }\n\n  private async sendForApproval(request: LogAccessRequest, approvalId: string): Promise<void> {\n    // Send approval request to designated approvers\n    this.logger.log(`Sending log access request for approval: ${approvalId}`);\n  }\n\n  private async invalidateAccessToken(accessToken: string): Promise<void> {\n    // Invalidate the access token\n    this.logger.log(`Access token invalidated: ${this.hashToken(accessToken)}`);\n  }\n\n  private async detectAnomalousAccess(): Promise<void> {\n    // Detect anomalous log access patterns\n    this.logger.log('Monitoring for anomalous log access patterns');\n  }\n\n  private async checkComplianceViolations(): Promise<void> {\n    // Check for compliance violations in log access\n    this.logger.log('Checking for log access compliance violations');\n  }\n\n  private async generateAccessReport(): Promise<void> {\n    // Generate log access report\n    this.logger.log('Generating log access report');\n  }\n\n  private initializeAccessPolicies(): void {\n    const policies: Array<{ category: string; policy: LogAccessPolicy }> = [\n      {\n        category: 'application_logs',\n        policy: {\n          logCategory: 'application_logs',\n          allowedRoles: ['developer', 'devops', 'support'],\n          restrictions: {\n            maxTimeRange: 30,\n            requiresApproval: false,\n            approvalRoles: [],\n            allowedOperations: ['READ', 'SEARCH'],\n          },\n          auditRequired: false,\n        },\n      },\n      {\n        category: 'security_logs',\n        policy: {\n          logCategory: 'security_logs',\n          allowedRoles: ['security-engineer', 'security-lead', 'compliance-officer'],\n          restrictions: {\n            maxTimeRange: 90,\n            requiresApproval: true,\n            approvalRoles: ['security-lead', 'ciso'],\n            allowedOperations: ['READ', 'SEARCH', 'EXPORT'],\n          },\n          auditRequired: true,\n        },\n      },\n      {\n        category: 'audit_logs',\n        policy: {\n          logCategory: 'audit_logs',\n          allowedRoles: ['auditor', 'compliance-officer', 'legal-team'],\n          restrictions: {\n            maxTimeRange: 365,\n            requiresApproval: true,\n            approvalRoles: ['compliance-officer', 'legal-lead'],\n            allowedOperations: ['READ', 'SEARCH', 'EXPORT'],\n          },\n          auditRequired: true,\n        },\n      },\n      {\n        category: 'payment_logs',\n        policy: {\n          logCategory: 'payment_logs',\n          allowedRoles: ['finance-team', 'compliance-officer', 'auditor'],\n          restrictions: {\n            maxTimeRange: 180,\n            requiresApproval: true,\n            approvalRoles: ['finance-lead', 'compliance-officer'],\n            allowedOperations: ['READ', 'SEARCH'],\n          },\n          auditRequired: true,\n        },\n      },\n    ];\n\n    policies.forEach(({ category, policy }) => {\n      this.accessPolicies.set(category, policy);\n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"retention--compliance",children:"Retention & Compliance"}),"\n",(0,s.jsx)(n.h3,{id:"log-retention-management",children:"Log Retention Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# scripts/log-retention-management.sh\n\nset -e\n\nPROJECT_ID=${1:-"your-project-id"}\nENVIRONMENT=${2:-"production"}\n\necho "Setting up log retention management for project: $PROJECT_ID"\n\n# Create Cloud Storage buckets for log archival\ngsutil mb -p $PROJECT_ID -l us-central1 gs://$PROJECT_ID-log-archive-$ENVIRONMENT\ngsutil mb -p $PROJECT_ID -l us-central1 gs://$PROJECT_ID-log-cold-storage-$ENVIRONMENT\n\n# Set lifecycle policies for log retention\ncat > log-lifecycle-policy.json << EOF\n{\n  "lifecycle": {\n    "rule": [\n      {\n        "action": {"type": "SetStorageClass", "storageClass": "NEARLINE"},\n        "condition": {"age": 30}\n      },\n      {\n        "action": {"type": "SetStorageClass", "storageClass": "COLDLINE"},\n        "condition": {"age": 90}\n      },\n      {\n        "action": {"type": "SetStorageClass", "storageClass": "ARCHIVE"},\n        "condition": {"age": 365}\n      },\n      {\n        "action": {"type": "Delete"},\n        "condition": {"age": 2555}\n      }\n    ]\n  }\n}\nEOF\n\n# Apply lifecycle policies\ngsutil lifecycle set log-lifecycle-policy.json gs://$PROJECT_ID-log-archive-$ENVIRONMENT\ngsutil lifecycle set log-lifecycle-policy.json gs://$PROJECT_ID-log-cold-storage-$ENVIRONMENT\n\n# Set up log sinks for different log categories\ngcloud logging sinks create security-logs-sink \\\n    storage.googleapis.com/$PROJECT_ID-log-archive-$ENVIRONMENT/security-logs \\\n    --log-filter=\'resource.type="k8s_container" AND logName="projects/\'$PROJECT_ID\'/logs/security-events"\'\n\ngcloud logging sinks create audit-logs-sink \\\n    storage.googleapis.com/$PROJECT_ID-log-archive-$ENVIRONMENT/audit-logs \\\n    --log-filter=\'resource.type="k8s_container" AND logName="projects/\'$PROJECT_ID\'/logs/audit-logs"\'\n\ngcloud logging sinks create application-logs-sink \\\n    storage.googleapis.com/$PROJECT_ID-log-archive-$ENVIRONMENT/application-logs \\\n    --log-filter=\'resource.type="k8s_container" AND logName="projects/\'$PROJECT_ID\'/logs/application-logs"\'\n\n# Set up BigQuery datasets for log analytics\nbq mk --dataset --location=US $PROJECT_ID:log_analytics_$ENVIRONMENT\n\n# Create log export jobs\ncat > log-export-config.json << EOF\n{\n  "destinationTable": {\n    "projectId": "$PROJECT_ID",\n    "datasetId": "log_analytics_$ENVIRONMENT",\n    "tableId": "security_logs"\n  },\n  "filter": "resource.type=\\"k8s_container\\" AND logName=\\"projects/$PROJECT_ID/logs/security-events\\"",\n  "description": "Export security logs to BigQuery for analysis"\n}\nEOF\n\necho "Log retention management setup completed for: $PROJECT_ID"\n'})}),"\n",(0,s.jsx)(n.p,{children:"This comprehensive log data security implementation provides:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Secure logging architecture"})," with centralized logging and proper log classification"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Log data classification"})," with sensitivity levels and retention policies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Log protection and encryption"})," with field-level encryption and key management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Access controls and monitoring"})," with role-based access and audit trails"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Retention and compliance"})," with automated lifecycle management and regulatory compliance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Log security monitoring"})," with anomaly detection and security event correlation"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The implementation ensures that all log data is properly classified, protected, and managed according to security and compliance requirements."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}}}]);