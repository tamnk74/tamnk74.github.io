"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[6598],{473:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>l});var t=r(1151),s=r(5813),i=r(7814);const o={slug:"nestjs-auth-microservices-gcp-kubernetes",title:"Building Secure Microservices: Authentication & Authorization with NestJS on GCP Kubernetes",authors:["tam"],tags:["nestjs","microservices","authentication","authorization","gcp","kubernetes","jwt","rbac","security","docker"]},a=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Core Security Concepts",id:"core-security-concepts",level:2},{value:"Authentication vs Authorization",id:"authentication-vs-authorization",level:3},{value:"Authorization Models We&#39;ll Implement",id:"authorization-models-well-implement",level:3},{value:"Project Setup and Structure",id:"project-setup-and-structure",level:2},{value:"Project Structure",id:"project-structure",level:3},{value:"Authentication Service Implementation",id:"authentication-service-implementation",level:2},{value:"Core Authentication Service",id:"core-authentication-service",level:3},{value:"Database Entities",id:"database-entities",level:3},{value:"Authorization Implementation",id:"authorization-implementation",level:2},{value:"Guards and Decorators",id:"guards-and-decorators",level:3},{value:"Advanced Authorization with Resource Access",id:"advanced-authorization-with-resource-access",level:3},{value:"API Gateway Implementation",id:"api-gateway-implementation",level:2},{value:"Service Implementation Examples",id:"service-implementation-examples",level:2},{value:"Order Service with Authorization",id:"order-service-with-authorization",level:3},{value:"Kubernetes Deployment Configuration",id:"kubernetes-deployment-configuration",level:2},{value:"Namespace and RBAC",id:"namespace-and-rbac",level:3},{value:"ConfigMaps and Secrets",id:"configmaps-and-secrets",level:3},{value:"Service Deployments",id:"service-deployments",level:3},{value:"Istio Service Mesh Configuration",id:"istio-service-mesh-configuration",level:3},{value:"Authorization Policies with Istio",id:"authorization-policies-with-istio",level:3},{value:"Database Migrations and Setup",id:"database-migrations-and-setup",level:2},{value:"Deployment Scripts",id:"deployment-scripts",level:2},{value:"Security Best Practices Summary",id:"security-best-practices-summary",level:2},{value:"1. <strong>Authentication Security</strong>",id:"1-authentication-security",level:3},{value:"2. <strong>Authorization Security</strong>",id:"2-authorization-security",level:3},{value:"3. <strong>Infrastructure Security</strong>",id:"3-infrastructure-security",level:3},{value:"4. <strong>API Security</strong>",id:"4-api-security",level:3},{value:"5. <strong>Container Security</strong>",id:"5-container-security",level:3},{value:"6. <strong>Monitoring and Observability</strong>",id:"6-monitoring-and-observability",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Further Resources",id:"further-resources",level:2}];function u(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Building secure microservices with proper authentication and authorization is one of the most critical aspects of modern application development. When deploying to Google Cloud Platform (GCP) Kubernetes, we need to consider not only the application-level security patterns but also the infrastructure and container orchestration security layers."}),"\n",(0,s.jsx)(n.p,{children:"This comprehensive guide demonstrates how to implement robust authentication and authorization in a NestJS microservices architecture deployed on GCP Kubernetes, incorporating enterprise-grade security patterns including RBAC, JWT tokens, service mesh security, and cloud-native best practices."}),"\n",(0,s.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,s.jsx)(n.p,{children:"Before diving into implementation, let's establish our target architecture based on microservices security best practices:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   React UI      \u2502    \u2502   Mobile App    \u2502    \u2502   Third-party   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                      \u2502                      \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502             API Gateway / BFF                  \u2502\n          \u2502         (NestJS Gateway Service)               \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502              Service Mesh (Istio)              \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502             \u2502             \u2502             \u2502             \u2502\n\u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510\n\u2502 Auth  \u2502    \u2502 User  \u2502    \u2502Product\u2502    \u2502 Order \u2502    \u2502Payment\u2502\n\u2502Service\u2502    \u2502Service\u2502    \u2502Service\u2502    \u2502Service\u2502    \u2502Service\u2502\n\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\n    \u2502            \u2502            \u2502            \u2502            \u2502\n\u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510\n\u2502Auth DB\u2502    \u2502User DB\u2502    \u2502Prod DB\u2502    \u2502Order \u2502    \u2502Pay DB \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502  DB   \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h2,{id:"core-security-concepts",children:"Core Security Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"authentication-vs-authorization",children:"Authentication vs Authorization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authentication"}),": Verifying who the user is (identity verification)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authorization"}),": Determining what the authenticated user can do (access control)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"authorization-models-well-implement",children:"Authorization Models We'll Implement"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RBAC (Role-Based Access Control)"}),": Users have roles, roles have permissions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ReBAC (Relationship-Based Access Control)"}),": Access based on user's relationship to resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ABAC (Attribute-Based Access Control)"}),": Access based on user, resource, and environment attributes"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"project-setup-and-structure",children:"Project Setup and Structure"}),"\n",(0,s.jsx)(n.p,{children:"Let's start by setting up our NestJS microservices project structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Create the monorepo structure\nmkdir ecommerce-microservices\ncd ecommerce-microservices\n\n# Initialize the NestJS workspace\nnpx @nestjs/cli new . --package-manager npm\nnpm install @nestjs/microservices @nestjs/jwt @nestjs/passport\nnpm install passport passport-jwt passport-local bcryptjs\nnpm install @nestjs/config @nestjs/typeorm typeorm pg\nnpm install class-validator class-transformer\nnpm install @google-cloud/secret-manager\nnpm install helmet compression morgan\n"})}),"\n",(0,s.jsx)(n.h3,{id:"project-structure",children:"Project Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ecommerce-microservices/\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 api-gateway/          # BFF/API Gateway\n\u2502   \u251c\u2500\u2500 auth-service/         # Authentication service\n\u2502   \u251c\u2500\u2500 user-service/         # User management\n\u2502   \u251c\u2500\u2500 product-service/      # Product catalog\n\u2502   \u251c\u2500\u2500 order-service/        # Order management\n\u2502   \u2514\u2500\u2500 payment-service/      # Payment processing\n\u251c\u2500\u2500 libs/\n\u2502   \u251c\u2500\u2500 common/              # Shared utilities\n\u2502   \u251c\u2500\u2500 database/            # Database configurations\n\u2502   \u251c\u2500\u2500 auth/                # Authentication guards/decorators\n\u2502   \u2514\u2500\u2500 security/            # Security middleware\n\u251c\u2500\u2500 k8s/                     # Kubernetes manifests\n\u251c\u2500\u2500 docker/                  # Dockerfiles\n\u2514\u2500\u2500 scripts/                 # Deployment scripts\n"})}),"\n",(0,s.jsx)(n.h2,{id:"authentication-service-implementation",children:"Authentication Service Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"core-authentication-service",children:"Core Authentication Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// apps/auth-service/src/auth.service.ts\nimport { Injectable, UnauthorizedException, ConflictException } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport * as bcrypt from 'bcryptjs';\nimport { User } from './entities/user.entity';\nimport { Role } from './entities/role.entity';\nimport { Permission } from './entities/permission.entity';\n\nexport interface JwtPayload {\n  sub: string;\n  email: string;\n  roles: string[];\n  permissions: string[];\n  companyId?: string;\n  departmentId?: string;\n  iat?: number;\n  exp?: number;\n}\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    @InjectRepository(User)\n    private readonly userRepository: Repository<User>,\n    @InjectRepository(Role)\n    private readonly roleRepository: Repository<Role>,\n    private readonly jwtService: JwtService,\n  ) {}\n\n  async register(registerDto: RegisterDto): Promise<{ user: User; tokens: TokenPair }> {\n    // Check if user already exists\n    const existingUser = await this.userRepository.findOne({\n      where: { email: registerDto.email }\n    });\n\n    if (existingUser) {\n      throw new ConflictException('User with this email already exists');\n    }\n\n    // Hash password\n    const saltRounds = 12;\n    const hashedPassword = await bcrypt.hash(registerDto.password, saltRounds);\n\n    // Create user with default role\n    const defaultRole = await this.roleRepository.findOne({\n      where: { name: 'USER' },\n      relations: ['permissions']\n    });\n\n    const user = this.userRepository.create({\n      ...registerDto,\n      password: hashedPassword,\n      roles: defaultRole ? [defaultRole] : [],\n      isActive: true,\n      emailVerified: false,\n    });\n\n    const savedUser = await this.userRepository.save(user);\n    \n    // Generate tokens\n    const tokens = await this.generateTokens(savedUser);\n    \n    // Remove password from response\n    delete savedUser.password;\n\n    return { user: savedUser, tokens };\n  }\n\n  async login(loginDto: LoginDto): Promise<{ user: User; tokens: TokenPair }> {\n    // Find user with roles and permissions\n    const user = await this.userRepository.findOne({\n      where: { email: loginDto.email },\n      relations: ['roles', 'roles.permissions', 'company', 'department']\n    });\n\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Check if user is active\n    if (!user.isActive) {\n      throw new UnauthorizedException('Account is deactivated');\n    }\n\n    // Verify password\n    const isPasswordValid = await bcrypt.compare(loginDto.password, user.password);\n    if (!isPasswordValid) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Update last login\n    user.lastLoginAt = new Date();\n    await this.userRepository.save(user);\n\n    // Generate tokens\n    const tokens = await this.generateTokens(user);\n    \n    // Remove password from response\n    delete user.password;\n\n    return { user, tokens };\n  }\n\n  async generateTokens(user: User): Promise<TokenPair> {\n    const roles = user.roles?.map(role => role.name) || [];\n    const permissions = user.roles?.flatMap(role => \n      role.permissions?.map(permission => permission.name) || []\n    ) || [];\n\n    const payload: JwtPayload = {\n      sub: user.id,\n      email: user.email,\n      roles,\n      permissions,\n      companyId: user.company?.id,\n      departmentId: user.department?.id,\n    };\n\n    const [accessToken, refreshToken] = await Promise.all([\n      this.jwtService.signAsync(payload, {\n        secret: process.env.JWT_ACCESS_SECRET,\n        expiresIn: process.env.JWT_ACCESS_EXPIRES_IN || '15m',\n      }),\n      this.jwtService.signAsync(\n        { sub: user.id, type: 'refresh' }, \n        {\n          secret: process.env.JWT_REFRESH_SECRET,\n          expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d',\n        }\n      ),\n    ]);\n\n    return { accessToken, refreshToken };\n  }\n\n  async refreshTokens(refreshToken: string): Promise<TokenPair> {\n    try {\n      const payload = await this.jwtService.verifyAsync(refreshToken, {\n        secret: process.env.JWT_REFRESH_SECRET,\n      });\n\n      if (payload.type !== 'refresh') {\n        throw new UnauthorizedException('Invalid token type');\n      }\n\n      const user = await this.userRepository.findOne({\n        where: { id: payload.sub },\n        relations: ['roles', 'roles.permissions', 'company', 'department']\n      });\n\n      if (!user || !user.isActive) {\n        throw new UnauthorizedException('User not found or inactive');\n      }\n\n      return this.generateTokens(user);\n    } catch (error) {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n  }\n\n  async validateUser(userId: string): Promise<User | null> {\n    return this.userRepository.findOne({\n      where: { id: userId },\n      relations: ['roles', 'roles.permissions', 'company', 'department']\n    });\n  }\n\n  async logout(userId: string): Promise<void> {\n    // In a production environment, you might want to blacklist the JWT\n    // or store logout events for audit purposes\n    await this.userRepository.update(userId, { \n      lastLogoutAt: new Date() \n    });\n  }\n}\n\ninterface TokenPair {\n  accessToken: string;\n  refreshToken: string;\n}\n\n// DTOs\nexport class RegisterDto {\n  email: string;\n  password: string;\n  firstName: string;\n  lastName: string;\n  companyId?: string;\n  departmentId?: string;\n}\n\nexport class LoginDto {\n  email: string;\n  password: string;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"database-entities",children:"Database Entities"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// apps/auth-service/src/entities/user.entity.ts\nimport { Entity, PrimaryGeneratedColumn, Column, ManyToMany, ManyToOne, JoinTable, CreateDateColumn, UpdateDateColumn } from 'typeorm';\nimport { Role } from './role.entity';\nimport { Company } from './company.entity';\nimport { Department } from './department.entity';\n\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ unique: true })\n  email: string;\n\n  @Column()\n  password: string;\n\n  @Column()\n  firstName: string;\n\n  @Column()\n  lastName: string;\n\n  @Column({ default: true })\n  isActive: boolean;\n\n  @Column({ default: false })\n  emailVerified: boolean;\n\n  @Column({ nullable: true })\n  phoneNumber: string;\n\n  @Column({ nullable: true })\n  avatarUrl: string;\n\n  @Column({ nullable: true })\n  lastLoginAt: Date;\n\n  @Column({ nullable: true })\n  lastLogoutAt: Date;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  @ManyToMany(() => Role, role => role.users, { eager: true })\n  @JoinTable({\n    name: 'user_roles',\n    joinColumn: { name: 'userId', referencedColumnName: 'id' },\n    inverseJoinColumn: { name: 'roleId', referencedColumnName: 'id' }\n  })\n  roles: Role[];\n\n  @ManyToOne(() => Company, company => company.users)\n  company: Company;\n\n  @ManyToOne(() => Department, department => department.users)\n  department: Department;\n}\n\n// apps/auth-service/src/entities/role.entity.ts\n@Entity('roles')\nexport class Role {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ unique: true })\n  name: string;\n\n  @Column({ nullable: true })\n  description: string;\n\n  @Column({ default: true })\n  isActive: boolean;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  @ManyToMany(() => User, user => user.roles)\n  users: User[];\n\n  @ManyToMany(() => Permission, permission => permission.roles, { eager: true })\n  @JoinTable({\n    name: 'role_permissions',\n    joinColumn: { name: 'roleId', referencedColumnName: 'id' },\n    inverseJoinColumn: { name: 'permissionId', referencedColumnName: 'id' }\n  })\n  permissions: Permission[];\n}\n\n// apps/auth-service/src/entities/permission.entity.ts\n@Entity('permissions')\nexport class Permission {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ unique: true })\n  name: string;\n\n  @Column({ nullable: true })\n  description: string;\n\n  @Column()\n  resource: string; // e.g., 'orders', 'products', 'users'\n\n  @Column()\n  action: string; // e.g., 'create', 'read', 'update', 'delete'\n\n  @Column({ default: true })\n  isActive: boolean;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  @ManyToMany(() => Role, role => role.permissions)\n  roles: Role[];\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"authorization-implementation",children:"Authorization Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"guards-and-decorators",children:"Guards and Decorators"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// libs/auth/src/guards/jwt-auth.guard.ts\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\nimport { ExecutionContext } from '@nestjs/common';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  canActivate(context: ExecutionContext) {\n    return super.canActivate(context);\n  }\n\n  handleRequest(err: any, user: any, info: any, context: ExecutionContext) {\n    if (err || !user) {\n      throw err || new UnauthorizedException('Invalid or expired token');\n    }\n    return user;\n  }\n}\n\n// libs/auth/src/guards/roles.guard.ts\nimport { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { ROLES_KEY } from '../decorators/roles.decorator';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredRoles) {\n      return true;\n    }\n\n    const { user } = context.switchToHttp().getRequest();\n    if (!user) {\n      throw new ForbiddenException('User not authenticated');\n    }\n\n    const hasRole = requiredRoles.some(role => user.roles?.includes(role));\n    \n    if (!hasRole) {\n      throw new ForbiddenException(`Required roles: ${requiredRoles.join(', ')}`);\n    }\n\n    return true;\n  }\n}\n\n// libs/auth/src/guards/permissions.guard.ts\nimport { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { PERMISSIONS_KEY } from '../decorators/permissions.decorator';\n\n@Injectable()\nexport class PermissionsGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredPermissions = this.reflector.getAllAndOverride<string[]>(PERMISSIONS_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredPermissions) {\n      return true;\n    }\n\n    const { user } = context.switchToHttp().getRequest();\n    if (!user) {\n      throw new ForbiddenException('User not authenticated');\n    }\n\n    const hasPermission = requiredPermissions.every(permission => \n      user.permissions?.includes(permission)\n    );\n    \n    if (!hasPermission) {\n      throw new ForbiddenException(`Required permissions: ${requiredPermissions.join(', ')}`);\n    }\n\n    return true;\n  }\n}\n\n// libs/auth/src/decorators/roles.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);\n\n// libs/auth/src/decorators/permissions.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const PERMISSIONS_KEY = 'permissions';\nexport const RequirePermissions = (...permissions: string[]) => \n  SetMetadata(PERMISSIONS_KEY, permissions);\n\n// libs/auth/src/decorators/current-user.decorator.ts\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const CurrentUser = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return request.user;\n  },\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-authorization-with-resource-access",children:"Advanced Authorization with Resource Access"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// libs/auth/src/guards/resource-access.guard.ts\nimport { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { ClientProxy } from '@nestjs/microservices';\nimport { Inject } from '@nestjs/common';\nimport { firstValueFrom } from 'rxjs';\n\nexport interface ResourceAccessConfig {\n  resource: string;\n  action: string;\n  ownershipField?: string;\n  companyScoped?: boolean;\n  departmentScoped?: boolean;\n}\n\nexport const RESOURCE_ACCESS_KEY = 'resource_access';\nexport const ResourceAccess = (config: ResourceAccessConfig) => \n  SetMetadata(RESOURCE_ACCESS_KEY, config);\n\n@Injectable()\nexport class ResourceAccessGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    @Inject('USER_SERVICE') private userServiceClient: ClientProxy,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const config = this.reflector.getAllAndOverride<ResourceAccessConfig>(\n      RESOURCE_ACCESS_KEY,\n      [context.getHandler(), context.getClass()],\n    );\n\n    if (!config) {\n      return true;\n    }\n\n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n\n    if (!user) {\n      throw new ForbiddenException('User not authenticated');\n    }\n\n    // Check basic permission\n    const hasPermission = user.permissions?.includes(`${config.resource}:${config.action}`);\n    if (!hasPermission) {\n      throw new ForbiddenException(`Permission denied: ${config.resource}:${config.action}`);\n    }\n\n    // Check ownership if configured\n    if (config.ownershipField) {\n      const resourceId = request.params.id || request.body[config.ownershipField];\n      if (resourceId) {\n        const hasAccess = await this.checkResourceAccess(\n          user,\n          config.resource,\n          resourceId,\n          config\n        );\n        if (!hasAccess) {\n          throw new ForbiddenException('Access denied to this resource');\n        }\n      }\n    }\n\n    return true;\n  }\n\n  private async checkResourceAccess(\n    user: any,\n    resource: string,\n    resourceId: string,\n    config: ResourceAccessConfig\n  ): Promise<boolean> {\n    try {\n      const result = await firstValueFrom(\n        this.userServiceClient.send('check_resource_access', {\n          userId: user.sub,\n          resource,\n          resourceId,\n          config,\n        })\n      );\n      return result.hasAccess;\n    } catch (error) {\n      console.error('Error checking resource access:', error);\n      return false;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"api-gateway-implementation",children:"API Gateway Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// apps/api-gateway/src/main.ts\nimport { NestFactory } from '@nestjs/core';\nimport { ValidationPipe } from '@nestjs/common';\nimport { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';\nimport helmet from 'helmet';\nimport * as compression from 'compression';\nimport * as morgan from 'morgan';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  // Security middleware\n  app.use(helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\"'self'\", \"'unsafe-inline'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        imgSrc: [\"'self'\", \"data:\", \"https:\"],\n      },\n    },\n    hsts: {\n      maxAge: 31536000,\n      includeSubDomains: true,\n      preload: true,\n    },\n  }));\n\n  app.use(compression());\n  app.use(morgan('combined'));\n\n  // Enable CORS\n  app.enableCors({\n    origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],\n    allowedHeaders: ['Content-Type', 'Authorization'],\n    credentials: true,\n  });\n\n  // Global validation pipe\n  app.useGlobalPipes(new ValidationPipe({\n    whitelist: true,\n    forbidNonWhitelisted: true,\n    transform: true,\n  }));\n\n  // Swagger documentation\n  const config = new DocumentBuilder()\n    .setTitle('E-commerce Microservices API')\n    .setDescription('Secure microservices API with authentication and authorization')\n    .setVersion('1.0')\n    .addBearerAuth(\n      {\n        type: 'http',\n        scheme: 'bearer',\n        bearerFormat: 'JWT',\n        name: 'JWT',\n        description: 'Enter JWT token',\n        in: 'header',\n      },\n      'JWT-auth',\n    )\n    .build();\n\n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api', app, document);\n\n  const port = process.env.PORT || 3000;\n  await app.listen(port, '0.0.0.0');\n  console.log(`API Gateway is running on: http://localhost:${port}`);\n}\n\nbootstrap();\n\n// apps/api-gateway/src/auth/auth.controller.ts\nimport { Controller, Post, Body, UseGuards, Get, Req } from '@nestjs/common';\nimport { ClientProxy } from '@nestjs/microservices';\nimport { Inject } from '@nestjs/common';\nimport { firstValueFrom } from 'rxjs';\nimport { JwtAuthGuard } from '@app/auth';\nimport { CurrentUser } from '@app/auth';\nimport { ApiTags, ApiOperation, ApiBearerAuth } from '@nestjs/swagger';\n\n@ApiTags('Authentication')\n@Controller('auth')\nexport class AuthController {\n  constructor(\n    @Inject('AUTH_SERVICE') private authServiceClient: ClientProxy,\n  ) {}\n\n  @Post('register')\n  @ApiOperation({ summary: 'Register a new user' })\n  async register(@Body() registerDto: any) {\n    return firstValueFrom(\n      this.authServiceClient.send('auth.register', registerDto)\n    );\n  }\n\n  @Post('login')\n  @ApiOperation({ summary: 'Login user' })\n  async login(@Body() loginDto: any) {\n    return firstValueFrom(\n      this.authServiceClient.send('auth.login', loginDto)\n    );\n  }\n\n  @Post('refresh')\n  @ApiOperation({ summary: 'Refresh access token' })\n  async refresh(@Body() refreshDto: { refreshToken: string }) {\n    return firstValueFrom(\n      this.authServiceClient.send('auth.refresh', refreshDto)\n    );\n  }\n\n  @Post('logout')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth('JWT-auth')\n  @ApiOperation({ summary: 'Logout user' })\n  async logout(@CurrentUser() user: any) {\n    return firstValueFrom(\n      this.authServiceClient.send('auth.logout', { userId: user.sub })\n    );\n  }\n\n  @Get('profile')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth('JWT-auth')\n  @ApiOperation({ summary: 'Get current user profile' })\n  async getProfile(@CurrentUser() user: any) {\n    return firstValueFrom(\n      this.authServiceClient.send('auth.profile', { userId: user.sub })\n    );\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"service-implementation-examples",children:"Service Implementation Examples"}),"\n",(0,s.jsx)(n.h3,{id:"order-service-with-authorization",children:"Order Service with Authorization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// apps/order-service/src/orders.controller.ts\nimport { Controller, Get, Post, Body, Param, UseGuards, Query } from '@nestjs/common';\nimport { JwtAuthGuard, RolesGuard, PermissionsGuard, ResourceAccessGuard } from '@app/auth';\nimport { Roles, RequirePermissions, ResourceAccess, CurrentUser } from '@app/auth';\nimport { ApiTags, ApiBearerAuth } from '@nestjs/swagger';\n\n@ApiTags('Orders')\n@Controller('orders')\n@UseGuards(JwtAuthGuard)\n@ApiBearerAuth('JWT-auth')\nexport class OrdersController {\n  constructor(private readonly ordersService: OrdersService) {}\n\n  @Post()\n  @UseGuards(PermissionsGuard)\n  @RequirePermissions('orders:create')\n  async createOrder(\n    @Body() createOrderDto: CreateOrderDto,\n    @CurrentUser() user: any\n  ) {\n    return this.ordersService.create(createOrderDto, user);\n  }\n\n  @Get()\n  @UseGuards(PermissionsGuard)\n  @RequirePermissions('orders:read')\n  async getOrders(\n    @Query() query: GetOrdersDto,\n    @CurrentUser() user: any\n  ) {\n    return this.ordersService.findAllForUser(query, user);\n  }\n\n  @Get(':id')\n  @UseGuards(ResourceAccessGuard)\n  @ResourceAccess({\n    resource: 'orders',\n    action: 'read',\n    ownershipField: 'userId',\n    companyScoped: true\n  })\n  async getOrder(@Param('id') id: string) {\n    return this.ordersService.findOne(id);\n  }\n\n  @Post(':id/cancel')\n  @UseGuards(ResourceAccessGuard)\n  @ResourceAccess({\n    resource: 'orders',\n    action: 'cancel',\n    ownershipField: 'userId'\n  })\n  async cancelOrder(@Param('id') id: string, @CurrentUser() user: any) {\n    return this.ordersService.cancel(id, user);\n  }\n\n  @Get('admin/all')\n  @UseGuards(RolesGuard)\n  @Roles('ADMIN', 'ORDER_MANAGER')\n  async getAllOrdersAdmin(@Query() query: AdminGetOrdersDto) {\n    return this.ordersService.findAllAdmin(query);\n  }\n}\n\n// apps/order-service/src/orders.service.ts\n@Injectable()\nexport class OrdersService {\n  constructor(\n    @InjectRepository(Order)\n    private orderRepository: Repository<Order>,\n    @Inject('USER_SERVICE')\n    private userServiceClient: ClientProxy,\n  ) {}\n\n  async create(createOrderDto: CreateOrderDto, user: any): Promise<Order> {\n    // Verify user can create orders in their company/department\n    const canCreate = await this.checkUserPermission(\n      user,\n      'orders:create',\n      createOrderDto.companyId\n    );\n\n    if (!canCreate) {\n      throw new ForbiddenException('Cannot create orders for this company');\n    }\n\n    const order = this.orderRepository.create({\n      ...createOrderDto,\n      userId: user.sub,\n      companyId: user.companyId,\n      status: OrderStatus.PENDING,\n    });\n\n    return this.orderRepository.save(order);\n  }\n\n  async findAllForUser(query: GetOrdersDto, user: any): Promise<Order[]> {\n    const queryBuilder = this.orderRepository.createQueryBuilder('order');\n\n    // Apply user-specific filters based on roles\n    if (user.roles.includes('ADMIN')) {\n      // Admins can see all orders\n    } else if (user.roles.includes('COMPANY_MANAGER')) {\n      // Company managers can see company orders\n      queryBuilder.where('order.companyId = :companyId', { \n        companyId: user.companyId \n      });\n    } else {\n      // Regular users can only see their own orders\n      queryBuilder.where('order.userId = :userId', { userId: user.sub });\n    }\n\n    // Apply additional filters\n    if (query.status) {\n      queryBuilder.andWhere('order.status = :status', { status: query.status });\n    }\n\n    if (query.startDate) {\n      queryBuilder.andWhere('order.createdAt >= :startDate', { \n        startDate: query.startDate \n      });\n    }\n\n    return queryBuilder.getMany();\n  }\n\n  private async checkUserPermission(\n    user: any,\n    permission: string,\n    resourceId?: string\n  ): Promise<boolean> {\n    try {\n      const result = await firstValueFrom(\n        this.userServiceClient.send('check_permission', {\n          userId: user.sub,\n          permission,\n          resourceId,\n          context: {\n            companyId: user.companyId,\n            departmentId: user.departmentId,\n          }\n        })\n      );\n      return result.hasPermission;\n    } catch (error) {\n      console.error('Error checking user permission:', error);\n      return false;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"kubernetes-deployment-configuration",children:"Kubernetes Deployment Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"namespace-and-rbac",children:"Namespace and RBAC"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# k8s/namespace.yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: ecommerce\n  labels:\n    name: ecommerce\n    istio-injection: enabled\n\n---\n# k8s/rbac.yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: ecommerce-service-account\n  namespace: ecommerce\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: ecommerce\n  name: ecommerce-role\nrules:\n- apiGroups: [""]\n  resources: ["secrets", "configmaps"]\n  verbs: ["get", "list"]\n- apiGroups: [""]\n  resources: ["pods"]\n  verbs: ["get", "list", "watch"]\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: ecommerce-role-binding\n  namespace: ecommerce\nsubjects:\n- kind: ServiceAccount\n  name: ecommerce-service-account\n  namespace: ecommerce\nroleRef:\n  kind: Role\n  name: ecommerce-role\n  apiGroup: rbac.authorization.k8s.io\n'})}),"\n",(0,s.jsx)(n.h3,{id:"configmaps-and-secrets",children:"ConfigMaps and Secrets"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# k8s/configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: ecommerce-config\n  namespace: ecommerce\ndata:\n  NODE_ENV: "production"\n  LOG_LEVEL: "info"\n  API_VERSION: "v1"\n  CORS_ORIGINS: "https://yourdomain.com,https://app.yourdomain.com"\n  REDIS_HOST: "redis-service"\n  REDIS_PORT: "6379"\n  DB_HOST: "postgres-service"\n  DB_PORT: "5432"\n  DB_NAME: "ecommerce"\n  JWT_ACCESS_EXPIRES_IN: "15m"\n  JWT_REFRESH_EXPIRES_IN: "7d"\n\n---\n# k8s/secrets.yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: ecommerce-secrets\n  namespace: ecommerce\ntype: Opaque\ndata:\n  # Base64 encoded values\n  DB_USERNAME: cG9zdGdyZXM= # postgres\n  DB_PASSWORD: cGFzc3dvcmQxMjM= # password123\n  JWT_ACCESS_SECRET: c3VwZXItc2VjcmV0LWFjY2Vzcy1rZXk= # super-secret-access-key\n  JWT_REFRESH_SECRET: c3VwZXItc2VjcmV0LXJlZnJlc2gta2V5 # super-secret-refresh-key\n  REDIS_PASSWORD: cmVkaXNwYXNzd29yZA== # redispassword\n'})}),"\n",(0,s.jsx)(n.h3,{id:"service-deployments",children:"Service Deployments"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# k8s/auth-service.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: auth-service\n  namespace: ecommerce\n  labels:\n    app: auth-service\n    version: v1\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: auth-service\n      version: v1\n  template:\n    metadata:\n      labels:\n        app: auth-service\n        version: v1\n    spec:\n      serviceAccountName: ecommerce-service-account\n      containers:\n      - name: auth-service\n        image: gcr.io/your-project/auth-service:latest\n        ports:\n        - containerPort: 3001\n        env:\n        - name: PORT\n          value: "3001"\n        - name: SERVICE_NAME\n          value: "auth-service"\n        envFrom:\n        - configMapRef:\n            name: ecommerce-config\n        - secretRef:\n            name: ecommerce-secrets\n        resources:\n          requests:\n            memory: "256Mi"\n            cpu: "250m"\n          limits:\n            memory: "512Mi"\n            cpu: "500m"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3001\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health/ready\n            port: 3001\n          initialDelaySeconds: 5\n          periodSeconds: 5\n        securityContext:\n          runAsNonRoot: true\n          runAsUser: 1000\n          allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: true\n          capabilities:\n            drop:\n            - ALL\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: auth-service\n  namespace: ecommerce\n  labels:\n    app: auth-service\nspec:\n  selector:\n    app: auth-service\n  ports:\n  - port: 3001\n    targetPort: 3001\n    name: http\n\n---\n# k8s/api-gateway.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: api-gateway\n  namespace: ecommerce\n  labels:\n    app: api-gateway\n    version: v1\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: api-gateway\n      version: v1\n  template:\n    metadata:\n      labels:\n        app: api-gateway\n        version: v1\n    spec:\n      serviceAccountName: ecommerce-service-account\n      containers:\n      - name: api-gateway\n        image: gcr.io/your-project/api-gateway:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: PORT\n          value: "3000"\n        - name: AUTH_SERVICE_URL\n          value: "http://auth-service:3001"\n        - name: USER_SERVICE_URL\n          value: "http://user-service:3002"\n        - name: ORDER_SERVICE_URL\n          value: "http://order-service:3003"\n        - name: PRODUCT_SERVICE_URL\n          value: "http://product-service:3004"\n        envFrom:\n        - configMapRef:\n            name: ecommerce-config\n        - secretRef:\n            name: ecommerce-secrets\n        resources:\n          requests:\n            memory: "512Mi"\n            cpu: "500m"\n          limits:\n            memory: "1Gi"\n            cpu: "1000m"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health/ready\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: api-gateway\n  namespace: ecommerce\n  labels:\n    app: api-gateway\nspec:\n  selector:\n    app: api-gateway\n  ports:\n  - port: 80\n    targetPort: 3000\n    name: http\n  type: LoadBalancer\n'})}),"\n",(0,s.jsx)(n.h3,{id:"istio-service-mesh-configuration",children:"Istio Service Mesh Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"# k8s/istio/gateway.yaml\napiVersion: networking.istio.io/v1beta1\nkind: Gateway\nmetadata:\n  name: ecommerce-gateway\n  namespace: ecommerce\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n  - port:\n      number: 443\n      name: https\n      protocol: HTTPS\n    tls:\n      mode: SIMPLE\n      credentialName: ecommerce-tls-cert\n    hosts:\n    - api.yourdomain.com\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - api.yourdomain.com\n    tls:\n      httpsRedirect: true\n\n---\n# k8s/istio/virtual-service.yaml\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: ecommerce-vs\n  namespace: ecommerce\nspec:\n  hosts:\n  - api.yourdomain.com\n  gateways:\n  - ecommerce-gateway\n  http:\n  - match:\n    - uri:\n        prefix: /api/\n    rewrite:\n      uri: /\n    route:\n    - destination:\n        host: api-gateway\n        port:\n          number: 80\n    timeout: 30s\n    retries:\n      attempts: 3\n      perTryTimeout: 10s\n\n---\n# k8s/istio/destination-rule.yaml\napiVersion: networking.istio.io/v1beta1\nkind: DestinationRule\nmetadata:\n  name: api-gateway-dr\n  namespace: ecommerce\nspec:\n  host: api-gateway\n  trafficPolicy:\n    connectionPool:\n      tcp:\n        maxConnections: 100\n      http:\n        http1MaxPendingRequests: 50\n        maxRequestsPerConnection: 10\n    loadBalancer:\n      simple: LEAST_CONN\n    circuitBreaker:\n      consecutiveErrors: 3\n      interval: 30s\n      baseEjectionTime: 30s\n"})}),"\n",(0,s.jsx)(n.h3,{id:"authorization-policies-with-istio",children:"Authorization Policies with Istio"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# k8s/istio/authorization-policy.yaml\napiVersion: security.istio.io/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: ecommerce-authz\n  namespace: ecommerce\nspec:\n  rules:\n  - from:\n    - source:\n        principals: ["cluster.local/ns/ecommerce/sa/ecommerce-service-account"]\n  - to:\n    - operation:\n        methods: ["GET"]\n        paths: ["/health", "/health/ready", "/metrics"]\n  - to:\n    - operation:\n        methods: ["POST"]\n        paths: ["/auth/login", "/auth/register"]\n  - when:\n    - key: request.headers[authorization]\n      values: ["Bearer *"]\n\n---\n# k8s/istio/peer-authentication.yaml\napiVersion: security.istio.io/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: ecommerce-mtls\n  namespace: ecommerce\nspec:\n  mtls:\n    mode: STRICT\n'})}),"\n",(0,s.jsx)(n.h2,{id:"database-migrations-and-setup",children:"Database Migrations and Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// database/migrations/001_initial_schema.ts\nimport { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class InitialSchema1698765432100 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    // Create companies table\n    await queryRunner.query(`\n      CREATE TABLE companies (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        name VARCHAR(255) NOT NULL,\n        domain VARCHAR(255) UNIQUE,\n        is_active BOOLEAN DEFAULT true,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Create departments table\n    await queryRunner.query(`\n      CREATE TABLE departments (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        name VARCHAR(255) NOT NULL,\n        company_id UUID REFERENCES companies(id),\n        is_active BOOLEAN DEFAULT true,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Create permissions table\n    await queryRunner.query(`\n      CREATE TABLE permissions (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        name VARCHAR(255) UNIQUE NOT NULL,\n        description TEXT,\n        resource VARCHAR(100) NOT NULL,\n        action VARCHAR(100) NOT NULL,\n        is_active BOOLEAN DEFAULT true,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Create roles table\n    await queryRunner.query(`\n      CREATE TABLE roles (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        name VARCHAR(255) UNIQUE NOT NULL,\n        description TEXT,\n        is_active BOOLEAN DEFAULT true,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Create users table\n    await queryRunner.query(`\n      CREATE TABLE users (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        email VARCHAR(255) UNIQUE NOT NULL,\n        password VARCHAR(255) NOT NULL,\n        first_name VARCHAR(255) NOT NULL,\n        last_name VARCHAR(255) NOT NULL,\n        is_active BOOLEAN DEFAULT true,\n        email_verified BOOLEAN DEFAULT false,\n        phone_number VARCHAR(50),\n        avatar_url TEXT,\n        last_login_at TIMESTAMP,\n        last_logout_at TIMESTAMP,\n        company_id UUID REFERENCES companies(id),\n        department_id UUID REFERENCES departments(id),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Create junction tables\n    await queryRunner.query(`\n      CREATE TABLE role_permissions (\n        role_id UUID REFERENCES roles(id) ON DELETE CASCADE,\n        permission_id UUID REFERENCES permissions(id) ON DELETE CASCADE,\n        PRIMARY KEY (role_id, permission_id)\n      )\n    `);\n\n    await queryRunner.query(`\n      CREATE TABLE user_roles (\n        user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n        role_id UUID REFERENCES roles(id) ON DELETE CASCADE,\n        PRIMARY KEY (user_id, role_id)\n      )\n    `);\n\n    // Create indexes\n    await queryRunner.query(`CREATE INDEX idx_users_email ON users(email)`);\n    await queryRunner.query(`CREATE INDEX idx_users_company ON users(company_id)`);\n    await queryRunner.query(`CREATE INDEX idx_users_department ON users(department_id)`);\n    await queryRunner.query(`CREATE INDEX idx_permissions_resource_action ON permissions(resource, action)`);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`DROP TABLE IF EXISTS user_roles`);\n    await queryRunner.query(`DROP TABLE IF EXISTS role_permissions`);\n    await queryRunner.query(`DROP TABLE IF EXISTS users`);\n    await queryRunner.query(`DROP TABLE IF EXISTS roles`);\n    await queryRunner.query(`DROP TABLE IF EXISTS permissions`);\n    await queryRunner.query(`DROP TABLE IF EXISTS departments`);\n    await queryRunner.query(`DROP TABLE IF EXISTS companies`);\n  }\n}\n\n// database/seeders/default-data.seeder.ts\nimport { DataSource } from 'typeorm';\nimport { Permission } from '../entities/permission.entity';\nimport { Role } from '../entities/role.entity';\nimport { Company } from '../entities/company.entity';\n\nexport class DefaultDataSeeder {\n  constructor(private dataSource: DataSource) {}\n\n  async run(): Promise<void> {\n    await this.seedPermissions();\n    await this.seedRoles();\n    await this.seedDefaultCompany();\n  }\n\n  private async seedPermissions(): Promise<void> {\n    const permissionRepository = this.dataSource.getRepository(Permission);\n    \n    const permissions = [\n      // User permissions\n      { name: 'users:create', resource: 'users', action: 'create', description: 'Create new users' },\n      { name: 'users:read', resource: 'users', action: 'read', description: 'View user information' },\n      { name: 'users:update', resource: 'users', action: 'update', description: 'Update user information' },\n      { name: 'users:delete', resource: 'users', action: 'delete', description: 'Delete users' },\n      \n      // Order permissions\n      { name: 'orders:create', resource: 'orders', action: 'create', description: 'Create new orders' },\n      { name: 'orders:read', resource: 'orders', action: 'read', description: 'View orders' },\n      { name: 'orders:update', resource: 'orders', action: 'update', description: 'Update orders' },\n      { name: 'orders:cancel', resource: 'orders', action: 'cancel', description: 'Cancel orders' },\n      { name: 'orders:delete', resource: 'orders', action: 'delete', description: 'Delete orders' },\n      \n      // Product permissions\n      { name: 'products:create', resource: 'products', action: 'create', description: 'Create new products' },\n      { name: 'products:read', resource: 'products', action: 'read', description: 'View products' },\n      { name: 'products:update', resource: 'products', action: 'update', description: 'Update products' },\n      { name: 'products:delete', resource: 'products', action: 'delete', description: 'Delete products' },\n      \n      // Company permissions\n      { name: 'companies:create', resource: 'companies', action: 'create', description: 'Create companies' },\n      { name: 'companies:read', resource: 'companies', action: 'read', description: 'View companies' },\n      { name: 'companies:update', resource: 'companies', action: 'update', description: 'Update companies' },\n      { name: 'companies:delete', resource: 'companies', action: 'delete', description: 'Delete companies' },\n    ];\n\n    for (const permData of permissions) {\n      const exists = await permissionRepository.findOne({ where: { name: permData.name } });\n      if (!exists) {\n        const permission = permissionRepository.create(permData);\n        await permissionRepository.save(permission);\n      }\n    }\n  }\n\n  private async seedRoles(): Promise<void> {\n    const roleRepository = this.dataSource.getRepository(Role);\n    const permissionRepository = this.dataSource.getRepository(Permission);\n\n    // Super Admin role\n    const adminPermissions = await permissionRepository.find();\n    let adminRole = await roleRepository.findOne({ \n      where: { name: 'SUPER_ADMIN' },\n      relations: ['permissions']\n    });\n    \n    if (!adminRole) {\n      adminRole = roleRepository.create({\n        name: 'SUPER_ADMIN',\n        description: 'Super administrator with all permissions',\n        permissions: adminPermissions,\n      });\n      await roleRepository.save(adminRole);\n    }\n\n    // Regular user role\n    const userPermissions = await permissionRepository.find({\n      where: [\n        { name: 'orders:create' },\n        { name: 'orders:read' },\n        { name: 'orders:cancel' },\n        { name: 'products:read' },\n      ]\n    });\n\n    let userRole = await roleRepository.findOne({ \n      where: { name: 'USER' },\n      relations: ['permissions']\n    });\n    \n    if (!userRole) {\n      userRole = roleRepository.create({\n        name: 'USER',\n        description: 'Regular user with basic permissions',\n        permissions: userPermissions,\n      });\n      await roleRepository.save(userRole);\n    }\n  }\n\n  private async seedDefaultCompany(): Promise<void> {\n    const companyRepository = this.dataSource.getRepository(Company);\n    \n    const exists = await companyRepository.findOne({ where: { name: 'Default Company' } });\n    if (!exists) {\n      const company = companyRepository.create({\n        name: 'Default Company',\n        domain: 'default.com',\n      });\n      await companyRepository.save(company);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"deployment-scripts",children:"Deployment Scripts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# scripts/deploy.sh\n\nset -e\n\nPROJECT_ID=${1:-"your-gcp-project-id"}\nREGION=${2:-"us-central1"}\nCLUSTER_NAME=${3:-"ecommerce-cluster"}\n\necho "Deploying to GCP Project: $PROJECT_ID"\necho "Region: $REGION"\necho "Cluster: $CLUSTER_NAME"\n\n# Build and push Docker images\necho "Building and pushing Docker images..."\ndocker build -t gcr.io/$PROJECT_ID/auth-service:latest -f docker/auth-service.Dockerfile .\ndocker build -t gcr.io/$PROJECT_ID/api-gateway:latest -f docker/api-gateway.Dockerfile .\ndocker build -t gcr.io/$PROJECT_ID/user-service:latest -f docker/user-service.Dockerfile .\ndocker build -t gcr.io/$PROJECT_ID/order-service:latest -f docker/order-service.Dockerfile .\ndocker build -t gcr.io/$PROJECT_ID/product-service:latest -f docker/product-service.Dockerfile .\n\ndocker push gcr.io/$PROJECT_ID/auth-service:latest\ndocker push gcr.io/$PROJECT_ID/api-gateway:latest\ndocker push gcr.io/$PROJECT_ID/user-service:latest\ndocker push gcr.io/$PROJECT_ID/order-service:latest\ndocker push gcr.io/$PROJECT_ID/product-service:latest\n\n# Get GKE credentials\necho "Getting GKE credentials..."\ngcloud container clusters get-credentials $CLUSTER_NAME --region=$REGION --project=$PROJECT_ID\n\n# Apply Kubernetes manifests\necho "Applying Kubernetes manifests..."\nkubectl apply -f k8s/namespace.yaml\nkubectl apply -f k8s/rbac.yaml\nkubectl apply -f k8s/configmap.yaml\nkubectl apply -f k8s/secrets.yaml\n\n# Deploy services\nkubectl apply -f k8s/auth-service.yaml\nkubectl apply -f k8s/api-gateway.yaml\nkubectl apply -f k8s/user-service.yaml\nkubectl apply -f k8s/order-service.yaml\nkubectl apply -f k8s/product-service.yaml\n\n# Apply Istio configurations\necho "Applying Istio configurations..."\nkubectl apply -f k8s/istio/\n\necho "Waiting for deployments to be ready..."\nkubectl wait --for=condition=available --timeout=600s deployment/auth-service -n ecommerce\nkubectl wait --for=condition=available --timeout=600s deployment/api-gateway -n ecommerce\nkubectl wait --for=condition=available --timeout=600s deployment/user-service -n ecommerce\nkubectl wait --for=condition=available --timeout=600s deployment/order-service -n ecommerce\nkubectl wait --for=condition=available --timeout=600s deployment/product-service -n ecommerce\n\necho "Deployment completed successfully!"\necho "API Gateway endpoint:"\nkubectl get service api-gateway -n ecommerce -o jsonpath=\'{.status.loadBalancer.ingress[0].ip}\'\n'})}),"\n",(0,s.jsx)(n.h2,{id:"security-best-practices-summary",children:"Security Best Practices Summary"}),"\n",(0,s.jsxs)(n.h3,{id:"1-authentication-security",children:["1. ",(0,s.jsx)(n.strong,{children:"Authentication Security"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use strong JWT secrets stored in Kubernetes secrets"}),"\n",(0,s.jsx)(n.li,{children:"Implement proper token expiration and rotation"}),"\n",(0,s.jsx)(n.li,{children:"Use bcrypt with appropriate salt rounds for password hashing"}),"\n",(0,s.jsx)(n.li,{children:"Implement account lockout after failed login attempts"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-authorization-security",children:["2. ",(0,s.jsx)(n.strong,{children:"Authorization Security"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implement defense in depth with multiple authorization layers"}),"\n",(0,s.jsx)(n.li,{children:"Use principle of least privilege for role assignments"}),"\n",(0,s.jsx)(n.li,{children:"Validate resource ownership at the service level"}),"\n",(0,s.jsx)(n.li,{children:"Implement audit logging for all authorization decisions"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-infrastructure-security",children:["3. ",(0,s.jsx)(n.strong,{children:"Infrastructure Security"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use Kubernetes RBAC for service account permissions"}),"\n",(0,s.jsx)(n.li,{children:"Implement network policies to restrict inter-service communication"}),"\n",(0,s.jsx)(n.li,{children:"Use Istio service mesh for mTLS between services"}),"\n",(0,s.jsx)(n.li,{children:"Store sensitive data in GCP Secret Manager or Kubernetes secrets"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-api-security",children:["4. ",(0,s.jsx)(n.strong,{children:"API Security"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implement rate limiting at the API gateway level"}),"\n",(0,s.jsx)(n.li,{children:"Use HTTPS/TLS for all external communication"}),"\n",(0,s.jsx)(n.li,{children:"Validate all input data with proper sanitization"}),"\n",(0,s.jsx)(n.li,{children:"Implement proper CORS policies"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"5-container-security",children:["5. ",(0,s.jsx)(n.strong,{children:"Container Security"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Run containers as non-root users"}),"\n",(0,s.jsx)(n.li,{children:"Use read-only root filesystems"}),"\n",(0,s.jsx)(n.li,{children:"Implement resource limits and requests"}),"\n",(0,s.jsx)(n.li,{children:"Regularly scan container images for vulnerabilities"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"6-monitoring-and-observability",children:["6. ",(0,s.jsx)(n.strong,{children:"Monitoring and Observability"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implement comprehensive logging for security events"}),"\n",(0,s.jsx)(n.li,{children:"Set up monitoring for failed authentication attempts"}),"\n",(0,s.jsx)(n.li,{children:"Use distributed tracing for request flow analysis"}),"\n",(0,s.jsx)(n.li,{children:"Implement alerting for suspicious activities"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"This comprehensive implementation demonstrates how to build secure, scalable microservices with NestJS on GCP Kubernetes. The architecture incorporates:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-layered Security"}),": Authentication at the gateway, authorization at the service level"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enterprise Patterns"}),": RBAC, ReBAC, and ABAC authorization models"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cloud-Native Features"}),": Kubernetes-native security, Istio service mesh, GCP integrations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Production Readiness"}),": Proper error handling, monitoring, and deployment automation"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Key benefits of this approach:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scalability"}),": Each service can scale independently based on demand"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Security"}),": Multiple layers of security from infrastructure to application level"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintainability"}),": Clear separation of concerns and modular architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Observability"}),": Comprehensive logging, monitoring, and tracing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reliability"}),": Health checks, circuit breakers, and proper error handling"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This implementation provides a solid foundation for building enterprise-grade microservices with robust authentication and authorization mechanisms suitable for production deployment on Google Cloud Platform."}),"\n",(0,s.jsx)(n.h2,{id:"further-resources",children:"Further Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.nestjs.com/",children:"NestJS Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/security/",children:"Kubernetes Security Best Practices"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://istio.io/latest/docs/concepts/security/",children:"Istio Security Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://cloud.google.com/security/best-practices",children:"Google Cloud Security Best Practices"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://microservices.io/patterns/security/",children:"Microservices Security Patterns"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Have you implemented similar microservices architectures? Share your experiences with authentication and authorization patterns in the comments!"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},1151:e=>{e.exports=JSON.parse('{"permalink":"/fullstack-dev/blog/nestjs-auth-microservices-gcp-kubernetes","editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/blog/2025-10-06-nestjs-auth-microservices-gcp-kubernetes.md","source":"@site/blog/2025-10-06-nestjs-auth-microservices-gcp-kubernetes.md","title":"Building Secure Microservices: Authentication & Authorization with NestJS on GCP Kubernetes","description":"Building secure microservices with proper authentication and authorization is one of the most critical aspects of modern application development. When deploying to Google Cloud Platform (GCP) Kubernetes, we need to consider not only the application-level security patterns but also the infrastructure and container orchestration security layers.","date":"2025-10-06T00:00:00.000Z","tags":[{"inline":false,"label":"NestJS","permalink":"/fullstack-dev/blog/tags/nestjs","description":"NestJS framework for Node.js applications"},{"inline":false,"label":"Microservices","permalink":"/fullstack-dev/blog/tags/microservices","description":"Microservices architecture and patterns"},{"inline":false,"label":"Authentication","permalink":"/fullstack-dev/blog/tags/authentication","description":"User authentication systems"},{"inline":false,"label":"Authorization","permalink":"/fullstack-dev/blog/tags/authorization","description":"Access control and permissions"},{"inline":false,"label":"Google Cloud Platform","permalink":"/fullstack-dev/blog/tags/gcp","description":"Google Cloud Platform services"},{"inline":false,"label":"Kubernetes","permalink":"/fullstack-dev/blog/tags/kubernetes","description":"Kubernetes container orchestration"},{"inline":false,"label":"JWT","permalink":"/fullstack-dev/blog/tags/jwt","description":"JSON Web Tokens for authentication"},{"inline":false,"label":"RBAC","permalink":"/fullstack-dev/blog/tags/rbac","description":"Role-based access control"},{"inline":false,"label":"Security","permalink":"/fullstack-dev/blog/tags/security","description":"Application security practices"},{"inline":false,"label":"Docker","permalink":"/fullstack-dev/blog/tags/docker","description":"Docker containerization"}],"readingTime":21.86,"hasTruncateMarker":true,"authors":[{"name":"Tam Nguyen","title":"Full Stack Developer, Next.js for Production Creator","url":"https://github.com/tamnk74","page":{"permalink":"/fullstack-dev/blog/authors/tam"},"socials":{"github":"https://github.com/tamnk74"},"imageURL":"https://github.com/tamnk74.png","key":"tam"}],"frontMatter":{"slug":"nestjs-auth-microservices-gcp-kubernetes","title":"Building Secure Microservices: Authentication & Authorization with NestJS on GCP Kubernetes","authors":["tam"],"tags":["nestjs","microservices","authentication","authorization","gcp","kubernetes","jwt","rbac","security","docker"]},"unlisted":false,"prevItem":{"title":"Securing Your Website with Let\'s Encrypt and Nginx: A Complete Guide","permalink":"/fullstack-dev/blog/lets-encrypt-nginx-ssl-setup"},"nextItem":{"title":"Nginx: The High-Performance Web Server and Reverse Proxy","permalink":"/fullstack-dev/blog/nginx-web-server-guide"}}')},7814:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(9729);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);