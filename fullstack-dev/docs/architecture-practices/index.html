<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-architecture-practices/index" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.1">
<title data-rh="true">Architecture Practices for NestJS &amp; Next.js | Full-Stack Developer</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://tamnk74.github.io/fullstack-dev/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://tamnk74.github.io/fullstack-dev/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://tamnk74.github.io/fullstack-dev/docs/architecture-practices/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Architecture Practices for NestJS &amp; Next.js | Full-Stack Developer"><meta data-rh="true" name="description" content="This section provides detailed implementation guides for each architecture practice identified in the Architecture Maturity Assessment. Each guide is specifically tailored for NestJS microservices and Next.js microfrontend architectures."><meta data-rh="true" property="og:description" content="This section provides detailed implementation guides for each architecture practice identified in the Architecture Maturity Assessment. Each guide is specifically tailored for NestJS microservices and Next.js microfrontend architectures."><link data-rh="true" rel="icon" href="/fullstack-dev/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://tamnk74.github.io/fullstack-dev/docs/architecture-practices/"><link data-rh="true" rel="alternate" href="https://tamnk74.github.io/fullstack-dev/docs/architecture-practices/" hreflang="en"><link data-rh="true" rel="alternate" href="https://tamnk74.github.io/fullstack-dev/docs/architecture-practices/" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Architecture Practices","item":"https://tamnk74.github.io/fullstack-dev/docs/architecture-practices/"}]}</script><link rel="alternate" type="application/rss+xml" href="/fullstack-dev/blog/rss.xml" title="Full-Stack Developer RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/fullstack-dev/blog/atom.xml" title="Full-Stack Developer Atom Feed"><link rel="stylesheet" href="/fullstack-dev/assets/css/styles.60db8567.css">
<script src="/fullstack-dev/assets/js/runtime~main.87438347.js" defer="defer"></script>
<script src="/fullstack-dev/assets/js/main.9dc31388.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/fullstack-dev/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_DozU" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/fullstack-dev/"><div class="navbar__logo"><img src="/fullstack-dev/img/logo.svg" alt="Full-Stack Developer Logo" class="themedComponent_dued themedComponent--light_Jgez"><img src="/fullstack-dev/img/logo.svg" alt="Full-Stack Developer Logo" class="themedComponent_dued themedComponent--dark_OEZ1"></div><b class="navbar__title text--truncate">Full-Stack Developer</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/fullstack-dev/docs/intro">Documentation</a><a class="navbar__item navbar__link" href="/fullstack-dev/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><div class="navbarSearchContainer_SFyi"><div class="navbar__search searchBarContainer_jFf1" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input searchInput_mr2x" value=""><div class="loadingRing__lbt searchBarLoadingRing_pf7H"><div></div><div></div><div></div><div></div></div></div></div><a href="https://github.com/tamnk74/fullstack-dev" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_PqB4"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_WCEm colorModeToggle_eIxa"><button class="clean-btn toggleButton_nhoX toggleButtonDisabled_GPdO" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_BDuF lightToggleIcon_DH_d"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_BDuF darkToggleIcon_j7cc"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_BDuF systemToggleIcon_sRCC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_Inon"><div class="docsWrapper_vTcP"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Kk4I" type="button"></button><div class="docRoot_oC9v"><aside class="theme-doc-sidebar-container docSidebarContainer_o76a"><div class="sidebarViewport_X9l3"><div class="sidebar_nRMc"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_QChV"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/fullstack-dev/docs/intro"><span title="Introduction" class="linkLabel_ttjv">Introduction</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/fullstack-dev/docs/search-guide"><span title="Search Documentation" class="linkLabel_ttjv">Search Documentation</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/fullstack-dev/docs/setup"><span title="Getting Started" class="categoryLinkLabel_K4TR">Getting Started</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/fullstack-dev/docs/assessments/developer-assessment-with-development-plans"><span title="Career Development" class="categoryLinkLabel_K4TR">Career Development</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist" href="/fullstack-dev/docs/security-practices/"><span title="Security Practices" class="categoryLinkLabel_K4TR">Security Practices</span></a><button aria-label="Expand sidebar category &#x27;Security Practices&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist" href="/fullstack-dev/docs/qa-practices/"><span title="QA Practices" class="categoryLinkLabel_K4TR">QA Practices</span></a><button aria-label="Expand sidebar category &#x27;QA Practices&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible menu__list-item-collapsible--active"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--active" aria-current="page" href="/fullstack-dev/docs/architecture-practices/"><span title="Architecture Practices" class="categoryLinkLabel_K4TR">Architecture Practices</span></a><button aria-label="Collapse sidebar category &#x27;Architecture Practices&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/fullstack-dev/docs/architecture-practices/architecture-definition/scm-policy"><span title="Architecture Definition" class="categoryLinkLabel_K4TR">Architecture Definition</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline"><span title="Architecture Execution" class="categoryLinkLabel_K4TR">Architecture Execution</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/fullstack-dev/docs/architecture-practices/architecture-management/skills-assessment"><span title="Architecture Management" class="categoryLinkLabel_K4TR">Architecture Management</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/fullstack-dev/docs/architecture-practices/architecture-validation/code-review-process"><span title="Architecture Validation" class="categoryLinkLabel_K4TR">Architecture Validation</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/fullstack-dev/docs/architecture-practices/performance-system-architecture"><span title="Performance Architecture" class="categoryLinkLabel_K4TR">Performance Architecture</span></a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist" href="/fullstack-dev/docs/coding-conventions/"><span title="Coding Conventions" class="categoryLinkLabel_K4TR">Coding Conventions</span></a><button aria-label="Expand sidebar category &#x27;Coding Conventions&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist" href="/fullstack-dev/docs/rag-recommendations/"><span title="RAG Recommendations" class="categoryLinkLabel_K4TR">RAG Recommendations</span></a><button aria-label="Expand sidebar category &#x27;RAG Recommendations&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist" href="/fullstack-dev/docs/backend/"><span title="Backend" class="categoryLinkLabel_K4TR">Backend</span></a><button aria-label="Expand sidebar category &#x27;Backend&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/fullstack-dev/docs/ai-machine-learning/vertex-ai-gemini-guide"><span title="AI &amp; Machine Learning" class="categoryLinkLabel_K4TR">AI &amp; Machine Learning</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/fullstack-dev/docs/features"><span title="Features" class="categoryLinkLabel_K4TR">Features</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/fullstack-dev/docs/devops/gitops-microservices-gcp-guide"><span title="DevOps" class="categoryLinkLabel_K4TR">DevOps</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/fullstack-dev/docs/testing"><span title="Development" class="categoryLinkLabel_K4TR">Development</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/fullstack-dev/docs/api-reference"><span title="API Reference" class="categoryLinkLabel_K4TR">API Reference</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/fullstack-dev/docs/tutorial-basics/create-a-document"><span title="Tutorial" class="categoryLinkLabel_K4TR">Tutorial</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_AYZa menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/fullstack-dev/docs/tutorial-extras/manage-docs-versions"><span title="Advanced" class="categoryLinkLabel_K4TR">Advanced</span></a></div></li></ul></nav></div></div></aside><main class="docMainContainer_Go1O"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_tbb6"><div class="docItemContainer_loSK"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Lu9I" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/fullstack-dev/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_x1cF"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Architecture Practices</span></li></ul></nav><div class="tocCollapsible_e8zW theme-doc-toc-mobile tocMobile_QFGV"><button type="button" class="clean-btn tocCollapsibleButton_N02v">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Architecture Practices for NestJS &amp; Next.js</h1></header>
<p>This section provides detailed implementation guides for each architecture practice identified in the <a href="/fullstack-dev/docs/architecture-practices/architecture-maturity-assessment">Architecture Maturity Assessment</a>. Each guide is specifically tailored for NestJS microservices and Next.js microfrontend architectures.</p>
<h2 class="anchor anchorWithStickyNavbar_vU8F" id="architecture-maturity-assessment">Architecture Maturity Assessment<a href="#architecture-maturity-assessment" class="hash-link" aria-label="Direct link to Architecture Maturity Assessment" title="Direct link to Architecture Maturity Assessment" translate="no">​</a></h2>
<p>The following table outlines all architecture practices organized by area, practice category, implementation phase, and maturity level:</p>
<table><thead><tr><th>#</th><th>Area</th><th>Practice</th><th>Phase</th><th>Maturity Level</th><th>Criteria</th><th>Help Text 💡</th></tr></thead><tbody><tr><td>1</td><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>SETUP</td><td>1</td><td>The SCM (Source Control Management) policy is defined and documented.</td><td>The Source Control Management policy is a set of rules related to source control that are agreed with the development team. What are the main branches, what are the rules for the developer to create new branches, naming conventions for branches, what are the conventions for commit messages? What are the rules to create Pull Request? When the branches will get merged? Those are some of the topics that should be covered in the Source Control Management policy. There should be a document that includes all this information. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td></tr><tr><td>2</td><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>SETUP</td><td>1</td><td>All needed software and tools (include versions) for the local environment (developer environment) are documented.</td><td>It is necessary to have a list of all needed software and tools, as well as the version of the utilized tool so any developer can consult it any time they need. It is also useful in case there is any new member joining the team. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td></tr><tr><td>3</td><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>SETUP</td><td>1</td><td>Coding (includes Unit Testing) practices, coding conventions are documented, explained and followed.</td><td>It is important for the project members to have a way to consult how to implement the coding conventions, patterns, and best practices. Providing some cone snippets as examples can also be a good way to put everyone on the same page. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td></tr><tr><td>4</td><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>SETUP</td><td>1</td><td>There is a guide of flows/steps of special development use-cases (e.g. How to run custom tools, how to set environment variables…)</td><td>It is necessary to provide documentation to the developers about how to set up their local environments. If there is any custom tool or script that is part of the process of setting up the local environment, the steps need to be clear in the document. If any new member joins the team, he or she should be able to set their local environments with low support. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td></tr><tr><td>5</td><td>Architecture Definition</td><td>Communication &amp; Alignment</td><td>SETUP</td><td>1</td><td>All the necessary KT (Knowledge Transfer) meetings are planned with stakeholders and partners.</td><td>This item applies when the team is receiving a new application from a third party or when there is a new integration with third parties that requires some knowledge transfer sessions. In this case, it is very important to have those knowledge transfer sessions scheduled and make sure that all stakeholders and technical people required are involved in these meetings.</td></tr><tr><td>6</td><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>SETUP</td><td>1</td><td>There are tools that will be used to check code style (lint, ESlint, PHPcs, stylecopaalyzers, etc).</td><td>It is important to establish a process to check the source code that is being created by the development team. Ideally, the code style verification should be incorporated in the code commit flow through git hooks, so we never allow code that is not compliant with the coding style rules to go further. There are different types of tools to check the code style, it differs depending on the technology that is being used in the project.</td></tr><tr><td>7</td><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>PREPARATION (Sprint 0)</td><td>1</td><td>The foundation of the application architecture is defined and documented (E.g. application layers, frameworks, logging mechanism, error handling mechanism, transaction control mechanism).</td><td>The architecture foundation is the basic structure of software architecture, including what are the application and data layers. The architecture foundation document should include all key mechanisms such as logging, mailing, CRUD structure, API structures, design patterns. We recommends the C4 model (<a href="https://c4model.com/" target="_blank" rel="noopener noreferrer">https://c4model.com/</a>), but other techniques can be used as long as it contains the needed level of details for everyone to understand it. It is important to set up meetings to share the overall diagrams and put everyone on the same page, especially the development team needs to be fully aware. Every time that there is an important change in the diagram, it should be also aligned with everyone. The document should be always maintained and up to date.</td></tr><tr><td>8</td><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>PREPARATION (Sprint 0)</td><td>1</td><td>The backup/restore strategy for the Production environment (database, files, etc) is defined and documented.</td><td>Backup and restore refers to practices for making periodic copies of data and applications to a separate, secondary device and then using those copies to recover the data and applications—and the business operations on which they depend—in the event that the original data and applications are lost. The information about the backup strategy should be documented and shared with the team. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td></tr><tr><td>9</td><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>PREPARATION (Sprint 0)</td><td>1</td><td>Internal and external important 3rd party APIs, libraries, frameworks, tools that are being used are documented.</td><td>3rd party APIs and libraries refers to any API (Restful, GraphQL api, etc) or libraries (SDK, pluggin, etc) that were not developed by other companies, not OTS. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td></tr><tr><td>10</td><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>All the data input by the user in any request are validated in the implemented code. Null or empty values/arrays must be taken into consideration.</td><td>The incorrect handling of data inputted by the user or received as a response from third-party APIs may lead to incidents on production later on. Not only the happy path should be covered during the testing. It is necessary to test the behavior of methods when receiving empty or null values as well.</td></tr><tr><td>Architecture Definition</td><td>Communication &amp; Alignment</td><td>SETUP</td><td>1</td><td>Business &amp; Technical communication channels are facilitated and used effectively.</td><td>The communication channel is the way utilized in the project to communicate with the client, stakeholders, and third parties. Many different channels such as slack, google chat, email, and teams can be used. However, it is necessary to ensure that the communication flows well and is facilitated. This item is to ensure that the team is thinking of ways to improve the communication if there is room for improvement.</td><td></td></tr><tr><td>Architecture Definition</td><td>Communication &amp; Alignment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>All the development policies, rules, conventions and plans are communicated to the team (e.g. SCM policy, Backup/restore plan, coding style convention, NFR metric targets, Unit test implementation process…)</td><td>Besides having all the information documented and available to the team, it is important to have all relevant technical information also communicated to them. Communication over video meetings or in-person meetings should be the preferable method. Communication written in the chat is an alternative way, however in this case it is important to ensure that everyone has read and understood the information.</td><td></td></tr><tr><td>Architecture Definition</td><td>Communication &amp; Alignment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>All big technical solutions and decisions are being communicated to the client. If there is any big change in the architecture, the change is also properly communicated to the stakeholders.</td><td>Besides keeping the architecture documentation up to date, it is also important to communicate with the client and stakeholders whenever there is a significant change in the overall architecture. A meeting should be scheduled to communicate with the stakeholders about those changes, and the architecture diagrams can be used to explain it to them.</td><td></td></tr><tr><td>Architecture Definition</td><td>Communication &amp; Alignment</td><td>SETUP</td><td>1</td><td>The overall Architecture diagram is shared and explained to all project stakeholders.</td><td>An architectural diagram is a diagram of a system that is used to abstract the overall outline of the software system and the relationships, constraints, and boundaries between components. We recommends the C4 model (<a href="https://c4model.com/" target="_blank" rel="noopener noreferrer">https://c4model.com/</a>), but other techniques can be used as long as it contains the needed level of details for everyone to understand it. It is important to set up meetings to share the overall diagrams and put everyone on the same page: development team, third parties and stakeholders. Every time that there is an important change in the diagram, it should be also aligned with everyone. The document should be always maintained and up to date.</td><td></td></tr><tr><td>Architecture Definition</td><td>Non-functional requirements</td><td>SETUP</td><td>1</td><td>All the Non-functional requirements related to the application are being mapped and collected.</td><td>A non-functional requirement is a specification that describes the system&#x27;s operational capabilities and constraints that enhance its functionality. These may be speed, security, reliability, etc. It is very important to identify all key NFRs of the project and document it and get approval from stakeholders. Remember that non-implemented NFRs may lead to gaps in the stakeholders&#x27; expectations and even become a production incident in the future.</td><td></td></tr><tr><td>Architecture Definition</td><td>Technical Refinement &amp; Design</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>The business stories are split into small testable-deployable features.</td><td>The business stories should be split into smaller testable parts. This will increase the predictability and the understanding of the team towards the task, thus reducing the risks.</td><td></td></tr><tr><td>Architecture Definition</td><td>Technical Refinement &amp; Design</td><td>SETUP</td><td>1</td><td>The technologies utilized in the project are vastly adopted there is no doubt about its capabilities; There is no early adoption and betas versions. Especially any infrastructure component must apply Global Availability version and have SLA/technical support commitment.</td><td>Ideally, new technologies that are still in alpha or beta should be avoided, unless it is already vastly adopted by other projects. In case of any questions or concerns, other Architects from different projects can be consulted before making the decision to use the technology.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>There is a way to track the artifact version deployed in each environment.</td><td>The artifact is the set of files that resulted from the build. For compiled languages, it can be a binary file or a jar file for example. For interpreted languages, the artifact is a snapshot of the source code, for example, a zip file containing all the needed files to run the application. This item refers to given an artifact, whether it is possible to track down the version of this artifact or the build number.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>There is a source code version control tool (git, svn, etc) and the team uses it efficiently.</td><td>Version control, also known as source control, is the practice of tracking and managing changes to software code. Version control systems are software tools that help software teams manage changes to source code over time. This item is about whether there is a source control tool and the team can understand how to use it and the team members do not commit trivial mistakes while using the to</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>Commit messages contains the related business ticket information, such as ticket number.</td><td>The commit messages should contain the related business ticket so it can be tracked down in case of need. If any issue or bug raises, it should be very simple to investigate and understand the business background behind those changes represented in the commit.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>Merge requests contain an informative description of related business tickets.</td><td>The merge requests messages should contain the related business tickets so it is possible to track them down in case of need. If any issue or bug raises, it should be very simple to investigate and understand the business background behind those changes represented in the commit.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>1</td><td>There are separated environments for development, testing and production (including the database).</td><td>Having dedicated environments for dev, test (stage), and production is a very basic best practice.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>1</td><td>The steps to set up the local environment (developer environment) are not considered complicated and the team has no difficulties following it.</td><td>The steps to set up the local environment should not be complicated. If there are lots of steps, other solutions like docker containers or script automation should be considered to make it simpler.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>1</td><td>There is a tool to manage all the application libraries and dependencies (maven, nuget, bower, npm, etc).</td><td>The third-party libraries used by the application should be not committed and pushed along with the code created by the development team. This makes source code management not efficient and complex. Library management tools should be leveraged instead. The tool differs according to the technology used. Maven (or equivalent) for Java, npm for Nodejs, Cocoapods for iOS, etc. In this case, only the main file that contains the reference for the libraries and their versions should be committed and pushed along with the code. The folder that contains the actual code should be added to the ignore list.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>1</td><td>There are monitoring tools for production infrastructure and there is a team in charge of following up.</td><td>It is an essential practice to apply monitoring solutions to production infrastructure to monitor the health of servers. It should at least track memory, CPU, and disk usage and notify whenever something goes wrong with those metrics. This item is about whether this kind of monitoring is applied to production servers and whether there is a team responsible for it.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>1</td><td>There are monitoring tools for the production application and there is a team in charge of following up.</td><td>It is an essential practice to apply monitoring solutions to the production application to monitor the health of the application and its critical business flows. It should at least cover the critical business flows, API monitoring for authentication, user registration, etc. This item is about whether this kind of monitoring is applied to the production application and whether there is a team responsible for it.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>There are documents describing the operation of branches, build pipelines, release pipelines, and environments.</td><td>This item refers to whether there is any documentation that describes the basic operation that is part of the daily basis of the development team (branches, build pipelines, ci/cd servers, and environments). The documentation should be kept always up to date, and everyone from the development team should have easy access to it. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td><td></td></tr><tr><td>Architecture Management</td><td>People &amp; Technical Skills Development</td><td>SETUP</td><td>1</td><td>There is a knowledge map from where it is possible to see the technical skills of the team.</td><td>The Architect is responsible for gathering the technical skills of the team members in a document (form, spreadsheet, etc). The document should be regularly updated (not more than 3 months). This document is very useful for the Architect to prepare/propose training sessions for the developers based on the gaps identified. This item is related to whether there is this document where is possible to see the team skills.</td><td></td></tr><tr><td>Architecture Management</td><td>Project Plan &amp; Architecture Roadmap</td><td>SETUP</td><td>1</td><td>There is an architecture Roadmap where all the key technical milestones and PoCs are listed; The technical tasks are in sync with the business stories (the technical preparation starts one sprint before the business story)</td><td>A roadmap is a strategic plan that defines a goal or desired outcome and includes the major steps or milestones needed to reach it. An Architecture Roadmap is a roadmap that contains all critical milestones of the project for the upcoming months: big PoCs, security test planning &amp; execution dates, performance tests planning &amp; execution dates, deployment dates, etc. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td><td></td></tr><tr><td>Architecture Management</td><td>Risks &amp; Blocks management</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>The Architecture maturity level PDCA (C&amp;A) meetings are being conducted at least monthly basis.</td><td>The Architecture maturity PDCA meeting stands for Plan Do Check Act (also known as Architecture C&amp;A). This refers to this meeting when we go through the checklist items checking whether the best practices are being followed in the project. The recommended frequency is bi-weekly basis, but the minimum acceptable frequency should be once a month.</td><td></td></tr><tr><td>Architecture Management</td><td>Risks &amp; Blocks management</td><td>RELEASE</td><td>1</td><td>The Solution Review meeting is always conducted when the project has a significant technical issue/technical decision, and other Software Architects from different projects are invited to join.</td><td>A Solution Review is a meeting that can be organized by any Architect, at any time. The Architect will invite architects from other projects in order to review some technical solutions provided or get advice from other perspectives. It is recommended to schedule this kind of meeting anytime there is a significant technical issue or big decision. It is always good to hear the opinion of other people.</td><td></td></tr><tr><td>Architecture Management</td><td>Technical Backlog management</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>The architecture backlog is being managed through follow-up meetings and the architecture tasks are being prioritized at an acceptable frequency (at least bi-weekly).</td><td>The Architecture backlog is a set of technical tasks that are managed by the Architect apart from the official product backlog. The tasks inside the architecture backlog do not generate direct value to the product, thus it is treated separated and there is no commitment about the delivery as a normal User Story. The Architect is responsible for including and prioritizing those tasks, whenever there is technical debt in the application, action items that came from the Architecture PDCA (C&amp;A meetings), performance gaps in the application, wrong coding standards, anti-patterns that are inside the code, etc. The tasks in the architecture backlog are not counted in the burndown chart because those are not part of the commitment in the sprint target, however, those tasks should be part of the Architect&#x27;s responsibility and regular activities from the Architect. Ideally, the Architect will be occupied half of the time with the Technical Refinement of the upcoming sprint, and the other half of the time he will be working on the Architecture backlog.</td><td></td></tr><tr><td>Architecture Validation</td><td>Architecture Evaluation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>The code quality is followed by performing code reviews and the process is documented and known by the team members.</td><td>The code review process differs according to the application and technology utilized. It is a good practice to have a checklist that includes the areas that should be verified before approving a pull request (security aspects, design pattern, performance aspects, etc). This item refers to whether the rules and best practices related to code quality are followed by the team and whether those code review rules are documented and known by the development team.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>The application is being validated across different browsers (for web), different devices (for mobile) and resolutions according to the requirements.</td><td>This is a basic item related to the testing process. All the supported browsers and devices should be listed up and the development team should be aware of this information. Before finishing a task, the developer should validate the application across all supported devices to avoid rework in the future. The sooner the bug is caught the cheaper is to fix it.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>The important web forms are protected with anti-spam mechanisms (Captcha or equivalent).</td><td>Form spam is the submission of website forms by human scammers or spambots with malicious intent. The information in these form submissions is false and they may contain abusive language, ads to other websites, or links to phishing websites and sites that download malware. There are several reasons scammers target websites with spam including spreading malware, stealing personal information, placing invisible links, and even hijacking control of the website. CAPTCHA stands for the Completely Automated Public Turing test to tell Computers and Humans Apart. CAPTCHAs are tools you can use to differentiate between real users and automated users, such as bots. CAPTCHAs provide challenges that are difficult for computers to perform but relatively easy for humans. For example, identifying stretched letters or numbers, or clicking in a specific area. By applying this technique, it is possible to prevent the webforms to be submitted by bots. This item is applicable for projects that have web forms and it refers to whether there are mechanisms to prevent it.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>All CSS and JS files are compressed and minified, and the images are optimized for the web to reduce bandwidth usage.</td><td>Minification is the process of minimizing code and markup in your web pages and script files. It&#x27;s one of the main methods used to reduce load times and bandwidth usage on websites. Minification dramatically improves site speed and accessibility, directly translating into a better user experience. It&#x27;s also beneficial to users accessing your website through a limited data plan and who would like to save on their bandwidth usage while surfing the web. The images also should be optimized and thumbnails with specific resolutions should be created according to the utilization purpose. For example, if you have a website that is showing up a list of items including a squared small visualization of the image, the original high-resolution image should not be used in this case. A specific smaller image should be generated for this purpose, otherwise, the bandwidth utilization will not be optimized.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>1</td><td>The response headers related to caching are being properly implemented for the application (cache-control with correct cacheability and max-age, etc).</td><td>Cache-Control is an HTTP cache header that contains a set of parameters to define the browser&#x27;s caching policies in the client requests and server responses. When a client makes a request to the server, the browser can cache, or store copies of resources for faster access and lower latency. This means that when the browser has to receive these files again, it doesn&#x27;t need to make a request to the web server again. Cache-Control specifies when and how a response should be cached and for how long. For web applications, it is important to ensure that the HTTP cache response headers are implemented correctly.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>PREPARATION (Sprint 0)</td><td>1</td><td>All non-production environments are protected under Basic Authentication, IP Whitelist or equivalent and web crawlers (Google, Yahoo, Bing) are not able to index the contents on the web.</td><td>If the non-production environments are not protected accordingly, that may lead to critical incidents such as leakage of important data or having non-production content getting indexed by Google. We should always protect non-production environments through IP whitelist, robots.txt files, Basic authentication, etc. Ideally, the non-production environments should also be monitored so it will send the team an alert in case of this protection was removed.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>RELEASE</td><td>1</td><td>All the critical performance areas are covered by performance testing.</td><td>Performance testing is a non-functional software testing technique that determines how the stability, speed, scalability, and responsiveness of an application hold up under a given workload. Covering the critical performance areas mean that the performance of the main business flows in the application is being tested. (For example: User registration form, Log-in screen, etc).</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>RELEASE</td><td>1</td><td>The performance tests are periodically executed, and the frequency is considered adequate.</td><td>Performance testing is a non-functional software testing technique that determines how the stability, speed, scalability, and responsiveness of an application hold up under a given workload. Periodically executed means that the performance is tested again everytime that there is a big change in the system.</td><td></td></tr><tr><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>SETUP</td><td>2</td><td>The rollback strategy is described in the SCM (Source Control Management) plan.</td><td>The Source Control Management policy is a set of rules related to source control that are agreed with the development team. What are the main branches, what are the rules for the developer to create new branches, naming conventions for branches, what are the conventions for commit messages? What are the rules to create Pull Request? When the branches will get merged? Those are some of the topics that should be covered in the Source Control Management policy. There should be a document that includes all this information. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td><td></td></tr><tr><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>SETUP</td><td>2</td><td>The details about how/when the PR (Pull requests) are created and what are the protected branches are included in the SCM (Source Control Management) plan.</td><td>The Source Control Management policy is a set of rules related to source control that are agreed with the development team. What are the main branches, what are the rules for the developer to create new branches, naming conventions for branches, what are the conventions for commit messages? What are the rules to create Pull Request? When the branches will get merged? Those are some of the topics that should be covered in the Source Control Management policy. There should be a document that includes all this information. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td><td></td></tr><tr><td>Architecture Definition</td><td>Technical Refinement &amp; Design</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The technical documentation is being updated during the project development (when it affects existing documents).</td><td>The technical documentation means architecture diagrams, coding standards, sequence diagrams, source control management plan, or any other documentation created by the Architect or development team. The documentation should be updated as soon as any changes come up.</td><td></td></tr><tr><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>The backup/restore strategy for pre-production environments (database, files, etc) is defined and documented.</td><td>Backup and restore refers to practices for making periodic copies of data and applications to a separate, secondary device and then using those copies to recover the data and applications—and the business operations on which they depend—in the event that the original data and applications are lost. The information about the backup strategy should be documented and shared with the team. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td><td></td></tr><tr><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>It is clear for all the developers how to implement unit tests for the technology stack used in the project. The process is defined and documented.</td><td>It is important for the project members to have a way to consult how to implement Unit Tests in case there are any questions. Sometimes the Unit Test framework is not intuitive, therefore it is necessary to have all the information documented. Providing some cone snippets as examples can also be a good way to put everyone on the same page. The document should be always maintained and up to date. There is no standard format for the documentation, it can be a Wiki, docx, ppt, pdf, README file, etc.</td><td></td></tr><tr><td>Architecture Definition</td><td>Communication &amp; Alignment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>All the team members, including development, infrastructure and business members share the same communication tool (Teams, Google Chat, Slack, etc).</td><td>Putting everyone together on the same communication tool is a way to enhance the collaboration in the project. To be faster, people need to be available and respond promptly. This item is about whether all key people share the same communication tools. If not, there should be a consensus and only one tool should be selected as much as we can.</td><td></td></tr><tr><td>Architecture Definition</td><td>Non-functional requirements</td><td>SETUP</td><td>2</td><td>All the Non-functional requirements related to the application are being mapped and collected using the Non-functional requirements template.</td><td>A non-functional requirement is a specification that describes the system&#x27;s operational capabilities and constraints that enhance its functionality. These may be speed, security, reliability, etc. It is very important to identify all key NFRs of the project and document it and get approval from stakeholders. Remember that non-implemented NFRs may lead to gaps in the stakeholders&#x27; expectations and even become a production incident in the future. This item refers to whether we are following the default company template. If not, the team should come up with an action plan to have everything documented according to the template.</td><td></td></tr><tr><td>Architecture Definition</td><td>Non-functional requirements</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The Non-functional requirements are approved by the stakeholders/business side.</td><td>A non-functional requirement is a specification that describes the system&#x27;s operational capabilities and constraints that enhance its functionality. These may be speed, security, reliability, etc. It is very important to identify all key NFRs of the project and document it and get approval from stakeholders. Remember that non-implemented NFRs may lead to gaps in the stakeholders&#x27; expectations and even become a production incident in the future. This item refers to whether the NFRs are being officially approved by the business or stakeholders. Items that are not officially approved are considered out of scope for the development, thus they cannot be considered as a bug or incident in case some issue occurs in the future.</td><td></td></tr><tr><td>Architecture Definition</td><td>Technical Refinement &amp; Design</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The technical refinement usually finishes on time (it is usually done before the planning of the upcoming sprint). The &quot;Heijunka&quot; concept is being followed accordingly.</td><td>The Architect should be able to finish all the technical preparation for the upcoming sprint one sprint beforehand. This is what we call &quot;technical refinement&quot;. The technical refinement should be done together with the PO / PPO and a document should be written to provide technical guidance for the developer, so when they start developing the sprint there are no technical doubts or big discussions about the solution. Heijunka is a Lean method for reducing the unevenness in a production process and minimizing the chance of overburden. The term Heijunka comes from Japanese and literally means leveling. It can help you react to demand changes and utilize your capacity in the best possible way.</td><td></td></tr><tr><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>There is a definition about how to load data for automated testing and this plan meets the project requirements.</td><td>Sometimes, in test automation it is necessary to load data to be able to reproduce and test critical business flows. This item is about whether the data required for test automation is properly planned to meet the business requirements being able to reproduce it during the test execution.</td><td></td></tr><tr><td>Architecture Definition</td><td>Non-functional requirements</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The top important non-functional requirements related to performance are defined and mapped within each business story.</td><td>A non-functional requirement is a specification that describes the system&#x27;s operational capabilities and constraints that enhance its functionality. These may be speed, security, reliability, etc. It is very important to identify all key NFRs of the project and document it and get approval from stakeholders. Remember that non-implemented NFRs may lead to gaps in the stakeholders&#x27; expectations and even become a production incident in the future. Ideally, the NFR should be identified and a sub-task should be created in the User Story to tackle the NFR related to that business story.</td><td></td></tr><tr><td>Architecture Definition</td><td>Non-functional requirements</td><td>SETUP</td><td>3</td><td>The Non-functional requirements related to security are defined and mapped within each individual business story.</td><td>A non-functional requirement is a specification that describes the system&#x27;s operational capabilities and constraints that enhance its functionality. These may be speed, security, reliability, etc. It is very important to identify all key NFRs of the project and document it and get approval from stakeholders. Remember that non-implemented NFRs may lead to gaps in the stakeholders&#x27; expectations and even become a production incident in the future. Ideally, the NFR related to security should be identified and a sub-task should be created in the User Story to tackle the NFR related to that business story.</td><td></td></tr><tr><td>Architecture Definition</td><td>Communication &amp; Alignment</td><td>SETUP</td><td>3</td><td>There is a goal in terms of target automated test coverage percentage and this target is aligned with the team and stakeholders.</td><td>Test coverage is defined as a technique that determines whether our test cases are covering the application code and how much code is exercised when we run those test cases. If there are 10 requirements and 100 tests created and if 90 tests are executed then test coverage is 90%. The type of automated testing applied will depend on each project. This item is about whether there is a goal in terms of percentage and whether the development team and stakeholders are aware of this goal. Having everyone aware of the goal will increase the engagement of everyone to achieve it.</td><td></td></tr><tr><td>Architecture Definition</td><td>Communication &amp; Alignment</td><td>SETUP</td><td>3</td><td>There is a goal for the metrics (Complexity, Duplications, Issues, Maintainability, Reliability, Comments, etc) related to static code analysis. The goal is communicated to the team members.</td><td>Static analysis, also called static code analysis, is the process of analyzing a computer program to find problems in it without actually executing it. One of the most famous static code analysis tools is SonarQube. However, it is not mandatory to use SonarQube as long as there is an equivalent tool. Static analysis tools will usually collect metrics like complexity, code duplications, maintainability issues, etc. This item is about whether there is a target for those metrics and the team members understand those targets.</td><td></td></tr><tr><td>Architecture Definition</td><td>Non-functional requirements</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>NFR is being reviewed every time business requirements changed (via backlog refinement, planning, customer feedback, etc)</td><td>A non-functional requirement is a specification that describes the system&#x27;s operational capabilities and constraints that enhance its functionality. These may be speed, security, reliability, etc. This item is about whether the NFR document is reviewed and updated in case of any changes.</td><td></td></tr><tr><td>Architecture Definition</td><td>Communication &amp; Alignment</td><td>SETUP</td><td>4</td><td>The DevOps lifecycle has been established and discussed with the team and the project stakeholders.</td><td>DevOps lifecycle is defined as a combination of different phases of continuous software development, integration, testing, deployment, and monitoring. A competent DevOps lifecycle is necessary to build superior quality software through the system. When a new project is getting started, it is very important to design what is going to be the DevOps lifecycle and discuss it with the team members and stakeholders. This item is about whether the DevOps lifecycle has been decided, documented, and discussed.</td><td></td></tr><tr><td>Architecture Definition</td><td>Non-functional requirements</td><td>SETUP</td><td>4</td><td>There is a target for the NFR metrics. The target is defined and documented.</td><td>A non-functional requirement is a specification that describes the system&#x27;s operational capabilities and constraints that enhance its functionality. These may be speed, security, reliability, etc. This item is about whether there are clear documented targets to achieve and the team is aware of those targets, for example, target speed, target page load time, etc.</td><td></td></tr><tr><td>Architecture Definition</td><td>Technical Refinement &amp; Design</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>The technical refinement document is very well structured; The team understands it and will rarely get blocked due to lack of details in the technical refinement; Continuous improvements are applied to the document through immediate feedback.</td><td>The Architect should be able to finish all the technical preparation for the upcoming sprint one sprint beforehand. One of the signs that the technical refinement was not done properly is when there are lots of technical blocks during the sprint. If this occurs, we should try to find out the root cause to check whether there is an issue with the technical refinement documents. If so, continuous improvement should be applied to the documentation based on the feedback provided by the development team.</td><td></td></tr><tr><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>Technical debts are kept monitoring and have plan to fix them.</td><td>Technical debt (also known as tech debt or code debt) describes what results when development teams take actions to expedite the delivery of a piece of functionality or a project which later needs to be refactored. In other words, it&#x27;s the result of prioritizing speedy delivery over perfect code. The Architect needs to keep track of the technical debts, so we can ensure that they are not increasing over time. Moreover, it is necessary to have a plan to reduce those debts in the upcoming sprints.</td><td></td></tr><tr><td>Architecture Definition</td><td>Communication &amp; Alignment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>There are rituals or meetings to share experiences about DevOps (kaizen meetings, C&amp;A, follow-up meetings).</td><td>This item refers to &quot;rituals&quot; (meetings, knowledge sharing sessions) that are proactively organized by the team to exchange experiences about the effectiveness of the DevOps practices and whether these meetings are proactively scheduled by the team.</td><td></td></tr><tr><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>SETUP</td><td>5</td><td>There is a strategy that helps to reduce the risk of production deployments (blue-green deployment, canary release, feature toggle, etc).</td><td>Deployment strategies are practices used to change or upgrade a running instance of an application. Blue-green deployment is a deployment strategy that utilizes two identical environments, a &quot;blue&quot; (aka staging) and a &quot;green&quot; (aka production) environment with different versions of an application or service. Quality assurance and user acceptance testing are typically done within the blue environment that hosts new versions or changes. User traffic is shifted from the green environment to the blue environment once new changes have been testing and accepted within the blue environment. You can then switch to the new environment once the deployment is successful.</td><td></td></tr><tr><td>Architecture Definition</td><td>Architecture &amp; Coding Guidance</td><td>SETUP</td><td>5</td><td>There are established metrics to measure how effective the DevOps practices are (lead time, deployment frequency, time to recovery, etc).</td><td>Once the project actives a certain maturity level on DevOps, it is expected that the team should start measuring data so the team will be able to apply continuous improvement on the DevOps lifecycle. That is also connected with the Lean&#x27;s Kaizen mindset. The metrics that are relevant to understand the DevOps lifecycle are: lead time, deployment frequency, time to recovery, etc. Lead time for changes is the length of time between when a code change is committed to the trunk branch and when it is in a deployable state. Understanding the frequency of how often new code is deployed into production is critical to understanding DevOps success. Many practitioners use the term &quot;delivery&quot; to mean code changes that are released into a pre-production staging environment, and reserve &quot;deployment&quot; to refer to code changes that are released into production.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The configuration that is specific for each environment, such as API endpoints and configuration for database connection are configured externally to the deployment package as environment variables.</td><td>Specific configuration for the environment should never be embedded or hardcoded in the source code. That may lead to mistakes because the build artifact could be mistakenly deployed to the wrong environment, or the team may forget to change this information before generating builds, leading to mistakes.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>The deployment to the dev, test environments are automated and executed in a CI/CD server (Jenkins, Azure DevOps, etc).</td><td>The deployment should be automated and centralized in a CI/CD server (or SaaS solution like Azure DevOps) and the deployment to the environments should be automated and executed directly from there. Relying on the local computer is not a good practice and it should be avoided as much as we can.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>It is possible to deploy database changes by running scripts that will incrementally upgrade the database according to the changes relevant to that deployment.</td><td>The deployment should be automated and centralized in a CI/CD server (or SaaS solution like Azure DevOps) and the deployment to the environments should be automated and executed directly from there. Relying on the local computer is not a good practice and it should be avoided as much as we can.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>It is possible to roll back the deployment (code and database).</td><td>One of the good practices when it comes to database management is to make sure that the changes on the database can be applied along with the code changes, so we will not rely on SQL scripts that need to be executed as a manual step before or after the code deployment. For doing that, it is necessary to adopt some solution such as &quot;Liquibase&quot; of equivalent may help you on that. Having a rollback strategy for the database is also important.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>The build to create an artifact for environments is automated, and there are no manual steps, excluding configuring environment variables/settings.</td><td>The build procedure should be very simple and should not require manual or complicated steps. This item is about whether the steps to generate a build targeting a specific environment is automated, meaning that there are no additional manual steps or configuration changes required.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The branches are often synchronized with their parent branches, at least before starting implementation or tests run.</td><td>Synchronizing the parent branch often is a best practice, that may prevent mistakes when performing complex manual merges. The more often the code is in sync, the less trouble the developer may have when merging. This item is about whether the branches are often synced with their parents and whether the frequency is considered adequate.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The team commits the runnable code with a certain frequency (at least once a day).</td><td>Committing runnable code with more frequency helps to prevent code losses in case one issue happens. It is also easier to debug and understand issues with the code by comparing it with the previous commit. It will also help to track bugs from the commit history. This item refers to whether the whole team is following this practice.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>Complex code (about 500 LOCs) merging is not performed with high frequency (twice per week).</td><td>Complex code merges should be prevented as much as possible by either merging them more often or having a Source Control Management strategy that allows less complex merging. Those merges may lead to conflicts that need to be solved manually. Mistakes may occur when manual merging is done. LOC means &quot;Lines of Code&quot;. A merging is considered complex when the number of lines is above 500 and the frequency is higher than twice a week.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The database scheme is exported and versioned in a source code version control tool (git, svn, etc).</td><td>The database scheme should be tracked along with the code that is compatible with that scheme version. Exporting the database scheme as configuration files is good practice once it allows database versioning and it does not rely on the manual operation to switch the database version. This item refers to whether there is a mechanism in place to export the database scheme as files (sql, yml, etc), and whether those files are tracked in the source control tool along with the source code.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>It is possible to roll back the database version when needed.</td><td>This item refers to whether is possible to roll back the database version when needed. The rollback operation should be very simple, it would require very simple steps or script execution.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>The current status of the build is visible to everyone in the team and there is immediate feedback when the build run or fail (email, chat message, etc)</td><td>The status of the build should be notified to everyone in the team. To increase the alignment with the development team, they should be notified every time that the build runs or fails. If the build fails, the team should take action to fix it as soon as possible.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>The build artifact is generated from a CI/CD server (Jenkins, Azure DevOps, etc)</td><td>The purpose of this item is to ensure that the build is automated and the build artifact is generated from a CI/CD server (it is not built using the developer&#x27;s local computer).</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>The time required to complete the build is acceptable (do not take more than 15 minutes), excluding execution time of automation test, quality metric collection, etc.</td><td>A build that takes too long to finish will become a bottleneck and it may cause unnecessary delays and wait time. This item is about whether the build does not take more than 15 minutes (excluding required time for test automation, quality metric collection, etc). If the build takes longer than 15 minutes, it is important to analyze the build steps to figure out whether this time could be reduced by identifying processes that can run in parallel, hardware improvements in the CI/CD server, etc.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>The build script steps are controlled using pipeline style or equivalent.</td><td>A continuous delivery (CD) pipeline is an automated expression of your process for getting software from version control right through to your users and customers. Every change to your software (committed in source control) goes through a complex process on its way to being released. This process involves building the software in a reliable and repeatable manner, as well as progressing the built software (called a &quot;build&quot;) through multiple stages of testing and deployment. Having the continuous delivery pipeline tracked in the code repository as scripts is the preferable way to implement it.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>A merge commit to (a) specified, main, or default branch(es) will trigger the build and the unit tests will run during the build.</td><td>The Unit tests should run periodically and be strategically triggered whenever new code is committed or merged to specific branches. This will help to ensure that the new code that is being developed is not breaking other areas of the application. The sooner the problem is identified the easier and faster will be to have it fixed. This item refers to whether the CI/CD pipelines are set to react upon code merge or commit.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>2</td><td>The monitoring tools are measuring CPU usage, Disk space, Response time, memory, etc. If there is an issue with any of those infrastructure metrics the team will get notified.</td><td>This item refers to whether infrastructure monitoring is in place and whether it monitors CPU, Disk space, response time, and memory. The notification is a must. There should be a team in charge of getting those notifications and take action accordingly in case of need.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>2</td><td>The application monitoring tools are measuring API availability (any unexpected error 404, 403, 500, etc), key functionalities, background jobs, etc. If there is an issue with any of those application metrics the team will get notified.</td><td>The application should be monitored 24/7 through monitoring tools that will try to reach the application and make for example API calls, and check if it responds as expected. It is a good practice to map all the critical business flows and make sure that all those flows are getting monitored. A notification group should be created so an email, phone call or chat message is sent in case of any issues.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>There is a flow of continuous development until the story gets deployed to production.</td><td>Continuous development is a software development process that encompasses multiple DevOps processes, including continuous integration, continuous testing, continuous delivery, and continuous deployment. This item refers to whether there is a continuous development flow from the moment that the story gets developed until it is deployed to production.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The foundation of the application architecture is being followed by the Development team as it was originally described in the documentation (application layers, frameworks, logging mechanism, error handling mechanism, transaction control mechanism).</td><td>This item refers to whether the Development team does follow the architecture defined and documented in the previous steps. It is very important for the Architect to keep reviewing the code created by the development team to understand whether there are any gaps between the definition and the execution.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The Software Architect is not overloaded by only giving support to the team.</td><td>If the development team requests support too often to the architect there might be an issue with the documentation, technical refinement, solution communication, or knowledge of the team members. It is very important to identify this issue by analyzing the root cause and come up with action items that may reduce the time spent by the Architect. If the Architect is not too overloaded with those tasks, then you should mark this item as DONE.</td><td></td></tr><tr><td>Architecture Management</td><td>People &amp; Technical Skills Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The knowledge map is maintained by the team members and updated in a frequency considered adequate.</td><td>The skill map (knowledge map) document should be regularly updated (not more than 3 months). This document is very useful for the Architect to prepare/propose training sessions for the developers based on the gaps identified. This item is related to whether there is this document that is always up to date where is possible to see the team skills.</td><td></td></tr><tr><td>Architecture Management</td><td>Project Plan &amp; Architecture Roadmap</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>Pros and Cons of technical decisions, comparing to the others solutions, are recorded for later reference.</td><td>Because the development team and Architects usually move from a project to another, it is very important to keep track of the history of the technical decisions as well as the pros and cons and reasons behind it. This will help to keep people on the same page when it comes to project background. This item refers to whether those big decisions are documented (wiki, Docx, videos, or any other way).</td><td></td></tr><tr><td>Architecture Management</td><td>Project Plan &amp; Architecture Roadmap</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>All big technical decisions are being taken through engagement and awareness of all technical team members, architects and developers.</td><td>Big technical decisions are any decisions that affect the architecture big picture: integration with third parties, interfaces, technology stack, new product adoption, infrastructure changes, changes on the frameworks used, etc. Those decisions should be taken through the engagement of the development team and technical stakeholders involved in the project, and not only by the Architect. This will help to put everyone on the same page and increase the awareness and ownership of the developers.</td><td></td></tr><tr><td>Architecture Management</td><td>Project Plan &amp; Architecture Roadmap</td><td>SETUP</td><td>2</td><td>All team members, including the team responsible for the development, infrastructure, business, and project sponsors are aware of the planned activities for the project.</td><td>It is very important to have everyone on the same page in regards to the planned activities for the project. This is a good way to identify risks, concerns, or dependencies that may affect people with different scopes. Sharing the technical roadmap that includes all the key milestones of the project with everyone in meetings is a good way to make everyone aware of the planned activities. If there is any change in the original plan, everyone should be notified as soon as possible.</td><td></td></tr><tr><td>Architecture Management</td><td>Risks &amp; Blocks management</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The technical risks are raised through monthly risk meetings that are conducted together with the Development team; the action plans raised during the meeting are included as tasks in the ticket system (JIRA, Azure DevOps) and followed up in the next meeting.</td><td>The risk meetings are usually conducted by the Scrum Master or responsible Manager. During those meetings, the Architect and Development team should analyze and raise all technical risks. The technical risks should always have a responsibility in charge, and the action item should be registered in the ticket system (JIRA, ADO). The result from the action items should be followed up in the next risk meeting.</td><td></td></tr><tr><td>Architecture Management</td><td>Technical Backlog management</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The technical gaps are being managed so the technical debts are not increasing over time. There is a plan to reduce the technical debts.</td><td>A technical gap is any technical issue that is identified and acknowledged by the Architect in the current application. For example, anti-pattern code, performance issues, CI/CD pipelines not working appropriately, etc. This item refers to whether the number of technical gaps is not growing over time. The gaps identified should be registered in the ticket system.</td><td></td></tr><tr><td>Architecture Validation</td><td>Architecture Evaluation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>The defects identified during the code reviews become defects in the ticket control system (JIRA or similar) and are part of the quality metrics.</td><td>It is very important to register the feedbacks from the code review process in the ticket system (JIRA, ADO) so the metrics can be collected later on, making it possible to identify whether the issues are reducing over time or how long the developers take to fix those issues.</td><td></td></tr><tr><td>Architecture Validation</td><td>Architecture Evaluation</td><td>PREPARATION (Sprint 0)</td><td>2</td><td>The code quality is measured through static code analysis tools.</td><td>Static code analysis is a method of debugging by examining source code before a program is run. It&#x27;s done by analyzing a set of code against a set (or multiple sets) of coding rules. SonarQube is the most famous tool to perform static code analysis.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>Unit tests are coded and planned within each business story.</td><td>Unit testing is a type of testing in which individual units or functions of software testing. We has a rule which states that the test coverage of all applications should be above or equal to 80%. Ideally, the tasks to develop the Unit Testing should be included within the relevant User Story.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>Manual test cases follow the template to be on the same page to all team members to execute them. The content of test cases must be informative (enough step/action, input value, expects, etc)</td><td>A test case is a sequence of steps, to test the correct behavior/functionality, features of an application. Test cases should be always documented with a standard template before being executed. The test cases must be simple and easy to understand.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>2</td><td>Unit test cases, as well as Assert conditions, are always updated every time business logic is changed.</td><td>Every time that some business logic is reviewed, it is a good practice to review all the unit test cases related to that business story and ensure that all tests are still passing and still make sense for that part. Also, we may want to add additional assertions based on the changes made.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>RELEASE</td><td>2</td><td>The top prioritized Non-functional requirements are mapped using the Non-functional template and are in fact validated.</td><td>A non-functional requirement is a specification that describes the system&#x27;s operational capabilities and constraints that enhance its functionality. These may be speed, security, reliability, etc. Besides mapping all the NFR of the application it is also important to validate them. This item is about whether the NFR that were agreed with the business is in fact being validated (performance, security, scalability, availability, etc).</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>When there is a dependency between modules, the artifacts of the components are published in a repository (nexus, artifactory, etc).</td><td>An artifact repository, which can also be called an artifacts management tool, is an application designed to store, version, and deploy artifacts for builds. This kind of tool can help to prevent mistakes about the version of the artifact especially in complex scenarios when there is a dependency between modules (for example, back end and client-side).</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>3</td><td>The team can take action when infrastructure monitoring is showing any problems (for example, contact the responsible for fixing it).</td><td>The infrastructure should be monitored 24/7. If anything is wrong with the infrastructure (CPU, disk space, memory, availability, response time, etc ) an alert should be raised. This item refers to whether the team can take action whenever those alert messages come, fixing or contacting the person in charge for fixing it.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>3</td><td>The team can take action when application monitoring is showing any problems (for example, contact the responsible for fixing it).</td><td>The critical business flows of the application should be monitored 24/7. If anything is wrong an alert should be raised. This item refers to whether the team can take action whenever those alert messages related to the application monitoring come, fixing it, or contacting the person in charge for fixing it.</td><td></td></tr><tr><td>Architecture Definition</td><td>Technical Refinement &amp; Design</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The planning meetings usually go smoothly; the technical refinement usually is on time and there are no missing definitions; the team understands the technical documents and is comfortable with the task estimations.</td><td>The Architect should be able to finish all the technical preparation for the upcoming sprint one sprint beforehand. This is what we call &quot;technical refinement&quot;. The technical refinement should be done together with the PO / PPO and a document should be written to provide technical guidance for the developer, so when they start developing the sprint there are no technical doubts or big discussions about the solution. All those documents should be ready before the sprint planning!</td><td></td></tr><tr><td>Architecture Definition</td><td>Technical Refinement &amp; Design</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>There are not many changes in the architecture definition during the sprint development.</td><td>The Architect should be able to finish all the technical preparation for the upcoming sprint one sprint beforehand. One of the signs that the technical refinement was not done properly is when there are lots of changes in the architecture definition during the sprints. If this is happening, the suggestion is to try to review the documentation provided and try to talk to the developers to find out the pain points so we can improve from that.</td><td></td></tr><tr><td>Architecture Definition</td><td>Technical Refinement &amp; Design</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>There are not many blocks during the sprint development due to a lack of details in the technical refinement.</td><td>The Architect should be able to finish all the technical preparation for the upcoming sprint one sprint beforehand. One of the signs that the technical refinement was not done properly is when there are lots of technical blocks during the sprint.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The team members are open-minded for experimentation and are keen to try alternatives and propose improvements.</td><td>One of the fundamental characteristics of DevOps high-skilled team members is the keenness to propose and try new things. The team should have an open culture of knowledge sharing, and everyone should step in and propose improvements or changes. This item refers to whether the team has this mindset. If not, action items to increase the engagement of the team should be tried.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The scripts for database changes are automatically deployed in the deployment pipeline.</td><td>This item is about whether there is a solution that will allow the automation in the CI/CD pipelines that allow to manage the database changes (Liquibase or equivalent)</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The backup strategy is automated for all environments (database, files, etc).</td><td>It is very important to have a backup strategy automated, so regular backups will be taken from the critical resources regularly and not rely on manual steps. (for example, backups from the database will be taken each 2 hours automatically by the CI/CD server)</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>The deployment can be executed in a single click for Dev, RC and Stage environments.</td><td>The deployment procedure should be very simple and should not require manual or complicated steps. In the ideal situation, it should require only a single click. Sometimes it can be fully automated and make it be triggered by a Pull request merge.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>The rollback can be executed in a single click for Dev, RC and Stage environments</td><td>The rollback procedure should be very simple and should not require manual or complicated steps. In the ideal situation, it should require only a single click.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The deployment pipeline contains steps/tasks reflecting the actual development flow and release flow.</td><td>The deployment pipelines consist of automated scripts composed of steps or tasks implemented in the CI/CD server. Those pipelines should be implemented according to the development flow and release flow. (the pipelines should be the actual implementation of the development and release flows except for steps cannot be represented in common sense)</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>There is a continuous improvement mindset in the team.</td><td>The term continuous improvement can be very abstract if not placed in a specific context. Explained shortly, it is a never-ending strive for perfection in everything you do. In Lean management, continuous improvement is also known as Kaizen. Kaizen originated in Japan shortly after the end of the Second World War. It gained massive popularity in manufacturing and became one of the foundations of Toyota&#x27;s rise from a small carmaker to the largest automobile manufacturer on the planet.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The frontend performance is being constantly validated using browser developer tools such as Chrome Lighthouse, Google Page Speed or equivalent.</td><td>If you make people wait on your website, if you deliver a slow experience, it will have fundamentally negative implications for the business. It is important not only to validate the response time of the backend part of the application but also the frontend as well. In the frontend performance test, it is possible to identify whether the Javascript code written is performative, whether the images utilized are adequated, whether the time to render the webpage is good, etc.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>The pre-production environment is very similar to production (except for the database can use mock data).</td><td>The main purpose of this item is to prevent issues or bugs related to different server configurations or differences in the environments. If the bug is only &quot;reproducible&quot; on production this is an indicator that the environments are not similar enough.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The team follows the SCM (Source Control Management) plan and the team spends low effort when managing the branches and merging the code.</td><td>One indication that the Source Control Management plan needs to improve is when the team spends too much effort while merging code. This item refers to whether this situation is happening very often and whether there is space for improvements in this area.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The database objects follow the same policies of the code, and it is possible to detect conflicts on database changes when merging the code.</td><td>The database scheme should be tracked along with the code that is compatible with that scheme version. Exporting the database scheme as configuration files is good practice once it allows database versioning and it does not rely on the manual operation to switch the database version. This item refers to whether there is a mechanism in place to export the database scheme as files (sql, yml, etc), and whether those files are tracked in the source control tool along with the source code and it is possible to identify conflicts in the database changes when merging code.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>There is a maximum time definition of build execution. Any increasing time of the build process has a clear and acceptable explanation.</td><td>There is an item in the Architecture Maturity that states that the build should not take longer than 15 minutes. Rather than that, we can set custom targets depending on the context of each project. For example, if your build takes only 2 minutes to complete, you might want to set 5 minutes as the maximum execution time of your build. Any increase in the time should be investigated and solved.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>There is an environment for performance tests and its configuration is very similar to the production environment.</td><td>Ideally, there should be a load test (performance test) environment that is as similar as possible to the production one. There is no point in running a performance test against non-production environments, because the server configuration in terms of CPU, memory, etc is way lower than production. Because the production environment is usually expensive, a performance test environment can be temporarily provisioned as a perfect copy of the production environment and it can be released as soon as the performance test is done.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>All the necessary tools are being leveraged to manage the database changes properly (liquibase, flyway, custom scripts, etc).</td><td>One of the good practices when it comes to database management is to make sure that the changes on the database can be applied along with the code changes, so we will not rely on SQL scripts that need to be executed as a manual step before or after the code deployment. For doing that, it is necessary to adopt some solution such as &quot;Liquibase&quot; of equivalent may help you on that. Having a rollback strategy for the database is also important. This item is about whether this kind of tool is being used (if needed).</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>The system configuration (except for sensitive information) is exported as code, and it is versioned in a repository (git, svn, etc). Given a commit hash, it is possible to track both the code and database version that works with that code.</td><td>This item refers to whether configuration files related to the server, database, endpoints, etc are versioned in the repository together with the source code. Having this information just in the database or in the configuration dashboard of the server is not a good practice unless it contains sensitive information such as API keys or passwords. In this case, it is better to use tools like AWS KMS (Key Management Services), Azure Key Vault, etc.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>The local environment (developer environments) provisioning is automated through scripts and/or virtual machines (vagrant, docker, etc) and requires very low effort.</td><td>The setup process for the developer environment (local computer) should not be too complicated. If the effort to set up the local environment is too high, it is better to consider automating it using scripts or virtual machines so it will require low effort. Having a local environment easy to set up will save a lot of time for the Architect and other team members and it will prevent the developers from getting blocked due to issues in their computers, making the development more efficient.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>The team has an infrastructure access policy (follow security checklist &amp; specific-team definition), or there is an available focal point in the third-party company/partner who can be easily contacted.</td><td>It is necessary to have a strong access policy to grant permissions in the infrastructure resources (web servers, databases, network resources, etc), or the access of the infrastructure resource should be handled by a company or partner that can be easily contacted in case of need. Having a strong process will help to prevent security incidents. It is important to follow all definitions available in our Security Checklist.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>A pull-request to (a) specified, main, or default branch(es) will trigger the build and the unit tests will run during the build.</td><td>The Unit tests should be strategically triggered whenever a new Pull-request is sent. This will help to ensure that the new code that is being developed is not breaking other areas of the application. The sooner the problem is identified the easier and faster will be to have it fixed. This item refers to whether the CI/CD pipelines are set to react upon pull request.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>Source code quality metrics (Code Coverage, Code Smells, etc) are automatically run and collected as tasks of the builds on specified branches.</td><td>The source code quality metrics are metrics extracted by static code analysis generated by tools like SonarQube. In order to ensure that the code metrics are always up to date, the static code analysis should be part of the tasks from the build.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>3</td><td>At least key members of the team can see the application monitoring metrics.</td><td>Key members mean senior developers, Architects, managers, etc. The metrics should be visible and available for everyone. Making it available through a dashboard is a good way to put everyone on the same page. This item refers to whether at least the key members can see the monitoring metrics.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The business stories are prioritized through value engineering, using consistent methodologies to support it when needed (design thinking, A3, etc).</td><td>To have a good alignment with the team, the business stories should be prioritized through value engineering using methodologies that will help to increase the engagement of the development team putting business and technical people on the same page. Some methodologies help on the business understanding, for example A3 workshop or design thinking. The Architect and technical leaders should be engaged on those kind of activities to increase the knowledge about the product or application that will be developed.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The technical tasks that are action plans raised during the Risk Meetings (or the meetings which contain Risk discussion) are being executed by the responsible.</td><td>The Risk management meeting is a meeting in which the team tries to raise and classify the risks of the project. It is usually a bi-weekly meeting and a spreadsheet template is used to input the risks. Depending on the case, there might be some technical risks that require action from the Architect or development team. The Architect should follow up on the technical action items raised from the Risk Meetings and make sure that there is a plan to execute those.</td><td></td></tr><tr><td>Architecture Management</td><td>People &amp; Technical Skills Development</td><td>SETUP</td><td>3</td><td>All the necessary KT (Knowledge Transfer) meetings are executed according to the plan, and the team has no knowledge gaps related to the covered areas.</td><td>At the beginning of the project, or whenever the team is taking over new scopes or responsibilities that are currently under other parties&#x27; scope, it is very important to ensure that we are scheduling knowledge transfer sessions to tackle the uncertain points. The knowledge transfer may also affect the project roadmap, so it should be clearly stated in the roadmap as well. This item refers to whether the team is always planning knowledge transfer sessions when needed.</td><td></td></tr><tr><td>Architecture Management</td><td>People &amp; Technical Skills Development</td><td>SETUP</td><td>3</td><td>The technical knowledge gaps are identified in the team and the necessary improvement is planned and executed.</td><td>Based on the knowledge map, the technical knowledge gaps in the team should be identified and actions should be taken in case of need. For example, if the project uses nodejs technology but just 2 from 5 developers know it, the team should create a plan to have technical training so people can improve their skills in the important technology stacks.</td><td></td></tr><tr><td>Architecture Management</td><td>Risks &amp; Blocks management</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The action plans originated from the Architecture maturity level PDCA meetings (C&amp;A) are tracked in the ticket system (JIRA, Azure DevOps) and the progress is followed up in the next meeting.</td><td>The Architecture maturity PDCA meeting stands for Plan Do Check Act (also known as Architecture C&amp;A). This refers to this meeting when we go through the checklist items checking whether the best practices are being followed in the project. The action items discussed during this meeting should all be registered in the ticket system (JIRA, ADO). Moreover, the status of the action items should be verified in the next interaction. This item refers to whether the tasks are registered and followed up in the next meeting.</td><td></td></tr><tr><td>Architecture Management</td><td>Technical Backlog management</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>Recurrent follow-up meetings are conducted by the technical responsible in order to discuss the goals and issues that came out from the code quality analysis.</td><td>There should be a goal-setting related to the quality metrics that came out from static code analysis (SonarQube or equivalent). The Architect or Developers should schedule follow-up meetings to discuss the current issues in the source code as well as the plan to solve them.</td><td></td></tr><tr><td>Architecture Management</td><td>Technical Backlog management</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>Recurrent follow-up meetings are conducted by the technical responsible in order to discuss the goals and issues that came from the test automation and coverage percentage.</td><td>There should be a goal-setting related to the coverage of testing automation. The Architect or Developers should schedule follow-up meetings to discuss the current issues or gaps in the automated testing scripts as well as the plan to solve them.</td><td></td></tr><tr><td>Architecture Validation</td><td>Architecture Evaluation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The code review is performed by the development team and they do not depend on the Software Architect.</td><td>Considering that all rules are documented, the development team should be able to understand are the things that should be reviewed during the core review process. In that sense, they should not only depend on the Architect to do the code review.</td><td></td></tr><tr><td>Architecture Validation</td><td>Architecture Evaluation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>The code quality is visible to everyone in the team and there is immediate feedback whenever the quality has decreased.</td><td>The team should have code quality goals agreed and the CI/CD pipelines should at least notify everyone whenever the code is not compliant with those goals. Static code analysis tools such as SonarQube can be used to measure the code quality.</td><td></td></tr><tr><td>Architecture Validation</td><td>Architecture Evaluation</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>The build will fail if the code that was created does not match the code quality goals.</td><td>The team should have code quality goals agreed and the CI/CD pipelines should be set to not allow going forward with code that is not compliant with those goals. Static code analysis tools such as SonarQube can be used to measure the code quality.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>Code coverage should not be decreased. Any decrease requires explanation and approval by the Architect (consulted with the architecture team).</td><td>The code coverage in general should not decrease over time. A rule should be set in the build pipelines to prevent from going forward with new code if the code coverage has decreased. This item refers to whether the practice is in place.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>Test cases are always up to date, updated every time a business logic is changed.</td><td>Every time that some business logic is reviewed, it is a good practice to review all the test cases related to that business story and ensure that all are correct and still make sense after the changes. Also, we may want to add additional test cases based on the changes made.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>If there is a gap between the test coverage target and the current situation, the necessary tasks are mapped and converted into defects in the ticket system (e.g. JIRA, ADO...).</td><td>It is important for the Architect and development team to proactively identify test coverage gaps based on the target covered set in agreement with everyone. The tasks to increase the testing coverage should then be created and planned to be executed in the upcoming sprints being able to little by little reduce the gap.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>PREPARATION (Sprint 0)</td><td>3</td><td>The automated testing is integrated into the build, and the build will fail if the test coverage percentage is not enough ( &lt; 80% ) or if the test is failing.</td><td>Unit testing is a type of testing in which individual units or functions of software testing. MTI has a rule which states that the test coverage of all applications should be above or equal to 80%. Making the build pipeline fail in case the code coverage does not achieve the 80% is the recommended way to ensure it. You may additionally create a rule to not allow the code coverage to be worst if already above 80%.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>3</td><td>Solution Review meetings are scheduled whenever it is necessary for complex architectures; Software Architects from different projects are invited to join so they can provide feedback on the architecture.</td><td>A Solution Review meeting is a meeting where other Architects from different projects are invited to advise about one architecture diagram, solution, or technical issue. In case there is any problem that the Architect is struggling with, the team should not hesitate to create an event on the calendar and invite CTA and other Architects from different projects.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>RELEASE</td><td>3</td><td>The issues identified during the performance tests are converted to defects and registered in the ticket system.</td><td>Performance testing is a non-functional software testing technique that determines how the stability, speed, scalability, and responsiveness of an application hold up under a given workload. This item is about whether the performance issues found during the performance testing are being registered in the ticket system (ADO, JIRA, etc) so the metrics about performance bugs can be collected later on.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>PREPARATION (Sprint 0)</td><td>4</td><td>The deployment to the pre-production environment is automated and executed in a CI/CD server (Jenkins, Azure DevOps, etc).</td><td>The deployment should be automated and centralized in a CI/CD server (or SaaS solution like Azure DevOps) and the deployment to the environments should be automated and executed directly from there. Relying on the local computer is not a good practice and it should be avoided as much as we can.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>PREPARATION (Sprint 0)</td><td>4</td><td>The deployment can be executed in a single click for the Production environment.</td><td>The deployment to the production environment should be as automated as possible. Ideally, there should be no manual steps or scripts that rely on human operation. It is understandable that sometimes due to the process, there should have approval for the release to go live. But even in those cases, if the release is approved there should be an automatic way to deploy it to production upon approval. You can mark this item as done in case your deployment to production is fully automated and it requires 1 click only.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>PREPARATION (Sprint 0)</td><td>4</td><td>The rollback can be executed in a single click for the Production environment.</td><td>The deployment rollback should be as automated as possible. Ideally, there should be no manual steps or scripts that rely on the human action to roll back. We should be able to roll back as fast as possible. You can mark this item as done in case your deployment rollback is fully automated and it requires 1 click only.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>4</td><td>System is being appied GitOps - the infrastructure and its configuration is exported as code, and it is versioned in a repository (git, svn, etc).</td><td>This item refers to whether infrastructure services related to the computing services, storage (database, files..), network, etc and their configuration are versioned in the repository together with the source code.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>4</td><td>All the application and database logs for the environments (at least PROD) are available and centralized in a log collector or solution (loggly, kafka, custom solution, etc).</td><td>Making all the logs available and centralized in a single log collector solution will optimize the debugging process and increase the traceability of issues in case of need. By using solutions like Loggly, Kafka it is possible to understand the user request end-to-end and identify issues without having to keep switching between servers and applications.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>When it is necessary to change some configuration in the server, this change is applied using scripts (the changes are not applied manually).</td><td>Besides having all infrastructure as a code, any configuration change in the server should be handled through scripts or files. Manual changes in the cloud provider dashboard should be prevented as much as possible to prevent mistakes.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>4</td><td>When a new environment needs to be created there are scripts that allow the team to do it automatically with no manual steps.</td><td>One of the big advantages of having all infrastructure as a code is that the environment creation can be automated. This will reduce the risks of forgetting some manual steps when creating new environments, and it will also save a lot of time for the team members. This item is about whether the provisioning of a new environment is fully automated and it will not rely on manual steps.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>It is possible to check the deployment status through smoking test scripts.</td><td>Smoke Testing is a software testing process that determines whether the deployed software build is stable or not. Smoke testing is a confirmation for QA team to proceed with further software testing. It consists of a minimal set of tests run on each build to test software functionalities. Smoke testing is also known as &quot;Build Verification Testing&quot; or &quot;Confidence Testing.&quot; Smoking test scripts are automated test cases that can be executed to identify whether the environment and application are working according to what was expected. A smoking test script may go through the basic functionalities of the application to identify trivial issues or problems. This practice is very helpful in the case that some new release is deployed to production, or whenever there is a new environment that requires validation.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>4</td><td>It is possible to scale up or scale down the server resources automatically to respond to demand changes.</td><td>This item refers to whether the web servers in production are set in an autoscaling group or whether the cloud resources are set for upscaling in case of a sudden traffic increase. Ideally, it should happen automatically with no human intervention required.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>4</td><td>Everyone in the team can see the infrastructure monitoring metrics.</td><td>The infrastructure monitoring metrics should be visible to everyone and available in a virtual dashboard that is updated in real-time.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>4</td><td>The team can fix the issue when infrastructure monitoring is showing any problems.</td><td>One of the best practices on DevOps culture is to reduce the separation of the application development and infrastructure development teams as much as possible. Everyone should be engaged in both development and infrastructure matters, so this item refers to whether the development team can fix issues by themselves whenever the infrastructure monitoring is showing any issues.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>4</td><td>The team can fix the issue when application monitoring is showing any problems.</td><td>One of the best practices on DevOps culture is to have the team engaged and accountable for the issues identified from the production monitoring. This item refers to whether the whole development team has the ownership and autonomy to fix the issues shown in the application monitoring (deploy can still be performed by designated people).</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>4</td><td>There are business monitoring tools for production and there is a team in charge of following up.</td><td>Business Monitoring is the proactive and process-oriented monitoring of the user flows in the application. It consists of mapping all the critical indicators for the business and making them visible in real-time so it will increase the concern and awareness of the Development team towards the business targets. For example: In an eCommerce application, we may want to monitor the conversion rate for products included in the shopping cart, or the total number of active users, the total number of sales, or any other business-oriented metric. If the Development team identifies that the conversion rate is too low after a release, they may want to proactively notify people responsible by following it.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>4</td><td>Everyone in the team can see the business monitoring metrics.</td><td>Business Monitoring is the proactive and process-oriented monitoring of the user flows in the application. It consists of mapping all the critical indicators for the business and making them visible in real-time so it will increase the concern and awareness of the Development team towards the business targets. For example: In an eCommerce application, we may want to monitor the conversion rate for products included in the shopping cart, or the total number of active users, the total number of sales, or any other business-oriented metric. This item refers to whether there is an online dashboard where everyone in the team can check the business monitoring metrics.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>The team members are considered multi-functional and most of the people in the team know the solution end to end (frontend, backend, and infrastructure).</td><td>A good way to shorten the distance among frontend developers, backend developers, and infrastructure people is to ensure that everyone in the team is multi-functional in the sense that they have minimum knowledge in both frontend and backend and also infrastructure areas. This item is whether most of the team members have this knowledge. If not, you should think about action items to reduce the knowledge gap of the team members.</td><td></td></tr><tr><td>Architecture Management</td><td>Technical Backlog management</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>Recurrent follow-up meetings are conducted by the technical responsible in order to discuss the goals and issues that came from the security test metrics.</td><td>Security is a big concern for OTS, so there should be very clear targets about security (for example, not having critical and medium issues from the Security test, and limiting the maximum amount of low issues raised from the Security test, etc). Those targets as well as the current situation of the application should be discussed in recurrent meetings so we ensure that there is a plan to reduce those issues. This item is about whether those follow-up meetings are being scheduled or at least those issues are being discussed during Architecture PDCA meetings.</td><td></td></tr><tr><td>Architecture Validation</td><td>Architecture Evaluation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>The number of defects identified during the code reviews is reducing over time.</td><td>Every time that an issue is identified during the code review, it should be registered in the ADO or JIRA as a bug! This is very important for metrics purposes. One of the indicators that the development team is learning with the feedbacks from the code review, is when the amount of defects identified during the code review is reducing over time.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>Have a plan to implement automation tests and follow them. The plan is reviewed periodically.</td><td>The testing automation strategy should be implemented as much as we can. Having a testing automation strategy will increase the quality of the application. The testing automation strategy depends on the type of application and technology utilized in the project. The testing pyramid strategy is one of the recommended ways to cover test cases <a href="https://martinfowler.com/articles/practical-test-pyramid.html" target="_blank" rel="noopener noreferrer">https://martinfowler.com/articles/practical-test-pyramid.html</a>. This item refers to whether there is a plan to implement the test automation and whether there are meetings to discuss and review it periodically.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>The team has a lean mindset (avoid unnecessary bureaucracy, documentation, overload added through unnecessary processes, etc).</td><td>Eliminating wasteful activities is one of the most important prerequisites for building a successful company. This concept is an integral part of Lean thinking. The idea of eliminating waste originates from the Toyota Production System.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>There is buy-in on DevOps culture from the project stakeholders.</td><td>DevOps culture is all about a shared understanding between developers and operations and sharing responsibility for the software they build. That means increasing transparency, communication, and collaboration across development, IT/operations, and &quot;the business&quot;. The project stakeholders are technical people and business people involved in the project. The DevOps mindset should be disseminated across to all parts so everyone understands the importance of applying it in the project. This item refers to whether there is buy-in on DevOps culture from the project stakeholders. If not, you may want to come up with some actions that will help to increase the engagement of people.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>There is a mindset on focusing on the product itself, rather than focusing on solutions.</td><td>The solution should solve a business need, not the other way around. Starting from providing a solution is not a good way to start a project. Therefore, this item refers to whether everyone involved in the project (including POs and the other business stakeholders) has the mindset about focusing on the product itself, rather than on solutions.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>The acceptance tests are automated and integrated into the build (behat, selenium, etc).</td><td>Acceptance testing is a test conducted to determine if the requirements of a software specification are met. Whenever new requirements come into the backlog and the User Story is included in the Sprint, it is possible to create automated testing related to that User Story so the test scripts are later on the build pipelines will run them. This will ensure that all the acceptance tests should pass otherwise it is not possible to go forward with the build.</td><td></td></tr><tr><td>Architecture Execution</td><td>Software Development</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>Every technical change that is done will bring benefit or value to the project (either is necessary to reduce the technical risks or new NFR or business requirement requested by stakeholders).</td><td>Any changes on the architecture should be triggered by some request from the business (NFR or new business story) or should be motivated by kaizen activities based on best practices that are not followed and may bring risks to the project/product. In both cases, the value of the change, as well as the risks involved, should be very clear for both the development team and stakeholders. There is no use in having a great architecture if the business requirements and value is not being generated to the users. Value generation should always be the ultimate target.</td><td></td></tr><tr><td>Architecture Management</td><td>Technical Backlog management</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>Recurrent follow-up meetings are conducted by the technical responsible in order to discuss the goals and issues that came from the performance test metrics.</td><td>There should be a goal-setting related to the coverage of performance testing scripts. The Architect or Developers should schedule follow-up meetings to discuss the current issues or gaps in the performance testing scripts as well as the plan to solve them.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>If a bug is found, Unit Tests are implemented for that scenario as part of the bugfix to avoid recurrence of the same issue.</td><td>Whenever a bug is found, a good practice is to implement unit tests to cover the test case related to it. That will ensure that the same bug will not occur again and it will little by little enhance the quality of the test coverage of the application. This item refers to whether the team has this internal rule when fixing bugs.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>Have the test automation and its strategy results in a low occurrence of technical problems and it usually identifies real problems when the test fails.</td><td>Ideally, we should be able to identify all the critical business flows in the application and create a test automation strategy to cover all the critical areas. The test automation should be efficient enough to work most of the time without technical problems or false positives, meaning that if the test failed it is because a bug was identified.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>The performance of the application is being continuously tested through automation in the deployment pipelines.</td><td>Performance testing is a non-functional software testing technique that determines how the stability, speed, scalability, and responsiveness of an application hold up under a given workload. This item refers to whether there are periodical jobs that are continuously testing the performance of the application.</td><td></td></tr><tr><td>Architecture Validation</td><td>Continuous Testing</td><td>DEVELOPMENT (Sprint 1-N)</td><td>4</td><td>If the build breaks due to the automated tests, the issue is immediately fixed by the team as a maximum priority.</td><td>The development team should be proactive to fix the automated tests as soon as the issue occurs. This should be taken as the highest priority.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>5</td><td>Deployment scripts are kept as code in the repository.</td><td>The deployment pipelines consist of automated scripts composed of steps or tasks implemented in the CI/CD server. Those scripts should be tracked and their versions should be controlled in the code repository.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>5</td><td>The deployment can be executed automatically for the Production environment (Except for release approval)</td><td>The deployment to the production environment should be as automated as possible. Ideally, there should be no manual steps or scripts that rely on human operation. It is understandable that sometimes due to the process, there should have approval for the release to go live. But even in those cases, if the release is approved there should be an automatic way to deploy it to production upon approval.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>PREPARATION (Sprint 0)</td><td>5</td><td>Have log retention policy to support trace whole log for every single request (e.g. Add GUID identifier for logs of each request)</td><td>GUID (aka UUID) is an acronym for &#x27;Globally Unique Identifier&#x27; (or &#x27;Universally Unique Identifier&#x27;). This item refers to whether the log retention is good enough and whether a GUID is attached to each request, so in case we need to track some issue it is possible to track down all the information by searching by GUID and immediately group together all the relevant log entries for that request.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>5</td><td>The business monitoring tools are measuring key indicators (conversion rate, number of sold items, average response time, etc). If there is an issue with any of those key indicators the team will get notified.</td><td>Business Monitoring is the proactive and process-oriented monitoring of the user flows in the application. It consists of mapping all the critical indicators for the business and making them visible in real-time so it will increase the concern and awareness of the Development team towards the business targets. For example: In an eCommerce application, we may want to monitor the conversion rate for products included in the shopping cart, or the total number of active users, the total number of sales, or any other business-oriented metric. If the Development team identifies that the conversion rate is too low after a release, they may want to proactively notify the business stakeholders. It also helps the Developers to understand better the business thus generate fewer bugs or mistakes due to misunderstanding the business targets.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>5</td><td>The team can take action when business monitoring is showing any problems (for example, contact the business responsible).</td><td>Business Monitoring is the proactive and process-oriented monitoring of the user flows in the application. It consists of mapping all the critical indicators for the business and making them visible in real-time so it will increase the concern and awareness of the Development team towards the business targets. For example: In an eCommerce application, we may want to monitor the conversion rate for products included in the shopping cart, or the total number of active users, the total number of sales, or any other business-oriented metric. This item refers to whether the Development team has the autonomy to take action whenever the business monitoring tools are showing any problems.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>5</td><td>There is flexibility to create new business indicators and dashboards whenever it is necessary.</td><td>Business Monitoring is the proactive and process-oriented monitoring of the user flows in the application. It consists of mapping all the critical indicators for the business and making them visible in real-time so it will increase the concern and awareness of the Development team towards the business targets. For example: In an eCommerce application, we may want to monitor the conversion rate for products included in the shopping cart, or the total number of active users, the total number of sales, or any other business-oriented metric. This item refers to whether those business metrics are visible in a dashboard and the development team has the autonomy to include new business indicators in this dashboard.</td><td></td></tr><tr><td>Architecture Validation</td><td>Architecture Evaluation</td><td>RELEASE</td><td>5</td><td>The PO and stakeholders recognize that the code quality is satisfactory through the metrics and goals that are shared with them.</td><td>This item refers to whether the code quality metrics (for example the ones generated by SonarQube) are periodically shared with the PO and stakeholders so they are able to understand it, interpret it, and recognize that the quality of the code is satisfactory.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>5</td><td>The same package, that was tested in Dev and Stage environments is promoted to production, (Build once, deploy anywhere) (Except for Mobile, SPA applications)</td><td>One of the fundamental principles of Continuous Delivery is to Build Binaries Only Once. Subsequent deployments, testing, and releases should never attempt to build the binary artifacts again. This also applies to interpreted languages when some sort of zip file representing the snapshot of the application is generated instead.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Deployment</td><td>DEVELOPMENT (Sprint 1-N)</td><td>5</td><td>The lead time (from development to deployment on production) is no longer than one sprint.</td><td>Lead time is a &quot;user point of view&quot; measurement, or how long it takes, from the perspective of the user, for a feature to go from &quot;requested&quot; to &quot;complete.&quot; Having more frequent releases will help to prevent incidents in production. The smaller the release is, the easier is to identify possible issues and the lower is the impact in case of a rollback is needed. For this item in maturity level 5, the lead time should be no longer than one sprint.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Integration</td><td>DEVELOPMENT (Sprint 1-N)</td><td>5</td><td>Once an environment is created, it will be never changed. The only way to apply changes is by re-creating the whole environment with scripts and using a pipeline.</td><td>This item refers to whether the environment creation is fully automated through scripts and whether changes on those environments can only be performed by re-creating them using build pipelines.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>5</td><td>When an issue has been raised from infrastructure monitoring systems, some actions are automatically triggered that will not require manual intervention to fix it (for feasible services).</td><td>This item refers to whether an infrastructure issue raised from the monitored system can be fixed through automation. For example, if the CPU usage is high that will trigger provisioning of additional resources, or if the disk usage is high it will automatically increase the disk size, or if one server from the cluster is down, it will automatically restart it, etc.</td><td></td></tr><tr><td>Architecture Execution</td><td>Continuous Monitoring</td><td>RELEASE</td><td>5</td><td>When an issue has been raised from application monitoring systems, some actions are automatically triggered that will not require manual intervention to fix it.</td><td>This item refers to whether an application issue raised from the monitored system can be fixed through automation. For example, if the API is not responding then it will trigger the creation of a new server in the cluster, or if a critical business flow is not working accordingly the system will try to recover based on pre-defined scripts.</td><td></td></tr><tr><td>Architecture Management</td><td>Technical Backlog management</td><td>DEVELOPMENT (Sprint 1-N)</td><td>5</td><td>The team&#x27;s maturity in Architecture Process is known by the entire company, project sponsors and stakeholders; There is a plan to manage, spread and scale knowledge beyond the project boundaries.</td><td>Whenever a team can succeed in applying the Architecture Process and the maturity score becomes close to 5, it is recommended to share this case in the company and expand the knowledge and lessons learned from the project to other projects within the organization. This item refers to whether there is a plan to share it through internal webinars or culture-sharing meetings with other teams.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>5</td><td>The developers are responsible for delivering the security test scripts as part of the story scope.</td><td>Security Testing is a type of Software Testing that uncovers vulnerabilities, threats, risks in a software application and prevents malicious attacks from intruders. Scripts for security tests are a way to improve and tailor the execution of a security test to your specific needs or critical flows in your system. Ideally, those scripts should be created as part of the User Story. So a sub-task under the same User Story should be created and the time to create the script should be estimated.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>5</td><td>The PO and stakeholders recognize that the security of the application is satisfactory through the metrics and goals that are shared with them.</td><td>One of the ways to build trust with the stakeholders is to share the data about the application in a very transparent way. Whenever we execute a security test (penetration test), a report should be produced with an executive summary. The number can then be shared with the stakeholders so they can be aware of it. The security test should be automated as much as possible. One alternative way to share this kind of data if we have it automated is making it always available in a situation dashboard and make sure that the data is always up to date (nice to have).</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>DEVELOPMENT (Sprint 1-N)</td><td>5</td><td>The developers are responsible for delivering the performance test scripts as part of the story scope.</td><td>Performance Test Script is a programming code specific to performance testing to automate real-world user behavior. This code contains the user actions performed by a real user on an application. Such scripts are developed with the help of performance testing tools like LoadRunner, JMeter, and NeoLoad, etc. Ideally, those scripts should be created as part of the User Story. So a sub-task under the same User Story should be created and the time to create the script should be estimated.</td><td></td></tr><tr><td>Architecture Validation</td><td>Non-functional Requirements Validation</td><td>RELEASE</td><td>5</td><td>The PO and stakeholders recognize that the performance of the application is satisfactory through the metrics and goals that are shared with them.</td><td>One of the ways to build trust with the stakeholders is to share the data about the application in a very transparent way. Whenever we execute a performance test (load test), a report should be produced with an executive summary. The number can then be shared with the stakeholders so they can be aware of it. The performance test should be automated as much as possible. One alternative way to share this kind of data if we have it automated is making it always available in a situation dashboard and make sure that the data is always up to date (nice to have).</td><td></td></tr></tbody></table>
<p><em>Note: This table shows a comprehensive set of practices across maturity levels 1-5. The complete assessment contains over 130 practices covering all aspects of architecture definition, execution, management, and validation. Higher maturity levels focus on advanced automation, self-healing systems, stakeholder transparency, and organizational knowledge sharing.</em></p>
<h2 class="anchor anchorWithStickyNavbar_vU8F" id="practice-categories">Practice Categories<a href="#practice-categories" class="hash-link" aria-label="Direct link to Practice Categories" title="Direct link to Practice Categories" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="️-architecture-definition">🏗️ Architecture Definition<a href="#️-architecture-definition" class="hash-link" aria-label="Direct link to 🏗️ Architecture Definition" title="Direct link to 🏗️ Architecture Definition" translate="no">​</a></h3>
<p>Foundation practices for establishing architectural standards and guidelines.</p>
<h4 class="anchor anchorWithStickyNavbar_vU8F" id="architecture--coding-guidance">Architecture &amp; Coding Guidance<a href="#architecture--coding-guidance" class="hash-link" aria-label="Direct link to Architecture &amp; Coding Guidance" title="Direct link to Architecture &amp; Coding Guidance" translate="no">​</a></h4>
<ul>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-definition/scm-policy">SCM Policy</a></strong> - Source Control Management policies and procedures</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-definition/dev-environment-setup">Development Environment Setup</a></strong> - Local development environment configuration</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-definition/coding-standards">Coding Standards &amp; Conventions</a></strong> - Code quality standards and testing practices</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-definition/dev-use-cases-guide">Development Use Cases Guide</a></strong> - Special development scenarios and tools</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-definition/code-quality-tools">Code Quality Tools</a></strong> - Linting, formatting, and quality analysis</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-definition/architecture-foundation">Architecture Foundation</a></strong> - Application layers and core mechanisms</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-definition/input-validation">Input Validation</a></strong> - Data validation and security practices</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-definition/third-party-integration">Third-Party Integration</a></strong> - External APIs and library management</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-definition/backup-recovery">Backup &amp; Recovery Strategy</a></strong> - Data protection and disaster recovery</li>
</ul>
<p><em>Additional practices to be documented:</em></p>
<ul>
<li>Knowledge Transfer Planning - Stakeholder and partner communication</li>
<li>Communication Channels - Team communication setup</li>
<li>Technical Documentation - Documentation standards and processes</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_vU8F" id="communication--alignment">Communication &amp; Alignment<a href="#communication--alignment" class="hash-link" aria-label="Direct link to Communication &amp; Alignment" title="Direct link to Communication &amp; Alignment" translate="no">​</a></h4>
<p><em>Practices to be documented:</em></p>
<ul>
<li>Knowledge Transfer Planning - Stakeholder and partner communication</li>
<li>Communication Channels - Team communication setup</li>
<li>Technical Documentation - Documentation standards and processes</li>
<li>Stakeholder Communication - Architecture change management</li>
<li>Architecture Sharing - Diagram creation and presentation</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_vU8F" id="non-functional-requirements">Non-functional Requirements<a href="#non-functional-requirements" class="hash-link" aria-label="Direct link to Non-functional Requirements" title="Direct link to Non-functional Requirements" translate="no">​</a></h4>
<p><em>Practices to be documented:</em></p>
<ul>
<li>NFR Collection &amp; Mapping - Requirements gathering and documentation</li>
<li>NFR Templates &amp; Standards - Standardized requirement formats</li>
<li>NFR Approval Process - Stakeholder approval workflows</li>
<li>NFR Metrics &amp; Targets - Measurable performance targets</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_vU8F" id="technical-refinement--design">Technical Refinement &amp; Design<a href="#technical-refinement--design" class="hash-link" aria-label="Direct link to Technical Refinement &amp; Design" title="Direct link to Technical Refinement &amp; Design" translate="no">​</a></h4>
<p><em>Practices to be documented:</em></p>
<ul>
<li>Story Splitting - Breaking down features into deployable units</li>
<li>Technology Selection - Choosing stable, supported technologies</li>
<li>Documentation Maintenance - Keeping technical docs current</li>
<li>Refinement Process - Technical preparation workflows</li>
<li>Structured Refinement - High-quality technical guidance</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="architecture-execution-1213-practices-completed">Architecture Execution (12/13 practices completed)<a href="#architecture-execution-1213-practices-completed" class="hash-link" aria-label="Direct link to Architecture Execution (12/13 practices completed)" title="Direct link to Architecture Execution (12/13 practices completed)" translate="no">​</a></h3>
<p>Implementation and operational practices for continuous delivery and system reliability:</p>
<ul>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline">CI/CD Pipeline</a> - Automated build, test, and deployment pipelines</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/deployment-automation">Deployment Automation</a> - Automated deployment strategies and rollback procedures</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/infrastructure-monitoring">Infrastructure Monitoring</a> - System health monitoring and alerting</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/application-monitoring">Application Monitoring</a> - Application performance and business metrics tracking</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/configuration-management">Configuration Management</a> - Environment-specific configuration management</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/automated-deployment">Automated Deployment</a> - Blue-green, canary, and rolling deployment strategies</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/database-migrations">Database Migrations</a> - Schema versioning and migration automation</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/performance-testing">Performance Testing</a> - Load testing and performance validation frameworks</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/environment-promotion">Environment Promotion</a> - Automated environment promotion and validation</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/rollback-procedures">Rollback Procedures</a> - Emergency rollback and recovery procedures</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/security-scanning">Security Scanning</a> - Automated vulnerability scanning and security testing</li>
<li>✅ <a href="/fullstack-dev/docs/architecture-practices/architecture-execution/resource-scaling">Resource Scaling</a> - Auto-scaling and resource optimization</li>
<li>🔄 Incident Response - Incident management and post-mortem procedures</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_vU8F" id="continuous-deployment">Continuous Deployment<a href="#continuous-deployment" class="hash-link" aria-label="Direct link to Continuous Deployment" title="Direct link to Continuous Deployment" translate="no">​</a></h4>
<p><em>Additional practices to be documented:</em></p>
<ul>
<li>Artifact Versioning - Version tracking across environments</li>
<li>Rollback Strategies - Recovery and rollback procedures</li>
<li>Single-Click Deployment - Simplified production deployment</li>
<li>Smoke Testing - Deployment verification</li>
<li>Build Once Deploy Anywhere - Immutable artifacts</li>
<li>Lead Time Optimization - Fast delivery practices</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_vU8F" id="continuous-integration">Continuous Integration<a href="#continuous-integration" class="hash-link" aria-label="Direct link to Continuous Integration" title="Direct link to Continuous Integration" translate="no">​</a></h4>
<p><em>Practices to be documented:</em></p>
<ul>
<li>Source Control Best Practices - Git workflows and policies</li>
<li>Commit Standards - Commit message and PR guidelines</li>
<li>Environment Management - Multi-environment setup</li>
<li>Build Automation - Automated build processes</li>
<li>Branch Management - Branching strategies and merging</li>
<li>Database Versioning - Schema version control</li>
<li>Build Notifications - Team communication and alerts</li>
<li>GitOps Implementation - Infrastructure as code</li>
<li>Centralized Logging - Log aggregation and analysis</li>
<li>Configuration Scripts - Automated server configuration</li>
<li>Environment Provisioning - Automated environment creation</li>
<li>Auto-scaling Setup - Automatic resource scaling</li>
<li>Immutable Infrastructure - Infrastructure lifecycle management</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_vU8F" id="continuous-monitoring">Continuous Monitoring<a href="#continuous-monitoring" class="hash-link" aria-label="Direct link to Continuous Monitoring" title="Direct link to Continuous Monitoring" translate="no">​</a></h4>
<p><em>Practices to be documented:</em></p>
<ul>
<li>Enhanced Monitoring - Advanced metrics and alerting</li>
<li>Team Monitoring Access - Shared monitoring visibility</li>
<li>DevOps Problem Resolution - Team-based issue handling</li>
<li>Business Monitoring - Business metrics tracking</li>
<li>Automated Issue Resolution - Self-healing systems</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="-architecture-management">📊 Architecture Management<a href="#-architecture-management" class="hash-link" aria-label="Direct link to 📊 Architecture Management" title="Direct link to 📊 Architecture Management" translate="no">​</a></h3>
<p>Management practices for skills development, planning, and continuous improvement.</p>
<h4 class="anchor anchorWithStickyNavbar_vU8F" id="people--technical-skills-development">People &amp; Technical Skills Development<a href="#people--technical-skills-development" class="hash-link" aria-label="Direct link to People &amp; Technical Skills Development" title="Direct link to People &amp; Technical Skills Development" translate="no">​</a></h4>
<ul>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-management/skills-assessment">Skills Assessment</a></strong> - Team capability mapping and development</li>
</ul>
<p><em>Additional practices to be documented:</em></p>
<ul>
<li>Architecture Roadmap - Technical milestone planning</li>
<li>PDCA Meetings - Regular architecture review sessions</li>
<li>Solution Review Process - Peer architecture reviews</li>
<li>Action Plan Tracking - Systematic improvement tracking</li>
<li>Architecture Backlog - Technical debt and improvement management</li>
<li>Technical Debt Management - Debt monitoring and reduction</li>
<li>Knowledge Sharing - Organization-wide practice scaling</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="-architecture-validation">✅ Architecture Validation<a href="#-architecture-validation" class="hash-link" aria-label="Direct link to ✅ Architecture Validation" title="Direct link to ✅ Architecture Validation" translate="no">​</a></h3>
<p>Validation practices for ensuring quality, performance, and compliance.</p>
<h4 class="anchor anchorWithStickyNavbar_vU8F" id="architecture-evaluation--testing">Architecture Evaluation &amp; Testing<a href="#architecture-evaluation--testing" class="hash-link" aria-label="Direct link to Architecture Evaluation &amp; Testing" title="Direct link to Architecture Evaluation &amp; Testing" translate="no">​</a></h4>
<ul>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-validation/code-review-process">Code Review Process</a></strong> - Quality-focused manual code reviews</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-validation/architecture-evaluation">Architecture Evaluation</a></strong> - Automated quality monitoring, architectural compliance, and review frameworks</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-validation/continuous-testing">Continuous Testing</a></strong> - Comprehensive testing strategies including unit, integration, E2E, and cross-platform testing</li>
<li><strong><a href="/fullstack-dev/docs/architecture-practices/architecture-validation/non-functional-requirements-validation">Non-functional Requirements Validation</a></strong> - Performance, security, scalability, and compliance testing frameworks</li>
</ul>
<p><strong>Section Status</strong>: ✅ <strong>Complete</strong> (4/4 practices documented with comprehensive NestJS and Next.js implementations)</p>
<h2 class="anchor anchorWithStickyNavbar_vU8F" id="implementation-approach">Implementation Approach<a href="#implementation-approach" class="hash-link" aria-label="Direct link to Implementation Approach" title="Direct link to Implementation Approach" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="-getting-started">🎯 Getting Started<a href="#-getting-started" class="hash-link" aria-label="Direct link to 🎯 Getting Started" title="Direct link to 🎯 Getting Started" translate="no">​</a></h3>
<ol>
<li><strong>Assessment</strong>: Use the <a href="/fullstack-dev/docs/architecture-practices/architecture-maturity-assessment">Architecture Maturity Assessment</a> to identify your current maturity level</li>
<li><strong>Planning</strong>: Select practices appropriate for your target maturity level</li>
<li><strong>Implementation</strong>: Follow the detailed guides for each selected practice</li>
<li><strong>Validation</strong>: Verify implementation using the provided checklists and metrics</li>
<li><strong>Iteration</strong>: Continuously improve based on feedback and results</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="-maturity-progression">📈 Maturity Progression<a href="#-maturity-progression" class="hash-link" aria-label="Direct link to 📈 Maturity Progression" title="Direct link to 📈 Maturity Progression" translate="no">​</a></h3>
<p><strong>Level 1 (Foundation)</strong>: Start with basic documentation, environment setup, and fundamental processes
<strong>Level 2 (Managed)</strong>: Add automation, standardization, and enhanced monitoring
<strong>Level 3 (Defined)</strong>: Implement quality gates, comprehensive testing, and metrics-driven improvements
<strong>Level 4 (Quantitatively Managed)</strong>: Focus on automation, self-service capabilities, and advanced monitoring
<strong>Level 5 (Optimizing)</strong>: Achieve self-healing systems, organization-wide scaling, and continuous innovation</p>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="-cross-references">🔗 Cross-References<a href="#-cross-references" class="hash-link" aria-label="Direct link to 🔗 Cross-References" title="Direct link to 🔗 Cross-References" translate="no">​</a></h3>
<p>Each practice guide includes:</p>
<ul>
<li><strong>Prerequisites</strong>: Required foundation practices</li>
<li><strong>Dependencies</strong>: Related practices that should be implemented together</li>
<li><strong>Next Steps</strong>: Logical progression to higher maturity levels</li>
<li><strong>Related Documentation</strong>: Links to complementary guides</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_vU8F" id="technology-specific-considerations">Technology-Specific Considerations<a href="#technology-specific-considerations" class="hash-link" aria-label="Direct link to Technology-Specific Considerations" title="Direct link to Technology-Specific Considerations" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="nestjs-microservices">NestJS Microservices<a href="#nestjs-microservices" class="hash-link" aria-label="Direct link to NestJS Microservices" title="Direct link to NestJS Microservices" translate="no">​</a></h3>
<ul>
<li><strong>Service mesh integration</strong> for inter-service communication</li>
<li><strong>Distributed tracing</strong> for request flow monitoring</li>
<li><strong>API versioning strategies</strong> for backward compatibility</li>
<li><strong>Event-driven architecture</strong> with message queues</li>
<li><strong>Database per service</strong> pattern implementation</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="nextjs-microfrontends">Next.js Microfrontends<a href="#nextjs-microfrontends" class="hash-link" aria-label="Direct link to Next.js Microfrontends" title="Direct link to Next.js Microfrontends" translate="no">​</a></h3>
<ul>
<li><strong>Module Federation</strong> for runtime integration</li>
<li><strong>Shared component libraries</strong> for consistency</li>
<li><strong>Independent deployment</strong> strategies</li>
<li><strong>State management</strong> across microfrontends</li>
<li><strong>Performance optimization</strong> for large applications</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_vU8F" id="support-and-contribution">Support and Contribution<a href="#support-and-contribution" class="hash-link" aria-label="Direct link to Support and Contribution" title="Direct link to Support and Contribution" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="getting-help">Getting Help<a href="#getting-help" class="hash-link" aria-label="Direct link to Getting Help" title="Direct link to Getting Help" translate="no">​</a></h3>
<ul>
<li><strong>Documentation Issues</strong>: Report gaps or improvements needed</li>
<li><strong>Implementation Questions</strong>: Seek guidance on specific practices</li>
<li><strong>Best Practice Updates</strong>: Suggest improvements based on experience</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_vU8F" id="contributing">Contributing<a href="#contributing" class="hash-link" aria-label="Direct link to Contributing" title="Direct link to Contributing" translate="no">​</a></h3>
<ul>
<li><strong>Practice Updates</strong>: Share improvements and lessons learned</li>
<li><strong>New Practices</strong>: Propose additional architecture practices</li>
<li><strong>Technology Updates</strong>: Update guides for new technology versions</li>
<li><strong>Real-world Examples</strong>: Contribute working examples and case studies</li>
</ul>
<hr>
<p><em>This documentation is continuously updated to reflect evolving best practices and technology capabilities.</em></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/index.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_oUsg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_nFFz"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/fullstack-dev/docs/qa-practices/qa-assessment/qa-maturity-assessment-action-plan"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Quality Assurance Maturity Assessment - Action Plan</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/fullstack-dev/docs/architecture-practices/architecture-definition/scm-policy"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">SCM Policy for NestJS &amp; Next.js Microservices</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_dfCb thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#architecture-maturity-assessment" class="table-of-contents__link toc-highlight">Architecture Maturity Assessment</a></li><li><a href="#practice-categories" class="table-of-contents__link toc-highlight">Practice Categories</a><ul><li><a href="#️-architecture-definition" class="table-of-contents__link toc-highlight">🏗️ Architecture Definition</a></li><li><a href="#architecture-execution-1213-practices-completed" class="table-of-contents__link toc-highlight">Architecture Execution (12/13 practices completed)</a></li><li><a href="#-architecture-management" class="table-of-contents__link toc-highlight">📊 Architecture Management</a></li><li><a href="#-architecture-validation" class="table-of-contents__link toc-highlight">✅ Architecture Validation</a></li></ul></li><li><a href="#implementation-approach" class="table-of-contents__link toc-highlight">Implementation Approach</a><ul><li><a href="#-getting-started" class="table-of-contents__link toc-highlight">🎯 Getting Started</a></li><li><a href="#-maturity-progression" class="table-of-contents__link toc-highlight">📈 Maturity Progression</a></li><li><a href="#-cross-references" class="table-of-contents__link toc-highlight">🔗 Cross-References</a></li></ul></li><li><a href="#technology-specific-considerations" class="table-of-contents__link toc-highlight">Technology-Specific Considerations</a><ul><li><a href="#nestjs-microservices" class="table-of-contents__link toc-highlight">NestJS Microservices</a></li><li><a href="#nextjs-microfrontends" class="table-of-contents__link toc-highlight">Next.js Microfrontends</a></li></ul></li><li><a href="#support-and-contribution" class="table-of-contents__link toc-highlight">Support and Contribution</a><ul><li><a href="#getting-help" class="table-of-contents__link toc-highlight">Getting Help</a></li><li><a href="#contributing" class="table-of-contents__link toc-highlight">Contributing</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Documentation</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/fullstack-dev/docs/intro">Getting Started</a></li><li class="footer__item"><a class="footer__link-item" href="/fullstack-dev/docs/architecture-practices">Architecture Practices</a></li><li class="footer__item"><a class="footer__link-item" href="/fullstack-dev/docs/features">Features</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Development</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/fullstack-dev/docs/setup">Setup &amp; Installation</a></li><li class="footer__item"><a class="footer__link-item" href="/fullstack-dev/docs/testing">Testing</a></li><li class="footer__item"><a class="footer__link-item" href="/fullstack-dev/docs/deployment">Deployment</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/fullstack-dev/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/tamnk74/fullstack-dev" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_PqB4"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://github.com/tamnk74/fullstack-dev" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub (Fullstack Dev)<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_PqB4"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Next.js for Production. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>