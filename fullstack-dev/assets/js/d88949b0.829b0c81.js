"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[5237],{1290:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"backend/idempotency-key-guide","title":"Handling Idempotency Keys in a REST API","description":"Handling an idempotency key in a REST API involves the client generating a unique key for each operation and sending it in an HTTP header. The server then uses this key to recognize and de-duplicate subsequent retries of the same request, ensuring that a sensitive operation is executed only once.","source":"@site/docs/backend/idempotency-key-guide.md","sourceDirName":"backend","slug":"/backend/idempotency-key-guide","permalink":"/fullstack-dev/docs/backend/idempotency-key-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/backend/idempotency-key-guide.md","tags":[],"version":"current","frontMatter":{}}');var i=s(5813),r=s(5741);const o={},a="Handling Idempotency Keys in a REST API",d={},c=[{value:"## What is Idempotency? \ud83e\udd14",id:"-what-is-idempotency-",level:3},{value:"## How to Implement an Idempotency Key",id:"-how-to-implement-an-idempotency-key",level:3},{value:"<strong>Client-Side Responsibilities</strong>",id:"client-side-responsibilities",level:4},{value:"<strong>Server-Side Responsibilities</strong>",id:"server-side-responsibilities",level:4},{value:"## Example Workflow: A Bank Transfer \ud83d\udcb0",id:"-example-workflow-a-bank-transfer-",level:3}];function l(e){const n={code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"handling-idempotency-keys-in-a-rest-api",children:"Handling Idempotency Keys in a REST API"})}),"\n",(0,i.jsx)(n.p,{children:"Handling an idempotency key in a REST API involves the client generating a unique key for each operation and sending it in an HTTP header. The server then uses this key to recognize and de-duplicate subsequent retries of the same request, ensuring that a sensitive operation is executed only once."}),"\n",(0,i.jsx)(n.p,{children:"This prevents common issues like accidental double payments or duplicate resource creation caused by network failures."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-what-is-idempotency-",children:"## What is Idempotency? \ud83e\udd14"}),"\n",(0,i.jsxs)(n.p,{children:["In the context of APIs, ",(0,i.jsx)(n.strong,{children:"idempotency"})," means that making the same API call multiple times will produce the same result as making it just once. While methods like ",(0,i.jsx)(n.code,{children:"GET"}),", ",(0,i.jsx)(n.code,{children:"PUT"}),", and ",(0,i.jsx)(n.code,{children:"DELETE"})," are naturally idempotent, ",(0,i.jsx)(n.code,{children:"POST"})," is not. An idempotency key is a technique to make ",(0,i.jsx)(n.code,{children:"POST"})," requests safe to retry."]}),"\n",(0,i.jsx)(n.p,{children:'Think of it like an elevator button. Pushing it once calls the elevator. Pushing it ten more times while you wait doesn\'t call ten more elevators; the result is the same. An idempotency key brings this same "push-once" behavior to sensitive API calls.'}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-how-to-implement-an-idempotency-key",children:"## How to Implement an Idempotency Key"}),"\n",(0,i.jsxs)(n.p,{children:["The implementation involves a handshake between the client and the server. The most common header used is ",(0,i.jsx)(n.code,{children:"Idempotency-Key"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"client-side-responsibilities",children:(0,i.jsx)(n.strong,{children:"Client-Side Responsibilities"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Generate a Unique Key:"})," Before sending a request for a new operation, the client must generate a unique key. A ",(0,i.jsx)(n.strong,{children:"UUID (Universally Unique Identifier)"})," is the best choice for this."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Send the Key in a Header:"})," The client includes this key in the request header."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Retry with the Same Key:"})," If the client does not receive a response (e.g., due to a network timeout) and needs to retry, it ",(0,i.jsx)(n.strong,{children:"must"})," send the exact same request with the exact same ",(0,i.jsx)(n.code,{children:"Idempotency-Key"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"server-side-responsibilities",children:(0,i.jsx)(n.strong,{children:"Server-Side Responsibilities"})}),"\n",(0,i.jsx)(n.p,{children:"The server's logic is the core of the implementation."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Check for the Key:"})," When a request with an ",(0,i.jsx)(n.code,{children:"Idempotency-Key"})," arrives, the server checks its storage (e.g., a cache like Redis or a database table) to see if it has ever processed this key before."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Handle Scenarios:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Case 1: Key is New."})," If the key has not been seen before, the server processes the request as usual. ",(0,i.jsx)(n.strong,{children:"Crucially, before sending the response, it saves the idempotency key and the resulting HTTP status code and body to its storage."})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Case 2: Key is Found."})," If the key exists in storage, the server ",(0,i.jsx)(n.strong,{children:"does not"})," re-process the request. Instead, it immediately returns the saved response (the same status code and body) from the original request."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Case 3: Race Condition."})," If a request arrives with a key that is currently being processed by another request, the server should return an error, such as ",(0,i.jsx)(n.code,{children:"409 Conflict"}),", to indicate that the client should wait and try again."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"-example-workflow-a-bank-transfer-",children:"## Example Workflow: A Bank Transfer \ud83d\udcb0"}),"\n",(0,i.jsxs)(n.p,{children:["Imagine a client wants to make a ",(0,i.jsx)(n.code,{children:"$100"})," transfer."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. First Attempt (Successful)"})}),"\n",(0,i.jsx)(n.p,{children:"The client generates a unique key and sends the request."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:'POST /transfers HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nIdempotency-Key: a9a2f3a4-b1c4-4c8e-a9d2-3b2a8d3b7c4e\n\n{\n  "amount": 100,\n  "currency": "USD",\n  "destination_account": "123456789"\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},5741:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(9729);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);