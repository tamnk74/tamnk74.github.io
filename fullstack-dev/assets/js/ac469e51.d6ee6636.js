"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[753],{170:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"architecture-practices/architecture-execution/deployment-automation","title":"Deployment Automation Guide","description":"This guide provides comprehensive deployment automation strategies for NestJS microservices and Next.js microfrontend applications, covering infrastructure as code, automated deployments, and production readiness.","source":"@site/docs/architecture-practices/architecture-execution/deployment-automation.md","sourceDirName":"architecture-practices/architecture-execution","slug":"/architecture-practices/architecture-execution/deployment-automation","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/deployment-automation","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-execution/deployment-automation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"CI/CD Pipeline for NestJS & Next.js Microservices","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline"},"next":{"title":"Infrastructure Monitoring Guide","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/infrastructure-monitoring"}}');var i=t(5813),s=t(7814);const o={},a="Deployment Automation Guide",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Deployment Architecture",id:"deployment-architecture",level:2},{value:"Multi-Environment Deployment Pipeline",id:"multi-environment-deployment-pipeline",level:3},{value:"Container Strategy",id:"container-strategy",level:2},{value:"Docker Configuration",id:"docker-configuration",level:3},{value:"NestJS Microservice Dockerfile",id:"nestjs-microservice-dockerfile",level:4},{value:"Next.js Microfrontend Dockerfile",id:"nextjs-microfrontend-dockerfile",level:4},{value:"Multi-Stage Build Optimization",id:"multi-stage-build-optimization",level:3},{value:"Kubernetes Deployment",id:"kubernetes-deployment",level:2},{value:"NestJS Deployment Configuration",id:"nestjs-deployment-configuration",level:3},{value:"Next.js Deployment Configuration",id:"nextjs-deployment-configuration",level:3},{value:"Infrastructure as Code",id:"infrastructure-as-code",level:2},{value:"Terraform Configuration",id:"terraform-configuration",level:3},{value:"Helm Charts",id:"helm-charts",level:3},{value:"GitOps Deployment",id:"gitops-deployment",level:2},{value:"ArgoCD Application Configuration",id:"argocd-application-configuration",level:3},{value:"Kustomize Configuration",id:"kustomize-configuration",level:3},{value:"Deployment Automation Scripts",id:"deployment-automation-scripts",level:2},{value:"Deployment Orchestration",id:"deployment-orchestration",level:3},{value:"Blue-Green Deployment",id:"blue-green-deployment",level:2},{value:"Blue-Green Strategy Implementation",id:"blue-green-strategy-implementation",level:3},{value:"Monitoring and Observability",id:"monitoring-and-observability",level:2},{value:"Deployment Metrics",id:"deployment-metrics",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Deployment Guidelines",id:"deployment-guidelines",level:3},{value:"Environment Management",id:"environment-management",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"deployment-automation-guide",children:"Deployment Automation Guide"})}),"\n",(0,i.jsx)(n.p,{children:"This guide provides comprehensive deployment automation strategies for NestJS microservices and Next.js microfrontend applications, covering infrastructure as code, automated deployments, and production readiness."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Deployment automation ensures consistent, reliable, and repeatable deployments across all environments. This guide covers Docker containerization, Kubernetes orchestration, Infrastructure as Code (IaC), and automated deployment pipelines for enterprise-grade applications."}),"\n",(0,i.jsx)(n.h2,{id:"deployment-architecture",children:"Deployment Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"multi-environment-deployment-pipeline",children:"Multi-Environment Deployment Pipeline"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Source Code] --\x3e B[CI Pipeline]\n    B --\x3e C[Build & Test]\n    C --\x3e D[Container Build]\n    D --\x3e E[Security Scan]\n    E --\x3e F[Development Deploy]\n    F --\x3e G[Integration Tests]\n    G --\x3e H[Staging Deploy]\n    H --\x3e I[Performance Tests]\n    I --\x3e J[Production Deploy]\n    \n    K[Infrastructure as Code] --\x3e L[Environment Provisioning]\n    L --\x3e M[Configuration Management]\n    M --\x3e N[Service Deployment]\n    \n    O[Monitoring] --\x3e F\n    O --\x3e H\n    O --\x3e J\n"})}),"\n",(0,i.jsx)(n.h2,{id:"container-strategy",children:"Container Strategy"}),"\n",(0,i.jsx)(n.h3,{id:"docker-configuration",children:"Docker Configuration"}),"\n",(0,i.jsx)(n.h4,{id:"nestjs-microservice-dockerfile",children:"NestJS Microservice Dockerfile"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dockerfile",children:'# Dockerfile for NestJS microservice\nFROM node:18-alpine AS base\n\n# Set working directory\nWORKDIR /app\n\n# Install dependencies for building native modules\nRUN apk add --no-cache libc6-compat python3 make g++\n\n# Copy package files\nCOPY package*.json ./\nCOPY tsconfig*.json ./\n\n# Install dependencies\nFROM base AS dependencies\nRUN npm ci --only=production && npm cache clean --force\n\n# Build stage\nFROM base AS builder\nCOPY . .\nRUN npm ci\nRUN npm run build\nRUN npm prune --production\n\n# Production stage\nFROM node:18-alpine AS production\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs\nRUN adduser -S nestjs -u 1001\n\n# Set working directory\nWORKDIR /app\n\n# Copy built application\nCOPY --from=builder --chown=nestjs:nodejs /app/dist ./dist\nCOPY --from=builder --chown=nestjs:nodejs /app/node_modules ./node_modules\nCOPY --from=builder --chown=nestjs:nodejs /app/package.json ./package.json\n\n# Health check script\nCOPY --chown=nestjs:nodejs scripts/health-check.sh ./health-check.sh\nRUN chmod +x ./health-check.sh\n\n# Switch to non-root user\nUSER nestjs\n\n# Expose port\nEXPOSE 3000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD ./health-check.sh\n\n# Start application\nCMD ["node", "dist/main.js"]\n'})}),"\n",(0,i.jsx)(n.h4,{id:"nextjs-microfrontend-dockerfile",children:"Next.js Microfrontend Dockerfile"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dockerfile",children:'# Dockerfile for Next.js microfrontend\nFROM node:18-alpine AS base\n\n# Set working directory\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\nCOPY next.config.js ./\nCOPY tailwind.config.js ./\nCOPY tsconfig.json ./\n\n# Dependencies stage\nFROM base AS dependencies\nRUN npm ci --only=production && npm cache clean --force\n\n# Build stage\nFROM base AS builder\nCOPY . .\nRUN npm ci\nRUN npm run build\n\n# Production stage\nFROM node:18-alpine AS production\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs\nRUN adduser -S nextjs -u 1001\n\nWORKDIR /app\n\n# Copy built application\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static\nCOPY --from=builder --chown=nextjs:nodejs /app/public ./public\n\n# Switch to non-root user\nUSER nextjs\n\n# Expose port\nEXPOSE 3000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:3000/api/health || exit 1\n\n# Start application\nCMD ["node", "server.js"]\n'})}),"\n",(0,i.jsx)(n.h3,{id:"multi-stage-build-optimization",children:"Multi-Stage Build Optimization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dockerfile",children:'# Optimized multi-stage build with shared base\nFROM node:18-alpine AS base\nWORKDIR /app\nRUN apk add --no-cache libc6-compat curl\n\n# Dependencies cache layer\nFROM base AS deps\nCOPY package*.json ./\nRUN npm ci --only=production && npm cache clean --force\n\n# Build dependencies layer  \nFROM base AS build-deps\nCOPY package*.json ./\nRUN npm ci\n\n# Build layer\nFROM build-deps AS builder\nCOPY . .\nRUN npm run build\nRUN npm run test:unit\n\n# Production layer\nFROM base AS runner\nENV NODE_ENV=production\nRUN addgroup --system --gid 1001 nodejs\nRUN adduser --system --uid 1001 app\n\nCOPY --from=deps --chown=app:nodejs /app/node_modules ./node_modules\nCOPY --from=builder --chown=app:nodejs /app/dist ./dist\nCOPY --from=builder --chown=app:nodejs /app/package.json ./\n\nUSER app\nEXPOSE 3000\n\nCMD ["node", "dist/main.js"]\n'})}),"\n",(0,i.jsx)(n.h2,{id:"kubernetes-deployment",children:"Kubernetes Deployment"}),"\n",(0,i.jsx)(n.h3,{id:"nestjs-deployment-configuration",children:"NestJS Deployment Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# k8s/nestjs-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: user-service\n  namespace: microservices\n  labels:\n    app: user-service\n    version: v1\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  selector:\n    matchLabels:\n      app: user-service\n  template:\n    metadata:\n      labels:\n        app: user-service\n        version: v1\n      annotations:\n        prometheus.io/scrape: "true"\n        prometheus.io/port: "3000"\n        prometheus.io/path: "/metrics"\n    spec:\n      serviceAccountName: user-service\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 1001\n        fsGroup: 1001\n      containers:\n      - name: user-service\n        image: myregistry/user-service:latest\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 3000\n          name: http\n          protocol: TCP\n        env:\n        - name: NODE_ENV\n          value: "production"\n        - name: PORT\n          value: "3000"\n        - name: DB_HOST\n          valueFrom:\n            secretKeyRef:\n              name: database-secrets\n              key: host\n        - name: DB_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: database-secrets\n              key: password\n        - name: REDIS_URL\n          valueFrom:\n            configMapKeyRef:\n              name: redis-config\n              key: url\n        resources:\n          requests:\n            memory: "256Mi"\n            cpu: "250m"\n          limits:\n            memory: "512Mi"\n            cpu: "500m"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: http\n          initialDelaySeconds: 30\n          periodSeconds: 30\n          timeoutSeconds: 5\n          failureThreshold: 3\n        readinessProbe:\n          httpGet:\n            path: /health/ready\n            port: http\n          initialDelaySeconds: 5\n          periodSeconds: 10\n          timeoutSeconds: 3\n          failureThreshold: 3\n        volumeMounts:\n        - name: config-volume\n          mountPath: /app/config\n          readOnly: true\n        - name: logs-volume\n          mountPath: /app/logs\n      volumes:\n      - name: config-volume\n        configMap:\n          name: user-service-config\n      - name: logs-volume\n        emptyDir: {}\n      imagePullSecrets:\n      - name: registry-secret\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: user-service\n  namespace: microservices\n  labels:\n    app: user-service\nspec:\n  type: ClusterIP\n  ports:\n  - port: 80\n    targetPort: http\n    protocol: TCP\n    name: http\n  selector:\n    app: user-service\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: user-service-ingress\n  namespace: microservices\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n    nginx.ingress.kubernetes.io/rate-limit: "100"\n    nginx.ingress.kubernetes.io/ssl-redirect: "true"\nspec:\n  tls:\n  - hosts:\n    - api.example.com\n    secretName: api-tls\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /users\n        pathType: Prefix\n        backend:\n          service:\n            name: user-service\n            port:\n              number: 80\n'})}),"\n",(0,i.jsx)(n.h3,{id:"nextjs-deployment-configuration",children:"Next.js Deployment Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# k8s/nextjs-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: frontend-app\n  namespace: microfrontends\n  labels:\n    app: frontend-app\n    version: v1\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 2\n      maxUnavailable: 1\n  selector:\n    matchLabels:\n      app: frontend-app\n  template:\n    metadata:\n      labels:\n        app: frontend-app\n        version: v1\n    spec:\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 1001\n        fsGroup: 1001\n      containers:\n      - name: frontend-app\n        image: myregistry/frontend-app:latest\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 3000\n          name: http\n        env:\n        - name: NODE_ENV\n          value: "production"\n        - name: NEXT_PUBLIC_API_URL\n          valueFrom:\n            configMapKeyRef:\n              name: frontend-config\n              key: api-url\n        - name: NEXT_PUBLIC_AUTH_DOMAIN\n          valueFrom:\n            configMapKeyRef:\n              name: frontend-config\n              key: auth-domain\n        resources:\n          requests:\n            memory: "512Mi"\n            cpu: "250m"\n          limits:\n            memory: "1Gi"\n            cpu: "500m"\n        livenessProbe:\n          httpGet:\n            path: /api/health\n            port: http\n          initialDelaySeconds: 30\n          periodSeconds: 30\n        readinessProbe:\n          httpGet:\n            path: /api/health\n            port: http\n          initialDelaySeconds: 10\n          periodSeconds: 10\n        volumeMounts:\n        - name: static-assets\n          mountPath: /app/.next/static\n          readOnly: true\n      volumes:\n      - name: static-assets\n        persistentVolumeClaim:\n          claimName: static-assets-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-app\n  namespace: microfrontends\nspec:\n  type: ClusterIP\n  ports:\n  - port: 80\n    targetPort: http\n    protocol: TCP\n  selector:\n    app: frontend-app\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: frontend-app-ingress\n  namespace: microfrontends\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n    nginx.ingress.kubernetes.io/ssl-redirect: "true"\n    nginx.ingress.kubernetes.io/use-regex: "true"\nspec:\n  tls:\n  - hosts:\n    - app.example.com\n    secretName: frontend-tls\n  rules:\n  - host: app.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-app\n            port:\n              number: 80\n'})}),"\n",(0,i.jsx)(n.h2,{id:"infrastructure-as-code",children:"Infrastructure as Code"}),"\n",(0,i.jsx)(n.h3,{id:"terraform-configuration",children:"Terraform Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hcl",children:'# terraform/main.tf\nterraform {\n  required_version = ">= 1.0"\n  required_providers {\n    aws = {\n      source  = "hashicorp/aws"\n      version = "~> 5.0"\n    }\n    kubernetes = {\n      source  = "hashicorp/kubernetes"\n      version = "~> 2.0"\n    }\n  }\n\n  backend "s3" {\n    bucket  = "mycompany-terraform-state"\n    key     = "infrastructure/production.tfstate"\n    region  = "us-west-2"\n    encrypt = true\n  }\n}\n\nprovider "aws" {\n  region = var.aws_region\n}\n\n# EKS Cluster\nmodule "eks" {\n  source = "terraform-aws-modules/eks/aws"\n  version = "~> 19.0"\n\n  cluster_name    = var.cluster_name\n  cluster_version = "1.27"\n\n  vpc_id     = module.vpc.vpc_id\n  subnet_ids = module.vpc.private_subnets\n\n  # EKS Managed Node Groups\n  eks_managed_node_groups = {\n    general = {\n      min_size     = 3\n      max_size     = 10\n      desired_size = 6\n\n      instance_types = ["t3.large"]\n      \n      k8s_labels = {\n        Environment = var.environment\n        NodeGroup   = "general"\n      }\n    }\n    \n    compute = {\n      min_size     = 0\n      max_size     = 5\n      desired_size = 2\n\n      instance_types = ["c5.xlarge"]\n      \n      k8s_labels = {\n        Environment = var.environment\n        NodeGroup   = "compute"\n      }\n      \n      taints = {\n        dedicated = {\n          key    = "compute-intensive"\n          value  = "true"\n          effect = "NO_SCHEDULE"\n        }\n      }\n    }\n  }\n\n  # aws-auth configmap\n  manage_aws_auth_configmap = true\n\n  aws_auth_roles = [\n    {\n      rolearn  = aws_iam_role.eks_admin.arn\n      username = "eks-admin"\n      groups   = ["system:masters"]\n    },\n  ]\n\n  tags = {\n    Environment = var.environment\n    Terraform   = "true"\n  }\n}\n\n# VPC\nmodule "vpc" {\n  source = "terraform-aws-modules/vpc/aws"\n  version = "~> 5.0"\n\n  name = "${var.cluster_name}-vpc"\n  cidr = "10.0.0.0/16"\n\n  azs             = ["${var.aws_region}a", "${var.aws_region}b", "${var.aws_region}c"]\n  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]\n  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]\n\n  enable_nat_gateway = true\n  enable_vpn_gateway = true\n  single_nat_gateway = false\n\n  public_subnet_tags = {\n    "kubernetes.io/cluster/${var.cluster_name}" = "shared"\n    "kubernetes.io/role/elb"                    = "1"\n  }\n\n  private_subnet_tags = {\n    "kubernetes.io/cluster/${var.cluster_name}" = "shared"\n    "kubernetes.io/role/internal-elb"           = "1"\n  }\n\n  tags = {\n    Environment = var.environment\n    Terraform   = "true"\n  }\n}\n\n# RDS Database\nmodule "db" {\n  source = "terraform-aws-modules/rds/aws"\n  version = "~> 6.0"\n\n  identifier = "${var.cluster_name}-database"\n\n  engine            = "postgres"\n  engine_version    = "15.3"\n  instance_class    = "db.t3.large"\n  allocated_storage = 100\n  max_allocated_storage = 1000\n\n  storage_encrypted = true\n\n  db_name  = var.database_name\n  username = var.database_username\n  manage_master_user_password = true\n\n  vpc_security_group_ids = [aws_security_group.rds.id]\n  db_subnet_group_name   = module.vpc.database_subnet_group\n\n  backup_retention_period = 7\n  backup_window          = "03:00-04:00"\n  maintenance_window     = "sun:04:00-sun:05:00"\n\n  enabled_cloudwatch_logs_exports = ["postgresql"]\n  monitoring_interval = 60\n  monitoring_role_arn = aws_iam_role.rds_monitoring.arn\n\n  deletion_protection = var.environment == "production"\n\n  tags = {\n    Environment = var.environment\n    Terraform   = "true"\n  }\n}\n\n# ElastiCache Redis\nresource "aws_elasticache_subnet_group" "redis" {\n  name       = "${var.cluster_name}-redis-subnet-group"\n  subnet_ids = module.vpc.private_subnets\n}\n\nresource "aws_elasticache_replication_group" "redis" {\n  replication_group_id         = "${var.cluster_name}-redis"\n  description                  = "Redis cluster for ${var.cluster_name}"\n  \n  port                         = 6379\n  parameter_group_name         = "default.redis7"\n  node_type                    = "cache.t3.micro"\n  num_cache_clusters           = 2\n  \n  engine_version               = "7.0"\n  at_rest_encryption_enabled   = true\n  transit_encryption_enabled   = true\n  \n  subnet_group_name            = aws_elasticache_subnet_group.redis.name\n  security_group_ids           = [aws_security_group.redis.id]\n  \n  automatic_failover_enabled   = true\n  multi_az_enabled            = true\n  \n  maintenance_window          = "sun:03:00-sun:04:00"\n  snapshot_retention_limit    = 5\n  snapshot_window            = "02:00-03:00"\n\n  tags = {\n    Environment = var.environment\n    Terraform   = "true"\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"helm-charts",children:"Helm Charts"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# helm/microservice/Chart.yaml\napiVersion: v2\nname: microservice\ndescription: A Helm chart for NestJS microservices\ntype: application\nversion: 0.1.0\nappVersion: "1.0.0"\n\ndependencies:\n- name: postgresql\n  version: "12.x.x"\n  repository: "https://charts.bitnami.com/bitnami"\n  condition: postgresql.enabled\n- name: redis\n  version: "17.x.x"\n  repository: "https://charts.bitnami.com/bitnami"\n  condition: redis.enabled\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# helm/microservice/values.yaml\n# Default values for microservice\nreplicaCount: 3\n\nimage:\n  repository: myregistry/microservice\n  pullPolicy: IfNotPresent\n  tag: ""\n\nimagePullSecrets:\n- name: registry-secret\n\nnameOverride: ""\nfullnameOverride: ""\n\nserviceAccount:\n  create: true\n  annotations: {}\n  name: ""\n\npodAnnotations:\n  prometheus.io/scrape: "true"\n  prometheus.io/port: "3000"\n  prometheus.io/path: "/metrics"\n\npodSecurityContext:\n  runAsNonRoot: true\n  runAsUser: 1001\n  fsGroup: 1001\n\nsecurityContext:\n  allowPrivilegeEscalation: false\n  readOnlyRootFilesystem: true\n  runAsNonRoot: true\n  runAsUser: 1001\n  capabilities:\n    drop:\n    - ALL\n\nservice:\n  type: ClusterIP\n  port: 80\n  targetPort: 3000\n\ningress:\n  enabled: false\n  className: ""\n  annotations: {}\n  hosts:\n  - host: chart-example.local\n    paths:\n    - path: /\n      pathType: ImplementationSpecific\n  tls: []\n\nresources:\n  limits:\n    cpu: 500m\n    memory: 512Mi\n  requests:\n    cpu: 250m\n    memory: 256Mi\n\nautoscaling:\n  enabled: true\n  minReplicas: 3\n  maxReplicas: 10\n  targetCPUUtilizationPercentage: 80\n  targetMemoryUtilizationPercentage: 80\n\nnodeSelector: {}\n\ntolerations: []\n\naffinity:\n  podAntiAffinity:\n    preferredDuringSchedulingIgnoredDuringExecution:\n    - weight: 100\n      podAffinityTerm:\n        labelSelector:\n          matchExpressions:\n          - key: app.kubernetes.io/name\n            operator: In\n            values:\n            - microservice\n        topologyKey: kubernetes.io/hostname\n\n# Application configuration\nconfig:\n  nodeEnv: production\n  logLevel: info\n  port: 3000\n\n# Database configuration\npostgresql:\n  enabled: false\n  auth:\n    username: app\n    database: appdb\n\n# Redis configuration  \nredis:\n  enabled: false\n  auth:\n    enabled: true\n\n# Environment variables\nenv:\n  normal: {}\n  secret: {}\n\n# ConfigMap and Secret management\nconfigMap:\n  create: true\n  data: {}\n\nsecret:\n  create: true\n  data: {}\n\n# Health checks\nhealthCheck:\n  liveness:\n    enabled: true\n    path: /health\n    initialDelaySeconds: 30\n    periodSeconds: 30\n    timeoutSeconds: 5\n    failureThreshold: 3\n  readiness:\n    enabled: true\n    path: /health/ready\n    initialDelaySeconds: 5\n    periodSeconds: 10\n    timeoutSeconds: 3\n    failureThreshold: 3\n\n# Persistence\npersistence:\n  enabled: false\n  storageClass: ""\n  accessMode: ReadWriteOnce\n  size: 1Gi\n  mountPath: /data\n\n# Network policies\nnetworkPolicy:\n  enabled: false\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress: []\n  egress: []\n'})}),"\n",(0,i.jsx)(n.h2,{id:"gitops-deployment",children:"GitOps Deployment"}),"\n",(0,i.jsx)(n.h3,{id:"argocd-application-configuration",children:"ArgoCD Application Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# argocd/applications/user-service.yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: user-service\n  namespace: argocd\n  finalizers:\n  - resources-finalizer.argocd.argoproj.io\nspec:\n  project: microservices\n  source:\n    repoURL: https://github.com/company/user-service-config\n    targetRevision: HEAD\n    path: overlays/production\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: microservices\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n      allowEmpty: false\n    syncOptions:\n    - CreateNamespace=true\n    - PrunePropagationPolicy=foreground\n    - PruneLast=true\n    retry:\n      limit: 5\n      backoff:\n        duration: 5s\n        factor: 2\n        maxDuration: 3m\n  revisionHistoryLimit: 10\n"})}),"\n",(0,i.jsx)(n.h3,{id:"kustomize-configuration",children:"Kustomize Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# k8s/overlays/production/kustomization.yaml\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nnamespace: microservices\n\nresources:\n- ../../base\n- secrets.yaml\n- configmap.yaml\n\nimages:\n- name: myregistry/user-service\n  newTag: v1.2.3\n\npatchesStrategicMerge:\n- deployment-patch.yaml\n- service-patch.yaml\n\nreplicas:\n- name: user-service\n  count: 5\n\nconfigMapGenerator:\n- name: user-service-config\n  files:\n  - application.yaml\n  options:\n    disableNameSuffixHash: true\n\nsecretGenerator:\n- name: user-service-secrets\n  env: secrets.env\n  options:\n    disableNameSuffixHash: true\n\nvars:\n- name: NAMESPACE\n  objref:\n    kind: Namespace\n    name: microservices\n    apiVersion: v1\n"})}),"\n",(0,i.jsx)(n.h2,{id:"deployment-automation-scripts",children:"Deployment Automation Scripts"}),"\n",(0,i.jsx)(n.h3,{id:"deployment-orchestration",children:"Deployment Orchestration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// scripts/deploy.ts\nimport { execSync } from 'child_process';\nimport * as fs from 'fs';\nimport * as yaml from 'js-yaml';\n\ninterface DeploymentConfig {\n  environment: string;\n  namespace: string;\n  imageTag: string;\n  replicas: number;\n  resources: {\n    requests: { cpu: string; memory: string };\n    limits: { cpu: string; memory: string };\n  };\n}\n\nclass DeploymentOrchestrator {\n  private config: DeploymentConfig;\n\n  constructor(environment: string) {\n    this.config = this.loadConfig(environment);\n  }\n\n  async deploy(): Promise<void> {\n    console.log(`Starting deployment to ${this.config.environment}`);\n\n    try {\n      // Pre-deployment checks\n      await this.preDeploymentChecks();\n\n      // Build and push image\n      await this.buildAndPushImage();\n\n      // Deploy to Kubernetes\n      await this.deployToKubernetes();\n\n      // Post-deployment verification\n      await this.postDeploymentVerification();\n\n      console.log('Deployment completed successfully');\n    } catch (error) {\n      console.error('Deployment failed:', error);\n      await this.rollback();\n      throw error;\n    }\n  }\n\n  private loadConfig(environment: string): DeploymentConfig {\n    const configPath = `./deploy/config/${environment}.json`;\n    return JSON.parse(fs.readFileSync(configPath, 'utf8'));\n  }\n\n  private async preDeploymentChecks(): Promise<void> {\n    console.log('Running pre-deployment checks...');\n\n    // Check cluster connectivity\n    try {\n      execSync('kubectl cluster-info', { stdio: 'pipe' });\n    } catch (error) {\n      throw new Error('Cannot connect to Kubernetes cluster');\n    }\n\n    // Check namespace exists\n    try {\n      execSync(`kubectl get namespace ${this.config.namespace}`, { stdio: 'pipe' });\n    } catch (error) {\n      console.log(`Creating namespace ${this.config.namespace}`);\n      execSync(`kubectl create namespace ${this.config.namespace}`);\n    }\n\n    // Validate configuration\n    this.validateConfiguration();\n\n    console.log('Pre-deployment checks completed');\n  }\n\n  private validateConfiguration(): void {\n    const requiredFields = ['environment', 'namespace', 'imageTag', 'replicas'];\n    for (const field of requiredFields) {\n      if (!this.config[field]) {\n        throw new Error(`Missing required configuration: ${field}`);\n      }\n    }\n\n    if (this.config.replicas < 1) {\n      throw new Error('Replicas must be at least 1');\n    }\n  }\n\n  private async buildAndPushImage(): Promise<void> {\n    console.log('Building and pushing Docker image...');\n\n    const imageName = `myregistry/user-service:${this.config.imageTag}`;\n\n    // Build image\n    execSync(`docker build -t ${imageName} .`, { stdio: 'inherit' });\n\n    // Security scan\n    try {\n      execSync(`docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image ${imageName}`, { stdio: 'inherit' });\n    } catch (error) {\n      console.warn('Security scan failed, but continuing deployment');\n    }\n\n    // Push image\n    execSync(`docker push ${imageName}`, { stdio: 'inherit' });\n\n    console.log('Image built and pushed successfully');\n  }\n\n  private async deployToKubernetes(): Promise<void> {\n    console.log('Deploying to Kubernetes...');\n\n    // Generate deployment manifest\n    const manifest = this.generateDeploymentManifest();\n    fs.writeFileSync('./deploy/generated-manifest.yaml', manifest);\n\n    // Apply manifest\n    execSync(`kubectl apply -f ./deploy/generated-manifest.yaml`, { stdio: 'inherit' });\n\n    // Wait for rollout to complete\n    execSync(`kubectl rollout status deployment/user-service -n ${this.config.namespace} --timeout=600s`, { stdio: 'inherit' });\n\n    console.log('Kubernetes deployment completed');\n  }\n\n  private generateDeploymentManifest(): string {\n    const deployment = {\n      apiVersion: 'apps/v1',\n      kind: 'Deployment',\n      metadata: {\n        name: 'user-service',\n        namespace: this.config.namespace,\n        labels: {\n          app: 'user-service',\n          version: this.config.imageTag,\n          environment: this.config.environment,\n        },\n      },\n      spec: {\n        replicas: this.config.replicas,\n        strategy: {\n          type: 'RollingUpdate',\n          rollingUpdate: {\n            maxSurge: 1,\n            maxUnavailable: 0,\n          },\n        },\n        selector: {\n          matchLabels: {\n            app: 'user-service',\n          },\n        },\n        template: {\n          metadata: {\n            labels: {\n              app: 'user-service',\n              version: this.config.imageTag,\n            },\n          },\n          spec: {\n            containers: [\n              {\n                name: 'user-service',\n                image: `myregistry/user-service:${this.config.imageTag}`,\n                ports: [{ containerPort: 3000 }],\n                resources: this.config.resources,\n                livenessProbe: {\n                  httpGet: {\n                    path: '/health',\n                    port: 3000,\n                  },\n                  initialDelaySeconds: 30,\n                  periodSeconds: 30,\n                },\n                readinessProbe: {\n                  httpGet: {\n                    path: '/health/ready',\n                    port: 3000,\n                  },\n                  initialDelaySeconds: 5,\n                  periodSeconds: 10,\n                },\n              },\n            ],\n          },\n        },\n      },\n    };\n\n    return yaml.dump(deployment);\n  }\n\n  private async postDeploymentVerification(): Promise<void> {\n    console.log('Running post-deployment verification...');\n\n    // Wait for pods to be ready\n    await this.waitForPodsReady();\n\n    // Run health checks\n    await this.runHealthChecks();\n\n    // Run smoke tests\n    await this.runSmokeTests();\n\n    console.log('Post-deployment verification completed');\n  }\n\n  private async waitForPodsReady(): Promise<void> {\n    console.log('Waiting for pods to be ready...');\n\n    let retries = 30;\n    while (retries > 0) {\n      try {\n        const output = execSync(\n          `kubectl get pods -n ${this.config.namespace} -l app=user-service -o jsonpath='{.items[*].status.phase}'`,\n          { encoding: 'utf8' }\n        );\n\n        const phases = output.trim().split(' ');\n        if (phases.every(phase => phase === 'Running')) {\n          console.log('All pods are running');\n          return;\n        }\n      } catch (error) {\n        console.warn('Error checking pod status:', error.message);\n      }\n\n      retries--;\n      await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds\n    }\n\n    throw new Error('Pods did not become ready within timeout');\n  }\n\n  private async runHealthChecks(): Promise<void> {\n    console.log('Running health checks...');\n\n    try {\n      // Port-forward to service for health check\n      const portForwardProcess = execSync(\n        `kubectl port-forward -n ${this.config.namespace} service/user-service 8080:80 &`,\n        { stdio: 'pipe' }\n      );\n\n      // Wait a moment for port-forward to establish\n      await new Promise(resolve => setTimeout(resolve, 5000));\n\n      // Make health check request\n      const response = await fetch('http://localhost:8080/health');\n      if (!response.ok) {\n        throw new Error(`Health check failed: ${response.status}`);\n      }\n\n      console.log('Health checks passed');\n    } catch (error) {\n      throw new Error(`Health check failed: ${error.message}`);\n    }\n  }\n\n  private async runSmokeTests(): Promise<void> {\n    console.log('Running smoke tests...');\n\n    try {\n      // Run smoke test suite\n      execSync('npm run test:smoke', { stdio: 'inherit' });\n      console.log('Smoke tests passed');\n    } catch (error) {\n      throw new Error(`Smoke tests failed: ${error.message}`);\n    }\n  }\n\n  private async rollback(): Promise<void> {\n    console.log('Rolling back deployment...');\n\n    try {\n      execSync(`kubectl rollout undo deployment/user-service -n ${this.config.namespace}`, { stdio: 'inherit' });\n      console.log('Rollback completed');\n    } catch (error) {\n      console.error('Rollback failed:', error.message);\n    }\n  }\n}\n\n// Usage\nconst deployer = new DeploymentOrchestrator(process.argv[2] || 'staging');\ndeployer.deploy().catch(error => {\n  console.error('Deployment failed:', error);\n  process.exit(1);\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"blue-green-deployment",children:"Blue-Green Deployment"}),"\n",(0,i.jsx)(n.h3,{id:"blue-green-strategy-implementation",children:"Blue-Green Strategy Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// scripts/blue-green-deploy.ts\ninterface BlueGreenConfig {\n  blueNamespace: string;\n  greenNamespace: string;\n  serviceNamespace: string;\n  healthCheckUrl: string;\n  trafficShiftDelay: number;\n}\n\nclass BlueGreenDeployment {\n  private config: BlueGreenConfig;\n\n  constructor(config: BlueGreenConfig) {\n    this.config = config;\n  }\n\n  async deploy(newVersion: string): Promise<void> {\n    console.log(`Starting blue-green deployment for version ${newVersion}`);\n\n    try {\n      // Determine current and target environments\n      const currentEnv = await this.getCurrentEnvironment();\n      const targetEnv = currentEnv === 'blue' ? 'green' : 'blue';\n      const targetNamespace = targetEnv === 'blue' ? this.config.blueNamespace : this.config.greenNamespace;\n\n      console.log(`Current environment: ${currentEnv}, Target environment: ${targetEnv}`);\n\n      // Deploy to target environment\n      await this.deployToEnvironment(targetNamespace, newVersion);\n\n      // Run health checks\n      await this.validateDeployment(targetNamespace);\n\n      // Switch traffic\n      await this.switchTraffic(targetEnv);\n\n      // Verify traffic switch\n      await this.verifyTrafficSwitch();\n\n      // Cleanup old environment\n      await this.cleanupOldEnvironment(currentEnv === 'blue' ? this.config.blueNamespace : this.config.greenNamespace);\n\n      console.log('Blue-green deployment completed successfully');\n    } catch (error) {\n      console.error('Blue-green deployment failed:', error);\n      throw error;\n    }\n  }\n\n  private async getCurrentEnvironment(): Promise<'blue' | 'green'> {\n    try {\n      const serviceOutput = execSync(\n        `kubectl get service user-service -n ${this.config.serviceNamespace} -o jsonpath='{.spec.selector.environment}'`,\n        { encoding: 'utf8' }\n      );\n      return serviceOutput.trim() as 'blue' | 'green';\n    } catch (error) {\n      // Default to blue if service doesn't exist\n      return 'blue';\n    }\n  }\n\n  private async deployToEnvironment(namespace: string, version: string): Promise<void> {\n    console.log(`Deploying version ${version} to ${namespace}`);\n\n    const deployment = this.generateDeploymentManifest(namespace, version);\n    fs.writeFileSync(`./deploy/${namespace}-manifest.yaml`, deployment);\n\n    execSync(`kubectl apply -f ./deploy/${namespace}-manifest.yaml`, { stdio: 'inherit' });\n    execSync(`kubectl rollout status deployment/user-service -n ${namespace} --timeout=600s`, { stdio: 'inherit' });\n  }\n\n  private async validateDeployment(namespace: string): Promise<void> {\n    console.log(`Validating deployment in ${namespace}`);\n\n    // Port-forward and run health checks\n    const portForwardProcess = spawn('kubectl', [\n      'port-forward',\n      '-n', namespace,\n      'service/user-service',\n      '8080:80'\n    ]);\n\n    await new Promise(resolve => setTimeout(resolve, 5000));\n\n    try {\n      const response = await fetch('http://localhost:8080/health');\n      if (!response.ok) {\n        throw new Error(`Health check failed: ${response.status}`);\n      }\n\n      // Run additional validation tests\n      await this.runValidationTests();\n\n      console.log(`Deployment validation successful for ${namespace}`);\n    } finally {\n      portForwardProcess.kill();\n    }\n  }\n\n  private async switchTraffic(targetEnv: 'blue' | 'green'): Promise<void> {\n    console.log(`Switching traffic to ${targetEnv} environment`);\n\n    const serviceManifest = this.generateServiceManifest(targetEnv);\n    fs.writeFileSync('./deploy/service-switch.yaml', serviceManifest);\n\n    execSync('kubectl apply -f ./deploy/service-switch.yaml', { stdio: 'inherit' });\n\n    // Wait for DNS propagation\n    await new Promise(resolve => setTimeout(resolve, this.config.trafficShiftDelay));\n  }\n\n  private async verifyTrafficSwitch(): Promise<void> {\n    console.log('Verifying traffic switch...');\n\n    let retries = 5;\n    while (retries > 0) {\n      try {\n        const response = await fetch(this.config.healthCheckUrl);\n        if (response.ok) {\n          console.log('Traffic switch verified successfully');\n          return;\n        }\n      } catch (error) {\n        console.warn(`Traffic verification attempt failed: ${error.message}`);\n      }\n\n      retries--;\n      await new Promise(resolve => setTimeout(resolve, 10000));\n    }\n\n    throw new Error('Traffic switch verification failed');\n  }\n\n  private generateServiceManifest(targetEnv: 'blue' | 'green'): string {\n    const service = {\n      apiVersion: 'v1',\n      kind: 'Service',\n      metadata: {\n        name: 'user-service',\n        namespace: this.config.serviceNamespace,\n      },\n      spec: {\n        type: 'ClusterIP',\n        ports: [\n          {\n            port: 80,\n            targetPort: 3000,\n            protocol: 'TCP',\n          },\n        ],\n        selector: {\n          app: 'user-service',\n          environment: targetEnv,\n        },\n      },\n    };\n\n    return yaml.dump(service);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"monitoring-and-observability",children:"Monitoring and Observability"}),"\n",(0,i.jsx)(n.h3,{id:"deployment-metrics",children:"Deployment Metrics"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/deployment/deployment-metrics.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Gauge, Counter, Histogram, register } from 'prom-client';\n\n@Injectable()\nexport class DeploymentMetricsService {\n  private readonly logger = new Logger(DeploymentMetricsService.name);\n\n  private readonly deploymentCounter = new Counter({\n    name: 'deployments_total',\n    help: 'Total number of deployments',\n    labelNames: ['environment', 'service', 'status'],\n    registers: [register],\n  });\n\n  private readonly deploymentDuration = new Histogram({\n    name: 'deployment_duration_seconds',\n    help: 'Duration of deployments',\n    labelNames: ['environment', 'service'],\n    buckets: [30, 60, 120, 300, 600, 1200],\n    registers: [register],\n  });\n\n  private readonly activeDeployments = new Gauge({\n    name: 'active_deployments',\n    help: 'Number of active deployments',\n    labelNames: ['environment'],\n    registers: [register],\n  });\n\n  recordDeploymentStart(environment: string, service: string): void {\n    this.activeDeployments.inc({ environment });\n    this.logger.log(`Deployment started: ${service} to ${environment}`);\n  }\n\n  recordDeploymentEnd(\n    environment: string,\n    service: string,\n    status: 'success' | 'failure',\n    duration: number,\n  ): void {\n    this.deploymentCounter.inc({ environment, service, status });\n    this.deploymentDuration.observe({ environment, service }, duration);\n    this.activeDeployments.dec({ environment });\n    \n    this.logger.log(\n      `Deployment ${status}: ${service} to ${environment} (${duration}s)`\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"deployment-guidelines",children:"Deployment Guidelines"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Immutable Infrastructure"}),": Use containerized deployments with versioned images"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Progressive Delivery"}),": Implement canary deployments for gradual rollouts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero-Downtime"}),": Use rolling updates and blue-green deployments"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security Scanning"}),": Scan container images for vulnerabilities"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Management"}),": Set appropriate resource requests and limits"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"environment-management",children:"Environment Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// scripts/environment-config.ts\nexport const ENVIRONMENT_CONFIGS = {\n  development: {\n    replicas: 1,\n    resources: {\n      requests: { cpu: '100m', memory: '128Mi' },\n      limits: { cpu: '200m', memory: '256Mi' },\n    },\n    autoscaling: { enabled: false },\n    persistence: { enabled: false },\n  },\n  staging: {\n    replicas: 2,\n    resources: {\n      requests: { cpu: '250m', memory: '256Mi' },\n      limits: { cpu: '500m', memory: '512Mi' },\n    },\n    autoscaling: { enabled: true, minReplicas: 2, maxReplicas: 5 },\n    persistence: { enabled: true },\n  },\n  production: {\n    replicas: 3,\n    resources: {\n      requests: { cpu: '500m', memory: '512Mi' },\n      limits: { cpu: '1000m', memory: '1Gi' },\n    },\n    autoscaling: { enabled: true, minReplicas: 3, maxReplicas: 20 },\n    persistence: { enabled: true },\n  },\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline",children:"CI/CD Pipeline"})})," - Continuous integration and delivery"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-definition/architecture-foundation",children:"Architecture Foundation"})})," - Core infrastructure patterns"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-definition/code-quality-tools",children:"Code Quality Tools"})})," - Pre-deployment validation"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"This deployment automation guide should be regularly updated to incorporate new tools and best practices in the DevOps ecosystem."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},7814:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(9729);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);