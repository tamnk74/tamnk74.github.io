"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[1582],{1093:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"coding-conventions/react-best-practices","title":"React Best Practices","description":"Comprehensive guidelines for building scalable, maintainable React applications with modern patterns and performance optimizations.","source":"@site/docs/coding-conventions/react-best-practices.md","sourceDirName":"coding-conventions","slug":"/coding-conventions/react-best-practices","permalink":"/fullstack-dev/docs/coding-conventions/react-best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/coding-conventions/react-best-practices.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"TypeScript Guidelines","permalink":"/fullstack-dev/docs/coding-conventions/typescript-guidelines"},"next":{"title":"Next.js Conventions","permalink":"/fullstack-dev/docs/coding-conventions/nextjs-conventions"}}');var o=t(5813),s=t(5741);const a={},i="React Best Practices",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Component Design Patterns",id:"component-design-patterns",level:2},{value:"Functional Components with Hooks",id:"functional-components-with-hooks",level:3},{value:"Compound Components Pattern",id:"compound-components-pattern",level:3},{value:"Higher-Order Components (HOCs)",id:"higher-order-components-hocs",level:3},{value:"Hooks and State Management",id:"hooks-and-state-management",level:2},{value:"Custom Hooks",id:"custom-hooks",level:3},{value:"State Management with useReducer",id:"state-management-with-usereducer",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"React.memo and useMemo",id:"reactmemo-and-usememo",level:3},{value:"Virtualization for Large Lists",id:"virtualization-for-large-lists",level:3},{value:"Code Splitting and Lazy Loading",id:"code-splitting-and-lazy-loading",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Error Boundaries",id:"error-boundaries",level:3},{value:"Error Handling Hook",id:"error-handling-hook",level:3},{value:"Testing Strategies",id:"testing-strategies",level:2},{value:"Component Testing with React Testing Library",id:"component-testing-with-react-testing-library",level:3},{value:"Custom Hook Testing",id:"custom-hook-testing",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"react-best-practices",children:"React Best Practices"})}),"\n",(0,o.jsx)(n.p,{children:"Comprehensive guidelines for building scalable, maintainable React applications with modern patterns and performance optimizations."}),"\n",(0,o.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#component-design-patterns",children:"Component Design Patterns"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#hooks-and-state-management",children:"Hooks and State Management"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#error-handling",children:"Error Handling"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#testing-strategies",children:"Testing Strategies"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#best-practices-summary",children:"Best Practices Summary"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"component-design-patterns",children:"Component Design Patterns"}),"\n",(0,o.jsx)(n.h3,{id:"functional-components-with-hooks",children:"Functional Components with Hooks"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/components/UserProfile/UserProfile.tsx\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { User, UserPreferences } from '../../types/user.types';\nimport { useUserApi } from '../../hooks/useUserApi';\nimport { LoadingSpinner } from '../UI/LoadingSpinner';\nimport { ErrorMessage } from '../UI/ErrorMessage';\n\ninterface UserProfileProps {\n  userId: string;\n  onUserUpdate?: (user: User) => void;\n  className?: string;\n}\n\nexport const UserProfile: React.FC<UserProfileProps> = ({\n  userId,\n  onUserUpdate,\n  className = '',\n}) => {\n  const [isEditing, setIsEditing] = useState(false);\n  const [preferences, setPreferences] = useState<UserPreferences | null>(null);\n  \n  const {\n    user,\n    loading,\n    error,\n    updateUser,\n    refetch,\n  } = useUserApi(userId);\n\n  // Memoized values\n  const displayName = useMemo(() => {\n    if (!user) return '';\n    return user.firstName && user.lastName \n      ? `${user.firstName} ${user.lastName}`\n      : user.email;\n  }, [user]);\n\n  const isProfileComplete = useMemo(() => {\n    return user?.firstName && user?.lastName && user?.avatar;\n  }, [user]);\n\n  // Event handlers\n  const handleEditToggle = useCallback(() => {\n    setIsEditing(prev => !prev);\n  }, []);\n\n  const handleUserSave = useCallback(async (updatedUser: Partial<User>) => {\n    try {\n      const result = await updateUser(updatedUser);\n      if (result && onUserUpdate) {\n        onUserUpdate(result);\n      }\n      setIsEditing(false);\n    } catch (error) {\n      console.error('Failed to update user:', error);\n    }\n  }, [updateUser, onUserUpdate]);\n\n  const handlePreferencesChange = useCallback((newPreferences: UserPreferences) => {\n    setPreferences(newPreferences);\n  }, []);\n\n  // Effects\n  useEffect(() => {\n    if (user?.preferences) {\n      setPreferences(user.preferences);\n    }\n  }, [user?.preferences]);\n\n  if (loading) {\n    return <LoadingSpinner size=\"large\" />;\n  }\n\n  if (error) {\n    return (\n      <ErrorMessage \n        message=\"Failed to load user profile\"\n        onRetry={refetch}\n      />\n    );\n  }\n\n  if (!user) {\n    return <div>User not found</div>;\n  }\n\n  return (\n    <div className={`user-profile ${className}`}>\n      <div className=\"user-profile__header\">\n        <Avatar src={user.avatar} alt={displayName} size=\"large\" />\n        <div className=\"user-profile__info\">\n          <h2 className=\"user-profile__name\">{displayName}</h2>\n          <p className=\"user-profile__email\">{user.email}</p>\n          {!isProfileComplete && (\n            <div className=\"user-profile__warning\">\n              Profile incomplete\n            </div>\n          )}\n        </div>\n        <button\n          onClick={handleEditToggle}\n          className=\"btn btn--secondary\"\n          aria-label={isEditing ? 'Cancel editing' : 'Edit profile'}\n        >\n          {isEditing ? 'Cancel' : 'Edit'}\n        </button>\n      </div>\n\n      {isEditing ? (\n        <UserEditForm\n          user={user}\n          preferences={preferences}\n          onSave={handleUserSave}\n          onCancel={handleEditToggle}\n          onPreferencesChange={handlePreferencesChange}\n        />\n      ) : (\n        <UserDisplayInfo user={user} preferences={preferences} />\n      )}\n    </div>\n  );\n};\n\n// Default export with display name for debugging\nUserProfile.displayName = 'UserProfile';\nexport default React.memo(UserProfile);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"compound-components-pattern",children:"Compound Components Pattern"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/components/Modal/Modal.tsx\nimport React, { createContext, useContext, useState, useCallback } from 'react';\nimport { createPortal } from 'react-dom';\n\ninterface ModalContextValue {\n  isOpen: boolean;\n  open: () => void;\n  close: () => void;\n}\n\nconst ModalContext = createContext<ModalContextValue | null>(null);\n\nconst useModalContext = () => {\n  const context = useContext(ModalContext);\n  if (!context) {\n    throw new Error('Modal components must be used within a Modal');\n  }\n  return context;\n};\n\ninterface ModalProps {\n  children: React.ReactNode;\n  onClose?: () => void;\n}\n\nexport const Modal: React.FC<ModalProps> & {\n  Trigger: React.FC<ModalTriggerProps>;\n  Content: React.FC<ModalContentProps>;\n  Header: React.FC<ModalHeaderProps>;\n  Body: React.FC<ModalBodyProps>;\n  Footer: React.FC<ModalFooterProps>;\n} = ({ children, onClose }) => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const open = useCallback(() => setIsOpen(true), []);\n  const close = useCallback(() => {\n    setIsOpen(false);\n    onClose?.();\n  }, [onClose]);\n\n  const contextValue = {\n    isOpen,\n    open,\n    close,\n  };\n\n  return (\n    <ModalContext.Provider value={contextValue}>\n      {children}\n    </ModalContext.Provider>\n  );\n};\n\n// Modal Trigger Component\ninterface ModalTriggerProps {\n  children: React.ReactNode;\n  asChild?: boolean;\n}\n\nconst ModalTrigger: React.FC<ModalTriggerProps> = ({ children, asChild = false }) => {\n  const { open } = useModalContext();\n\n  if (asChild && React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      onClick: (e: React.MouseEvent) => {\n        children.props.onClick?.(e);\n        open();\n      },\n    });\n  }\n\n  return (\n    <button onClick={open} type=\"button\">\n      {children}\n    </button>\n  );\n};\n\n// Modal Content Component\ninterface ModalContentProps {\n  children: React.ReactNode;\n  className?: string;\n  size?: 'small' | 'medium' | 'large';\n}\n\nconst ModalContent: React.FC<ModalContentProps> = ({ \n  children, \n  className = '',\n  size = 'medium'\n}) => {\n  const { isOpen, close } = useModalContext();\n\n  const handleBackdropClick = useCallback((e: React.MouseEvent) => {\n    if (e.target === e.currentTarget) {\n      close();\n    }\n  }, [close]);\n\n  if (!isOpen) return null;\n\n  return createPortal(\n    <div \n      className=\"modal-backdrop\" \n      onClick={handleBackdropClick}\n      role=\"dialog\"\n      aria-modal=\"true\"\n    >\n      <div className={`modal-content modal-content--${size} ${className}`}>\n        <button\n          className=\"modal-close\"\n          onClick={close}\n          aria-label=\"Close modal\"\n        >\n          \xd7\n        </button>\n        {children}\n      </div>\n    </div>,\n    document.body\n  );\n};\n\n// Usage example\nconst App = () => {\n  return (\n    <Modal>\n      <Modal.Trigger>\n        <button>Open Modal</button>\n      </Modal.Trigger>\n      <Modal.Content size=\"large\">\n        <Modal.Header>\n          <h2>Modal Title</h2>\n        </Modal.Header>\n        <Modal.Body>\n          <p>Modal content goes here...</p>\n        </Modal.Body>\n        <Modal.Footer>\n          <button>Save</button>\n          <button>Cancel</button>\n        </Modal.Footer>\n      </Modal.Content>\n    </Modal>\n  );\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"higher-order-components-hocs",children:"Higher-Order Components (HOCs)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/hocs/withAuth.tsx\nimport React, { ComponentType } from 'react';\nimport { useAuth } from '../hooks/useAuth';\nimport { LoadingSpinner } from '../components/UI/LoadingSpinner';\nimport { LoginForm } from '../components/Auth/LoginForm';\n\ninterface WithAuthOptions {\n  requiredRoles?: string[];\n  redirectTo?: string;\n  showLoading?: boolean;\n}\n\nexport function withAuth<P extends object>(\n  WrappedComponent: ComponentType<P>,\n  options: WithAuthOptions = {}\n) {\n  const {\n    requiredRoles = [],\n    showLoading = true,\n  } = options;\n\n  const WithAuthComponent: React.FC<P> = (props) => {\n    const { user, loading, hasRole } = useAuth();\n\n    if (loading && showLoading) {\n      return <LoadingSpinner />;\n    }\n\n    if (!user) {\n      return <LoginForm />;\n    }\n\n    if (requiredRoles.length > 0 && !hasRole(requiredRoles)) {\n      return (\n        <div className=\"access-denied\">\n          <h2>Access Denied</h2>\n          <p>You don't have permission to access this page.</p>\n        </div>\n      );\n    }\n\n    return <WrappedComponent {...props} />;\n  };\n\n  WithAuthComponent.displayName = `withAuth(${WrappedComponent.displayName || WrappedComponent.name})`;\n\n  return WithAuthComponent;\n}\n\n// Usage\nconst ProtectedDashboard = withAuth(Dashboard, {\n  requiredRoles: ['admin', 'user'],\n});\n"})}),"\n",(0,o.jsx)(n.h2,{id:"hooks-and-state-management",children:"Hooks and State Management"}),"\n",(0,o.jsx)(n.h3,{id:"custom-hooks",children:"Custom Hooks"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/hooks/useApi.ts\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\ninterface UseApiOptions<T> {\n  initialData?: T;\n  onSuccess?: (data: T) => void;\n  onError?: (error: Error) => void;\n  dependencies?: any[];\n}\n\ninterface UseApiReturn<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n  reset: () => void;\n}\n\nexport function useApi<T>(\n  apiFunction: () => Promise<T>,\n  options: UseApiOptions<T> = {}\n): UseApiReturn<T> {\n  const {\n    initialData = null,\n    onSuccess,\n    onError,\n    dependencies = [],\n  } = options;\n\n  const [data, setData] = useState<T | null>(initialData);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const mountedRef = useRef(true);\n\n  const fetchData = useCallback(async () => {\n    if (!mountedRef.current) return;\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await apiFunction();\n      \n      if (mountedRef.current) {\n        setData(result);\n        onSuccess?.(result);\n      }\n    } catch (err) {\n      if (mountedRef.current) {\n        const error = err instanceof Error ? err : new Error('Unknown error');\n        setError(error);\n        onError?.(error);\n      }\n    } finally {\n      if (mountedRef.current) {\n        setLoading(false);\n      }\n    }\n  }, [apiFunction, onSuccess, onError]);\n\n  const reset = useCallback(() => {\n    setData(initialData);\n    setError(null);\n    setLoading(false);\n  }, [initialData]);\n\n  useEffect(() => {\n    fetchData();\n  }, dependencies);\n\n  useEffect(() => {\n    return () => {\n      mountedRef.current = false;\n    };\n  }, []);\n\n  return {\n    data,\n    loading,\n    error,\n    refetch: fetchData,\n    reset,\n  };\n}\n\n// src/hooks/useLocalStorage.ts\nimport { useState, useEffect, useCallback } from 'react';\n\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T\n): [T, (value: T | ((prev: T) => T)) => void, () => void] {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n\n  const setValue = useCallback((value: T | ((prev: T) => T)) => {\n    try {\n      const valueToStore = value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [key, storedValue]);\n\n  const removeValue = useCallback(() => {\n    try {\n      window.localStorage.removeItem(key);\n      setStoredValue(initialValue);\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error);\n    }\n  }, [key, initialValue]);\n\n  useEffect(() => {\n    const handleStorageChange = (e: StorageEvent) => {\n      if (e.key === key && e.newValue) {\n        try {\n          setStoredValue(JSON.parse(e.newValue));\n        } catch (error) {\n          console.error(`Error parsing localStorage value for key \"${key}\":`, error);\n        }\n      }\n    };\n\n    window.addEventListener('storage', handleStorageChange);\n    return () => window.removeEventListener('storage', handleStorageChange);\n  }, [key]);\n\n  return [storedValue, setValue, removeValue];\n}\n\n// src/hooks/useDebounce.ts\nimport { useState, useEffect } from 'react';\n\nexport function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"state-management-with-usereducer",children:"State Management with useReducer"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/hooks/useShoppingCart.ts\nimport { useReducer, useCallback, useMemo } from 'react';\n\ninterface CartItem {\n  id: string;\n  name: string;\n  price: number;\n  quantity: number;\n  image?: string;\n}\n\ninterface CartState {\n  items: CartItem[];\n  total: number;\n  itemCount: number;\n}\n\ntype CartAction =\n  | { type: 'ADD_ITEM'; payload: Omit<CartItem, 'quantity'> }\n  | { type: 'REMOVE_ITEM'; payload: { id: string } }\n  | { type: 'UPDATE_QUANTITY'; payload: { id: string; quantity: number } }\n  | { type: 'CLEAR_CART' }\n  | { type: 'SET_CART'; payload: CartItem[] };\n\nconst cartReducer = (state: CartState, action: CartAction): CartState => {\n  switch (action.type) {\n    case 'ADD_ITEM': {\n      const existingItem = state.items.find(item => item.id === action.payload.id);\n      \n      let newItems: CartItem[];\n      if (existingItem) {\n        newItems = state.items.map(item =>\n          item.id === action.payload.id\n            ? { ...item, quantity: item.quantity + 1 }\n            : item\n        );\n      } else {\n        newItems = [...state.items, { ...action.payload, quantity: 1 }];\n      }\n\n      return {\n        ...state,\n        items: newItems,\n        total: calculateTotal(newItems),\n        itemCount: calculateItemCount(newItems),\n      };\n    }\n\n    case 'REMOVE_ITEM': {\n      const newItems = state.items.filter(item => item.id !== action.payload.id);\n      return {\n        ...state,\n        items: newItems,\n        total: calculateTotal(newItems),\n        itemCount: calculateItemCount(newItems),\n      };\n    }\n\n    case 'UPDATE_QUANTITY': {\n      const newItems = state.items.map(item =>\n        item.id === action.payload.id\n          ? { ...item, quantity: Math.max(0, action.payload.quantity) }\n          : item\n      ).filter(item => item.quantity > 0);\n\n      return {\n        ...state,\n        items: newItems,\n        total: calculateTotal(newItems),\n        itemCount: calculateItemCount(newItems),\n      };\n    }\n\n    case 'CLEAR_CART':\n      return {\n        items: [],\n        total: 0,\n        itemCount: 0,\n      };\n\n    case 'SET_CART': {\n      return {\n        ...state,\n        items: action.payload,\n        total: calculateTotal(action.payload),\n        itemCount: calculateItemCount(action.payload),\n      };\n    }\n\n    default:\n      return state;\n  }\n};\n\nconst calculateTotal = (items: CartItem[]): number => {\n  return items.reduce((total, item) => total + (item.price * item.quantity), 0);\n};\n\nconst calculateItemCount = (items: CartItem[]): number => {\n  return items.reduce((count, item) => count + item.quantity, 0);\n};\n\nexport const useShoppingCart = () => {\n  const [state, dispatch] = useReducer(cartReducer, {\n    items: [],\n    total: 0,\n    itemCount: 0,\n  });\n\n  const addItem = useCallback((item: Omit<CartItem, 'quantity'>) => {\n    dispatch({ type: 'ADD_ITEM', payload: item });\n  }, []);\n\n  const removeItem = useCallback((id: string) => {\n    dispatch({ type: 'REMOVE_ITEM', payload: { id } });\n  }, []);\n\n  const updateQuantity = useCallback((id: string, quantity: number) => {\n    dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } });\n  }, []);\n\n  const clearCart = useCallback(() => {\n    dispatch({ type: 'CLEAR_CART' });\n  }, []);\n\n  const isItemInCart = useCallback((id: string): boolean => {\n    return state.items.some(item => item.id === id);\n  }, [state.items]);\n\n  const getItemQuantity = useCallback((id: string): number => {\n    const item = state.items.find(item => item.id === id);\n    return item?.quantity || 0;\n  }, [state.items]);\n\n  const cartSummary = useMemo(() => ({\n    subtotal: state.total,\n    tax: state.total * 0.08, // 8% tax\n    shipping: state.total > 50 ? 0 : 10, // Free shipping over $50\n    total: state.total + (state.total * 0.08) + (state.total > 50 ? 0 : 10),\n  }), [state.total]);\n\n  return {\n    ...state,\n    addItem,\n    removeItem,\n    updateQuantity,\n    clearCart,\n    isItemInCart,\n    getItemQuantity,\n    cartSummary,\n  };\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(n.h3,{id:"reactmemo-and-usememo",children:"React.memo and useMemo"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/components/ProductList/ProductList.tsx\nimport React, { useMemo, useState, useCallback } from 'react';\nimport { Product } from '../../types/product.types';\n\ninterface ProductListProps {\n  products: Product[];\n  onProductSelect: (product: Product) => void;\n  filters: ProductFilters;\n}\n\ninterface ProductFilters {\n  category?: string;\n  minPrice?: number;\n  maxPrice?: number;\n  searchTerm?: string;\n}\n\nexport const ProductList: React.FC<ProductListProps> = React.memo(({\n  products,\n  onProductSelect,\n  filters,\n}) => {\n  const [sortBy, setSortBy] = useState<'name' | 'price' | 'rating'>('name');\n  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');\n\n  // Memoized filtered and sorted products\n  const filteredAndSortedProducts = useMemo(() => {\n    let filtered = products;\n\n    // Apply filters\n    if (filters.category) {\n      filtered = filtered.filter(product => \n        product.category === filters.category\n      );\n    }\n\n    if (filters.minPrice !== undefined) {\n      filtered = filtered.filter(product => \n        product.price >= filters.minPrice!\n      );\n    }\n\n    if (filters.maxPrice !== undefined) {\n      filtered = filtered.filter(product => \n        product.price <= filters.maxPrice!\n      );\n    }\n\n    if (filters.searchTerm) {\n      const searchLower = filters.searchTerm.toLowerCase();\n      filtered = filtered.filter(product =>\n        product.name.toLowerCase().includes(searchLower) ||\n        product.description.toLowerCase().includes(searchLower)\n      );\n    }\n\n    // Apply sorting\n    filtered.sort((a, b) => {\n      let comparison = 0;\n      \n      switch (sortBy) {\n        case 'name':\n          comparison = a.name.localeCompare(b.name);\n          break;\n        case 'price':\n          comparison = a.price - b.price;\n          break;\n        case 'rating':\n          comparison = a.rating - b.rating;\n          break;\n      }\n\n      return sortOrder === 'asc' ? comparison : -comparison;\n    });\n\n    return filtered;\n  }, [products, filters, sortBy, sortOrder]);\n\n  // Memoized handlers\n  const handleSortChange = useCallback((newSortBy: typeof sortBy) => {\n    if (newSortBy === sortBy) {\n      setSortOrder(prev => prev === 'asc' ? 'desc' : 'asc');\n    } else {\n      setSortBy(newSortBy);\n      setSortOrder('asc');\n    }\n  }, [sortBy]);\n\n  const handleProductClick = useCallback((product: Product) => {\n    onProductSelect(product);\n  }, [onProductSelect]);\n\n  return (\n    <div className=\"product-list\">\n      <div className=\"product-list__header\">\n        <div className=\"product-list__sort\">\n          <button\n            onClick={() => handleSortChange('name')}\n            className={sortBy === 'name' ? 'active' : ''}\n          >\n            Name {sortBy === 'name' && (sortOrder === 'asc' ? '\u2191' : '\u2193')}\n          </button>\n          <button\n            onClick={() => handleSortChange('price')}\n            className={sortBy === 'price' ? 'active' : ''}\n          >\n            Price {sortBy === 'price' && (sortOrder === 'asc' ? '\u2191' : '\u2193')}\n          </button>\n          <button\n            onClick={() => handleSortChange('rating')}\n            className={sortBy === 'rating' ? 'active' : ''}\n          >\n            Rating {sortBy === 'rating' && (sortOrder === 'asc' ? '\u2191' : '\u2193')}\n          </button>\n        </div>\n        <div className=\"product-list__count\">\n          {filteredAndSortedProducts.length} products found\n        </div>\n      </div>\n\n      <div className=\"product-list__grid\">\n        {filteredAndSortedProducts.map(product => (\n          <ProductCard\n            key={product.id}\n            product={product}\n            onClick={handleProductClick}\n          />\n        ))}\n      </div>\n    </div>\n  );\n});\n\nProductList.displayName = 'ProductList';\n"})}),"\n",(0,o.jsx)(n.h3,{id:"virtualization-for-large-lists",children:"Virtualization for Large Lists"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/components/VirtualizedList/VirtualizedList.tsx\nimport React, { useState, useEffect, useRef, useMemo } from 'react';\n\ninterface VirtualizedListProps<T> {\n  items: T[];\n  itemHeight: number;\n  containerHeight: number;\n  renderItem: (item: T, index: number) => React.ReactNode;\n  keyExtractor: (item: T, index: number) => string;\n  overscan?: number;\n}\n\nexport function VirtualizedList<T>({\n  items,\n  itemHeight,\n  containerHeight,\n  renderItem,\n  keyExtractor,\n  overscan = 5,\n}: VirtualizedListProps<T>) {\n  const [scrollTop, setScrollTop] = useState(0);\n  const scrollElementRef = useRef<HTMLDivElement>(null);\n\n  const visibleRange = useMemo(() => {\n    const start = Math.floor(scrollTop / itemHeight);\n    const end = Math.min(\n      start + Math.ceil(containerHeight / itemHeight),\n      items.length - 1\n    );\n\n    return {\n      start: Math.max(0, start - overscan),\n      end: Math.min(items.length - 1, end + overscan),\n    };\n  }, [scrollTop, itemHeight, containerHeight, items.length, overscan]);\n\n  const visibleItems = useMemo(() => {\n    return items.slice(visibleRange.start, visibleRange.end + 1);\n  }, [items, visibleRange]);\n\n  const totalHeight = items.length * itemHeight;\n  const offsetY = visibleRange.start * itemHeight;\n\n  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {\n    setScrollTop(e.currentTarget.scrollTop);\n  };\n\n  return (\n    <div\n      ref={scrollElementRef}\n      className=\"virtualized-list\"\n      style={{ height: containerHeight, overflow: 'auto' }}\n      onScroll={handleScroll}\n    >\n      <div style={{ height: totalHeight, position: 'relative' }}>\n        <div\n          style={{\n            transform: `translateY(${offsetY}px)`,\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n          }}\n        >\n          {visibleItems.map((item, index) => (\n            <div\n              key={keyExtractor(item, visibleRange.start + index)}\n              style={{ height: itemHeight }}\n            >\n              {renderItem(item, visibleRange.start + index)}\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"code-splitting-and-lazy-loading",children:"Code Splitting and Lazy Loading"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/components/LazyRoute/LazyRoute.tsx\nimport React, { Suspense } from 'react';\nimport { LoadingSpinner } from '../UI/LoadingSpinner';\nimport { ErrorBoundary } from '../ErrorBoundary/ErrorBoundary';\n\ninterface LazyRouteProps {\n  children: React.ReactNode;\n  fallback?: React.ReactNode;\n  errorFallback?: React.ComponentType<{ error: Error; retry: () => void }>;\n}\n\nexport const LazyRoute: React.FC<LazyRouteProps> = ({\n  children,\n  fallback = <LoadingSpinner />,\n  errorFallback,\n}) => {\n  return (\n    <ErrorBoundary fallback={errorFallback}>\n      <Suspense fallback={fallback}>\n        {children}\n      </Suspense>\n    </ErrorBoundary>\n  );\n};\n\n// src/pages/Dashboard/Dashboard.lazy.tsx\nimport { lazy } from 'react';\n\nexport const DashboardPage = lazy(() => \n  import('./Dashboard').then(module => ({\n    default: module.Dashboard\n  }))\n);\n\n// Route configuration\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport { LazyRoute } from './components/LazyRoute/LazyRoute';\nimport { DashboardPage } from './pages/Dashboard/Dashboard.lazy';\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route\n          path=\"/dashboard\"\n          element={\n            <LazyRoute>\n              <DashboardPage />\n            </LazyRoute>\n          }\n        />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(n.h3,{id:"error-boundaries",children:"Error Boundaries"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/components/ErrorBoundary/ErrorBoundary.tsx\nimport React, { Component, ErrorInfo, ReactNode } from 'react';\nimport { logError } from '../../utils/errorLogging';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: React.ComponentType<ErrorBoundaryState>;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n  errorInfo: ErrorInfo | null;\n}\n\nconst DefaultErrorFallback: React.FC<ErrorBoundaryState & { retry: () => void }> = ({\n  error,\n  retry,\n}) => (\n  <div className=\"error-boundary\">\n    <h2>Something went wrong</h2>\n    <p>{error?.message || 'An unexpected error occurred'}</p>\n    <button onClick={retry} className=\"btn btn--primary\">\n      Try Again\n    </button>\n    {process.env.NODE_ENV === 'development' && (\n      <details className=\"error-details\">\n        <summary>Error Details</summary>\n        <pre>{error?.stack}</pre>\n      </details>\n    )}\n  </div>\n);\n\nexport class ErrorBoundary extends Component<Props, ErrorBoundaryState> {\n  public state: ErrorBoundaryState = {\n    hasError: false,\n    error: null,\n    errorInfo: null,\n  };\n\n  public static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {\n    return { hasError: true, error };\n  }\n\n  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    this.setState({ errorInfo });\n    \n    // Log error to monitoring service\n    logError(error, errorInfo);\n    \n    // Call custom error handler\n    this.props.onError?.(error, errorInfo);\n  }\n\n  private retry = () => {\n    this.setState({\n      hasError: false,\n      error: null,\n      errorInfo: null,\n    });\n  };\n\n  public render() {\n    if (this.state.hasError) {\n      const FallbackComponent = this.props.fallback || DefaultErrorFallback;\n      return (\n        <FallbackComponent\n          hasError={this.state.hasError}\n          error={this.state.error}\n          errorInfo={this.state.errorInfo}\n          retry={this.retry}\n        />\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// HOC for error boundary\nexport function withErrorBoundary<P extends object>(\n  Component: React.ComponentType<P>,\n  errorBoundaryProps?: Omit<Props, 'children'>\n) {\n  const WrappedComponent: React.FC<P> = (props) => (\n    <ErrorBoundary {...errorBoundaryProps}>\n      <Component {...props} />\n    </ErrorBoundary>\n  );\n\n  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`;\n\n  return WrappedComponent;\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"error-handling-hook",children:"Error Handling Hook"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/hooks/useErrorHandler.ts\nimport { useCallback } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { toast } from 'react-toastify';\n\ninterface ErrorHandlerOptions {\n  redirectTo?: string;\n  showToast?: boolean;\n  logError?: boolean;\n}\n\nexport const useErrorHandler = () => {\n  const navigate = useNavigate();\n\n  const handleError = useCallback((\n    error: Error,\n    options: ErrorHandlerOptions = {}\n  ) => {\n    const {\n      redirectTo,\n      showToast = true,\n      logError = true,\n    } = options;\n\n    // Log error\n    if (logError) {\n      console.error('Error caught by error handler:', error);\n      // Send to error tracking service\n      // Sentry.captureException(error);\n    }\n\n    // Show user-friendly message\n    if (showToast) {\n      const message = getErrorMessage(error);\n      toast.error(message);\n    }\n\n    // Redirect if specified\n    if (redirectTo) {\n      navigate(redirectTo);\n    }\n  }, [navigate]);\n\n  return handleError;\n};\n\nconst getErrorMessage = (error: Error): string => {\n  // Network errors\n  if (error.name === 'NetworkError' || error.message.includes('fetch')) {\n    return 'Network error. Please check your connection and try again.';\n  }\n\n  // Authentication errors\n  if (error.message.includes('401') || error.message.includes('Unauthorized')) {\n    return 'Your session has expired. Please log in again.';\n  }\n\n  // Validation errors\n  if (error.message.includes('400') || error.message.includes('validation')) {\n    return 'Please check your input and try again.';\n  }\n\n  // Server errors\n  if (error.message.includes('500')) {\n    return 'Server error. Please try again later.';\n  }\n\n  // Default message\n  return error.message || 'An unexpected error occurred.';\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,o.jsx)(n.h3,{id:"component-testing-with-react-testing-library",children:"Component Testing with React Testing Library"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/components/UserProfile/UserProfile.test.tsx\nimport React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { UserProfile } from './UserProfile';\nimport { useUserApi } from '../../hooks/useUserApi';\nimport { User } from '../../types/user.types';\n\n// Mock the custom hook\njest.mock('../../hooks/useUserApi');\nconst mockUseUserApi = useUserApi as jest.MockedFunction<typeof useUserApi>;\n\nconst mockUser: User = {\n  id: '1',\n  email: 'test@example.com',\n  firstName: 'John',\n  lastName: 'Doe',\n  avatar: 'https://example.com/avatar.jpg',\n  preferences: {\n    theme: 'light',\n    notifications: true,\n  },\n};\n\ndescribe('UserProfile', () => {\n  const mockOnUserUpdate = jest.fn();\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('renders user information correctly', () => {\n    mockUseUserApi.mockReturnValue({\n      user: mockUser,\n      loading: false,\n      error: null,\n      updateUser: jest.fn(),\n      refetch: jest.fn(),\n    });\n\n    render(<UserProfile userId=\"1\" onUserUpdate={mockOnUserUpdate} />);\n\n    expect(screen.getByText('John Doe')).toBeInTheDocument();\n    expect(screen.getByText('test@example.com')).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /edit profile/i })).toBeInTheDocument();\n  });\n\n  it('shows loading state', () => {\n    mockUseUserApi.mockReturnValue({\n      user: null,\n      loading: true,\n      error: null,\n      updateUser: jest.fn(),\n      refetch: jest.fn(),\n    });\n\n    render(<UserProfile userId=\"1\" onUserUpdate={mockOnUserUpdate} />);\n\n    expect(screen.getByRole('progressbar')).toBeInTheDocument();\n  });\n\n  it('shows error state with retry option', async () => {\n    const mockRefetch = jest.fn();\n    mockUseUserApi.mockReturnValue({\n      user: null,\n      loading: false,\n      error: new Error('Failed to load user'),\n      updateUser: jest.fn(),\n      refetch: mockRefetch,\n    });\n\n    render(<UserProfile userId=\"1\" onUserUpdate={mockOnUserUpdate} />);\n\n    expect(screen.getByText('Failed to load user profile')).toBeInTheDocument();\n    \n    const retryButton = screen.getByRole('button', { name: /retry/i });\n    await userEvent.click(retryButton);\n    \n    expect(mockRefetch).toHaveBeenCalledTimes(1);\n  });\n\n  it('toggles edit mode when edit button is clicked', async () => {\n    mockUseUserApi.mockReturnValue({\n      user: mockUser,\n      loading: false,\n      error: null,\n      updateUser: jest.fn(),\n      refetch: jest.fn(),\n    });\n\n    render(<UserProfile userId=\"1\" onUserUpdate={mockOnUserUpdate} />);\n\n    const editButton = screen.getByRole('button', { name: /edit profile/i });\n    await userEvent.click(editButton);\n\n    expect(screen.getByRole('button', { name: /cancel editing/i })).toBeInTheDocument();\n  });\n\n  it('calls onUserUpdate when user is successfully updated', async () => {\n    const mockUpdateUser = jest.fn().mockResolvedValue(mockUser);\n    \n    mockUseUserApi.mockReturnValue({\n      user: mockUser,\n      loading: false,\n      error: null,\n      updateUser: mockUpdateUser,\n      refetch: jest.fn(),\n    });\n\n    render(<UserProfile userId=\"1\" onUserUpdate={mockOnUserUpdate} />);\n\n    const editButton = screen.getByRole('button', { name: /edit profile/i });\n    await userEvent.click(editButton);\n\n    // Simulate form submission (assuming UserEditForm is mocked or simplified)\n    // This would depend on the actual implementation of UserEditForm\n    \n    await waitFor(() => {\n      expect(mockOnUserUpdate).toHaveBeenCalledWith(mockUser);\n    });\n  });\n\n  it('handles keyboard navigation', async () => {\n    mockUseUserApi.mockReturnValue({\n      user: mockUser,\n      loading: false,\n      error: null,\n      updateUser: jest.fn(),\n      refetch: jest.fn(),\n    });\n\n    render(<UserProfile userId=\"1\" onUserUpdate={mockOnUserUpdate} />);\n\n    const editButton = screen.getByRole('button', { name: /edit profile/i });\n    \n    // Test keyboard accessibility\n    editButton.focus();\n    expect(editButton).toHaveFocus();\n    \n    await userEvent.keyboard('{Enter}');\n    expect(screen.getByRole('button', { name: /cancel editing/i })).toBeInTheDocument();\n  });\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"custom-hook-testing",children:"Custom Hook Testing"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/hooks/useShoppingCart.test.ts\nimport { renderHook, act } from '@testing-library/react';\nimport { useShoppingCart } from './useShoppingCart';\n\nconst mockProduct = {\n  id: '1',\n  name: 'Test Product',\n  price: 10.99,\n  image: 'test.jpg',\n};\n\ndescribe('useShoppingCart', () => {\n  it('should initialize with empty cart', () => {\n    const { result } = renderHook(() => useShoppingCart());\n\n    expect(result.current.items).toEqual([]);\n    expect(result.current.total).toBe(0);\n    expect(result.current.itemCount).toBe(0);\n  });\n\n  it('should add item to cart', () => {\n    const { result } = renderHook(() => useShoppingCart());\n\n    act(() => {\n      result.current.addItem(mockProduct);\n    });\n\n    expect(result.current.items).toHaveLength(1);\n    expect(result.current.items[0]).toEqual({\n      ...mockProduct,\n      quantity: 1,\n    });\n    expect(result.current.total).toBe(10.99);\n    expect(result.current.itemCount).toBe(1);\n  });\n\n  it('should increase quantity when adding existing item', () => {\n    const { result } = renderHook(() => useShoppingCart());\n\n    act(() => {\n      result.current.addItem(mockProduct);\n      result.current.addItem(mockProduct);\n    });\n\n    expect(result.current.items).toHaveLength(1);\n    expect(result.current.items[0].quantity).toBe(2);\n    expect(result.current.total).toBe(21.98);\n    expect(result.current.itemCount).toBe(2);\n  });\n\n  it('should remove item from cart', () => {\n    const { result } = renderHook(() => useShoppingCart());\n\n    act(() => {\n      result.current.addItem(mockProduct);\n    });\n\n    expect(result.current.items).toHaveLength(1);\n\n    act(() => {\n      result.current.removeItem(mockProduct.id);\n    });\n\n    expect(result.current.items).toHaveLength(0);\n    expect(result.current.total).toBe(0);\n    expect(result.current.itemCount).toBe(0);\n  });\n\n  it('should update item quantity', () => {\n    const { result } = renderHook(() => useShoppingCart());\n\n    act(() => {\n      result.current.addItem(mockProduct);\n    });\n\n    act(() => {\n      result.current.updateQuantity(mockProduct.id, 5);\n    });\n\n    expect(result.current.items[0].quantity).toBe(5);\n    expect(result.current.total).toBe(54.95);\n    expect(result.current.itemCount).toBe(5);\n  });\n\n  it('should remove item when quantity is set to 0', () => {\n    const { result } = renderHook(() => useShoppingCart());\n\n    act(() => {\n      result.current.addItem(mockProduct);\n    });\n\n    act(() => {\n      result.current.updateQuantity(mockProduct.id, 0);\n    });\n\n    expect(result.current.items).toHaveLength(0);\n  });\n\n  it('should calculate cart summary correctly', () => {\n    const { result } = renderHook(() => useShoppingCart());\n\n    act(() => {\n      result.current.addItem(mockProduct);\n      result.current.updateQuantity(mockProduct.id, 10); // $109.90\n    });\n\n    const { cartSummary } = result.current;\n    \n    expect(cartSummary.subtotal).toBe(109.90);\n    expect(cartSummary.tax).toBeCloseTo(8.79); // 8% tax\n    expect(cartSummary.shipping).toBe(0); // Free shipping over $50\n    expect(cartSummary.total).toBeCloseTo(118.69);\n  });\n\n  it('should clear cart', () => {\n    const { result } = renderHook(() => useShoppingCart());\n\n    act(() => {\n      result.current.addItem(mockProduct);\n      result.current.addItem({ ...mockProduct, id: '2' });\n    });\n\n    expect(result.current.items).toHaveLength(2);\n\n    act(() => {\n      result.current.clearCart();\n    });\n\n    expect(result.current.items).toHaveLength(0);\n    expect(result.current.total).toBe(0);\n    expect(result.current.itemCount).toBe(0);\n  });\n});\n"})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use functional components"})," with hooks for new components"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Implement proper TypeScript typing"})," for all props and state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Optimize performance"})," with React.memo, useMemo, and useCallback"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Handle errors gracefully"})," with error boundaries and error handling hooks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Write comprehensive tests"})," for components and custom hooks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use custom hooks"})," for reusable stateful logic"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Implement proper accessibility"})," with ARIA attributes and semantic HTML"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Apply code splitting"})," for better bundle management"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Follow consistent naming conventions"})," and file organization"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use proper state management"})," patterns based on complexity needs"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},5741:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(9729);const o={},s=r.createContext(o);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);