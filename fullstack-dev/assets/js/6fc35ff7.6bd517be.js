"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[8217],{5409:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"security-practices/security-implementation/secure-sdlc","title":"Secure SDLC Implementation Guide","description":"This guide provides comprehensive Secure Software Development Life Cycle (SDLC) implementation for NestJS/Next.js applications on GCP Kubernetes, covering access controls, approval processes, and development security practices.","source":"@site/docs/security-practices/security-implementation/secure-sdlc.md","sourceDirName":"security-practices/security-implementation","slug":"/security-practices/security-implementation/secure-sdlc","permalink":"/fullstack-dev/docs/security-practices/security-implementation/secure-sdlc","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/security-practices/security-implementation/secure-sdlc.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Log Data Security Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/log-data-security"},"next":{"title":"Code Review & Solution Design Security Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/code-review-security"}}');var r=s(5813),o=s(5741);const i={},a="Secure SDLC Implementation Guide",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Production Access Controls",id:"production-access-controls",level:2},{value:"GCP Access Control Implementation",id:"gcp-access-control-implementation",level:3},{value:"Access Approval Process",id:"access-approval-process",level:2},{value:"Approval Workflow Implementation",id:"approval-workflow-implementation",level:3},{value:"Environment Isolation",id:"environment-isolation",level:2},{value:"Environment Security Configuration",id:"environment-security-configuration",level:3},{value:"Environment Access Control",id:"environment-access-control",level:3},{value:"Development Tools Security",id:"development-tools-security",level:2},{value:"Tool Approval Service",id:"tool-approval-service",level:3},{value:"CI/CD Security Pipeline",id:"cicd-security-pipeline",level:2},{value:"CI/CD Security Configuration",id:"cicd-security-configuration",level:3},{value:"Compliance &amp; Auditing",id:"compliance--auditing",level:2},{value:"Compliance Monitoring Service",id:"compliance-monitoring-service",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"secure-sdlc-implementation-guide",children:"Secure SDLC Implementation Guide"})}),"\n",(0,r.jsx)(n.p,{children:"This guide provides comprehensive Secure Software Development Life Cycle (SDLC) implementation for NestJS/Next.js applications on GCP Kubernetes, covering access controls, approval processes, and development security practices."}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#production-access-controls",children:"Production Access Controls"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#access-approval-process",children:"Access Approval Process"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#environment-isolation",children:"Environment Isolation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#development-tools-security",children:"Development Tools Security"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#cicd-security-pipeline",children:"CI/CD Security Pipeline"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#compliance--auditing",children:"Compliance & Auditing"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"production-access-controls",children:"Production Access Controls"}),"\n",(0,r.jsx)(n.h3,{id:"gcp-access-control-implementation",children:"GCP Access Control Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/access-control/production-access.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\ninterface AccessRequest {\n  id: string;\n  requesterId: string;\n  requesterName: string;\n  resource: string;\n  accessType: 'READ' | 'WRITE' | 'ADMIN';\n  justification: string;\n  duration: number; // minutes\n  status: 'PENDING' | 'APPROVED' | 'DENIED' | 'EXPIRED';\n  approver?: string;\n  approvedAt?: Date;\n  expiresAt?: Date;\n  createdAt: Date;\n}\n\ninterface AccessPolicy {\n  resource: string;\n  requiredApprovers: number;\n  maxDuration: number; // minutes\n  allowedRoles: string[];\n  emergencyAccess: boolean;\n  auditRequired: boolean;\n}\n\n@Injectable()\nexport class ProductionAccessService {\n  private readonly logger = new Logger(ProductionAccessService.name);\n  private readonly accessRequests = new Map<string, AccessRequest>();\n  private readonly accessPolicies = new Map<string, AccessPolicy>();\n\n  constructor(private configService: ConfigService) {\n    this.initializeAccessPolicies();\n  }\n\n  async requestAccess(\n    requesterId: string,\n    resource: string,\n    accessType: 'READ' | 'WRITE' | 'ADMIN',\n    justification: string,\n    duration: number\n  ): Promise<string> {\n    const policy = this.accessPolicies.get(resource);\n    if (!policy) {\n      throw new Error(`No access policy defined for resource: ${resource}`);\n    }\n\n    if (duration > policy.maxDuration) {\n      throw new Error(`Requested duration exceeds maximum allowed: ${policy.maxDuration} minutes`);\n    }\n\n    const requestId = this.generateRequestId();\n    const request: AccessRequest = {\n      id: requestId,\n      requesterId,\n      requesterName: await this.getUserName(requesterId),\n      resource,\n      accessType,\n      justification,\n      duration,\n      status: 'PENDING',\n      createdAt: new Date(),\n    };\n\n    this.accessRequests.set(requestId, request);\n\n    // Send for approval\n    await this.sendForApproval(request);\n\n    this.logger.log(`Access request created: ${requestId} for resource: ${resource}`);\n    return requestId;\n  }\n\n  async approveAccess(requestId: string, approverId: string): Promise<void> {\n    const request = this.accessRequests.get(requestId);\n    if (!request) {\n      throw new Error(`Access request not found: ${requestId}`);\n    }\n\n    if (request.status !== 'PENDING') {\n      throw new Error(`Request ${requestId} is not in pending status`);\n    }\n\n    // Verify approver has permission\n    if (!await this.isAuthorizedApprover(approverId, request.resource)) {\n      throw new Error(`User ${approverId} is not authorized to approve access to ${request.resource}`);\n    }\n\n    request.status = 'APPROVED';\n    request.approver = approverId;\n    request.approvedAt = new Date();\n    request.expiresAt = new Date(Date.now() + request.duration * 60 * 1000);\n\n    // Grant actual access\n    await this.grantAccess(request);\n\n    // Schedule automatic revocation\n    this.scheduleAccessRevocation(requestId, request.expiresAt);\n\n    this.logger.log(`Access approved: ${requestId} by ${approverId}`);\n  }\n\n  async denyAccess(requestId: string, approverId: string, reason: string): Promise<void> {\n    const request = this.accessRequests.get(requestId);\n    if (!request) {\n      throw new Error(`Access request not found: ${requestId}`);\n    }\n\n    request.status = 'DENIED';\n    request.approver = approverId;\n\n    await this.notifyRequester(request, `Access denied: ${reason}`);\n\n    this.logger.log(`Access denied: ${requestId} by ${approverId}, reason: ${reason}`);\n  }\n\n  async revokeAccess(requestId: string, reason: string = 'Manual revocation'): Promise<void> {\n    const request = this.accessRequests.get(requestId);\n    if (!request || request.status !== 'APPROVED') {\n      return;\n    }\n\n    request.status = 'EXPIRED';\n\n    // Remove actual access\n    await this.removeAccess(request);\n\n    this.logger.log(`Access revoked: ${requestId}, reason: ${reason}`);\n  }\n\n  async requestEmergencyAccess(\n    requesterId: string,\n    resource: string,\n    justification: string,\n    incidentId?: string\n  ): Promise<string> {\n    const policy = this.accessPolicies.get(resource);\n    if (!policy || !policy.emergencyAccess) {\n      throw new Error(`Emergency access not allowed for resource: ${resource}`);\n    }\n\n    const requestId = this.generateRequestId();\n    const request: AccessRequest = {\n      id: requestId,\n      requesterId,\n      requesterName: await this.getUserName(requesterId),\n      resource,\n      accessType: 'ADMIN',\n      justification: `EMERGENCY: ${justification}${incidentId ? ` (Incident: ${incidentId})` : ''}`,\n      duration: 60, // 1 hour emergency access\n      status: 'APPROVED', // Auto-approved for emergencies\n      approver: 'emergency-system',\n      approvedAt: new Date(),\n      expiresAt: new Date(Date.now() + 60 * 60 * 1000),\n      createdAt: new Date(),\n    };\n\n    this.accessRequests.set(requestId, request);\n\n    // Grant immediate access\n    await this.grantAccess(request);\n\n    // Schedule automatic revocation\n    this.scheduleAccessRevocation(requestId, request.expiresAt);\n\n    // Alert security team\n    await this.alertEmergencyAccess(request);\n\n    this.logger.error(`Emergency access granted: ${requestId} for resource: ${resource}`);\n    return requestId;\n  }\n\n  private async grantAccess(request: AccessRequest): Promise<void> {\n    // Implementation depends on the resource type\n    switch (request.resource) {\n      case 'production-gke':\n        await this.grantGKEAccess(request);\n        break;\n      case 'production-database':\n        await this.grantDatabaseAccess(request);\n        break;\n      case 'production-logs':\n        await this.grantLogsAccess(request);\n        break;\n      default:\n        throw new Error(`Unknown resource type: ${request.resource}`);\n    }\n  }\n\n  private async grantGKEAccess(request: AccessRequest): Promise<void> {\n    // Grant temporary RBAC access to GKE cluster\n    const roleBinding = {\n      apiVersion: 'rbac.authorization.k8s.io/v1',\n      kind: 'RoleBinding',\n      metadata: {\n        name: `temp-access-${request.id}`,\n        namespace: 'production',\n        labels: {\n          'access-request-id': request.id,\n          'temporary-access': 'true',\n        },\n      },\n      subjects: [{\n        kind: 'User',\n        name: request.requesterId,\n        apiGroup: 'rbac.authorization.k8s.io',\n      }],\n      roleRef: {\n        kind: 'ClusterRole',\n        name: this.getGKERoleForAccessType(request.accessType),\n        apiGroup: 'rbac.authorization.k8s.io',\n      },\n    };\n\n    // Apply role binding using Kubernetes API\n    // Implementation would use @kubernetes/client-node\n    this.logger.log(`Granted GKE access to ${request.requesterId}`);\n  }\n\n  private async grantDatabaseAccess(request: AccessRequest): Promise<void> {\n    // Grant temporary database access through Cloud SQL IAM\n    // Implementation would use Google Cloud SQL Admin API\n    this.logger.log(`Granted database access to ${request.requesterId}`);\n  }\n\n  private async grantLogsAccess(request: AccessRequest): Promise<void> {\n    // Grant temporary access to production logs\n    // Implementation would use Cloud Logging API\n    this.logger.log(`Granted logs access to ${request.requesterId}`);\n  }\n\n  private async removeAccess(request: AccessRequest): Promise<void> {\n    // Remove the granted access\n    switch (request.resource) {\n      case 'production-gke':\n        await this.removeGKEAccess(request);\n        break;\n      case 'production-database':\n        await this.removeDatabaseAccess(request);\n        break;\n      case 'production-logs':\n        await this.removeLogsAccess(request);\n        break;\n    }\n  }\n\n  private async removeGKEAccess(request: AccessRequest): Promise<void> {\n    // Remove the temporary role binding\n    // Implementation would delete the RoleBinding created in grantGKEAccess\n    this.logger.log(`Removed GKE access for ${request.requesterId}`);\n  }\n\n  private async removeDatabaseAccess(request: AccessRequest): Promise<void> {\n    // Remove database access\n    this.logger.log(`Removed database access for ${request.requesterId}`);\n  }\n\n  private async removeLogsAccess(request: AccessRequest): Promise<void> {\n    // Remove logs access\n    this.logger.log(`Removed logs access for ${request.requesterId}`);\n  }\n\n  private scheduleAccessRevocation(requestId: string, expiresAt: Date): void {\n    const timeUntilExpiry = expiresAt.getTime() - Date.now();\n    \n    setTimeout(async () => {\n      await this.revokeAccess(requestId, 'Automatic expiration');\n    }, timeUntilExpiry);\n  }\n\n  private async sendForApproval(request: AccessRequest): Promise<void> {\n    // Send notification to approvers\n    // Implementation would integrate with Slack, email, or ticketing system\n    this.logger.log(`Sent access request ${request.id} for approval`);\n  }\n\n  private async isAuthorizedApprover(approverId: string, resource: string): Promise<boolean> {\n    // Check if user is authorized to approve access to the resource\n    // Implementation would check against IAM roles or approval groups\n    return true; // Placeholder\n  }\n\n  private async notifyRequester(request: AccessRequest, message: string): Promise<void> {\n    // Notify the requester about the decision\n    this.logger.log(`Notifying ${request.requesterId}: ${message}`);\n  }\n\n  private async alertEmergencyAccess(request: AccessRequest): Promise<void> {\n    // Alert security team about emergency access\n    this.logger.error(`EMERGENCY ACCESS ALERT: ${JSON.stringify(request)}`);\n  }\n\n  private async getUserName(userId: string): Promise<string> {\n    // Get user name from identity provider\n    return 'User Name'; // Placeholder\n  }\n\n  private getGKERoleForAccessType(accessType: string): string {\n    switch (accessType) {\n      case 'READ':\n        return 'view';\n      case 'WRITE':\n        return 'edit';\n      case 'ADMIN':\n        return 'admin';\n      default:\n        return 'view';\n    }\n  }\n\n  private generateRequestId(): string {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2, 8);\n    return `REQ-${timestamp}-${random}`.toUpperCase();\n  }\n\n  private initializeAccessPolicies(): void {\n    this.accessPolicies.set('production-gke', {\n      resource: 'production-gke',\n      requiredApprovers: 1,\n      maxDuration: 240, // 4 hours\n      allowedRoles: ['security-lead', 'devops-lead'],\n      emergencyAccess: true,\n      auditRequired: true,\n    });\n\n    this.accessPolicies.set('production-database', {\n      resource: 'production-database',\n      requiredApprovers: 2,\n      maxDuration: 120, // 2 hours\n      allowedRoles: ['security-lead', 'dba-lead'],\n      emergencyAccess: false,\n      auditRequired: true,\n    });\n\n    this.accessPolicies.set('production-logs', {\n      resource: 'production-logs',\n      requiredApprovers: 1,\n      maxDuration: 60, // 1 hour\n      allowedRoles: ['security-lead', 'sre-lead'],\n      emergencyAccess: true,\n      auditRequired: true,\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"access-approval-process",children:"Access Approval Process"}),"\n",(0,r.jsx)(n.h3,{id:"approval-workflow-implementation",children:"Approval Workflow Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/workflow/approval-workflow.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\ninterface ApprovalWorkflow {\n  id: string;\n  name: string;\n  description: string;\n  steps: ApprovalStep[];\n  requiredApprovals: number;\n  escalationPolicy: EscalationPolicy;\n  notifications: NotificationConfig[];\n}\n\ninterface ApprovalStep {\n  id: string;\n  name: string;\n  approverGroups: string[];\n  timeoutMinutes: number;\n  parallel: boolean;\n  required: boolean;\n}\n\ninterface EscalationPolicy {\n  timeoutMinutes: number;\n  escalationLevels: EscalationLevel[];\n}\n\ninterface EscalationLevel {\n  level: number;\n  approverGroups: string[];\n  timeoutMinutes: number;\n}\n\ninterface NotificationConfig {\n  trigger: 'REQUEST_CREATED' | 'APPROVAL_NEEDED' | 'APPROVED' | 'DENIED' | 'ESCALATED';\n  recipients: string[];\n  channels: ('EMAIL' | 'SLACK' | 'SMS')[];\n  template: string;\n}\n\n@Injectable()\nexport class ApprovalWorkflowService {\n  private readonly logger = new Logger(ApprovalWorkflowService.name);\n  private readonly workflows = new Map<string, ApprovalWorkflow>();\n\n  constructor() {\n    this.initializeWorkflows();\n  }\n\n  async initiateApproval(\n    workflowId: string,\n    requestData: any,\n    requesterId: string\n  ): Promise<string> {\n    const workflow = this.workflows.get(workflowId);\n    if (!workflow) {\n      throw new Error(`Workflow not found: ${workflowId}`);\n    }\n\n    const approvalInstanceId = this.generateApprovalId();\n    \n    // Create approval instance\n    const approvalInstance = {\n      id: approvalInstanceId,\n      workflowId,\n      requestData,\n      requesterId,\n      status: 'PENDING',\n      currentStep: 0,\n      createdAt: new Date(),\n      approvals: [],\n    };\n\n    // Send notifications for request creation\n    await this.sendNotifications('REQUEST_CREATED', workflow, approvalInstance);\n\n    // Start first approval step\n    await this.startApprovalStep(approvalInstance, workflow.steps[0]);\n\n    this.logger.log(`Approval workflow initiated: ${approvalInstanceId}`);\n    return approvalInstanceId;\n  }\n\n  async processApproval(\n    approvalInstanceId: string,\n    approverId: string,\n    decision: 'APPROVE' | 'DENY',\n    comments?: string\n  ): Promise<void> {\n    // Implementation for processing individual approvals\n    this.logger.log(`Processing approval: ${approvalInstanceId} by ${approverId}: ${decision}`);\n  }\n\n  private async startApprovalStep(approvalInstance: any, step: ApprovalStep): Promise<void> {\n    // Send approval requests to designated approvers\n    for (const approverGroup of step.approverGroups) {\n      await this.sendApprovalRequest(approvalInstance, approverGroup, step);\n    }\n\n    // Set timeout for this step\n    setTimeout(() => {\n      this.handleStepTimeout(approvalInstance.id, step.id);\n    }, step.timeoutMinutes * 60 * 1000);\n  }\n\n  private async sendApprovalRequest(\n    approvalInstance: any,\n    approverGroup: string,\n    step: ApprovalStep\n  ): Promise<void> {\n    // Send approval request to the approver group\n    this.logger.log(`Sending approval request to group: ${approverGroup}`);\n  }\n\n  private async handleStepTimeout(approvalInstanceId: string, stepId: string): Promise<void> {\n    // Handle timeout and escalation\n    this.logger.warn(`Approval step timeout: ${approvalInstanceId}/${stepId}`);\n  }\n\n  private generateApprovalId(): string {\n    return `APPR-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`.toUpperCase();\n  }\n\n  private async sendNotifications(\n    trigger: string,\n    workflow: ApprovalWorkflow,\n    approvalInstance: any\n  ): Promise<void> {\n    const notifications = workflow.notifications.filter(n => n.trigger === trigger);\n    \n    for (const notification of notifications) {\n      for (const channel of notification.channels) {\n        await this.sendNotification(channel, notification.recipients, notification.template, approvalInstance);\n      }\n    }\n  }\n\n  private async sendNotification(\n    channel: string,\n    recipients: string[],\n    template: string,\n    data: any\n  ): Promise<void> {\n    switch (channel) {\n      case 'EMAIL':\n        await this.sendEmailNotification(recipients, template, data);\n        break;\n      case 'SLACK':\n        await this.sendSlackNotification(recipients, template, data);\n        break;\n      case 'SMS':\n        await this.sendSMSNotification(recipients, template, data);\n        break;\n    }\n  }\n\n  private async sendEmailNotification(recipients: string[], template: string, data: any): Promise<void> {\n    this.logger.log(`Sending email notification to: ${recipients.join(', ')}`);\n  }\n\n  private async sendSlackNotification(recipients: string[], template: string, data: any): Promise<void> {\n    this.logger.log(`Sending Slack notification to: ${recipients.join(', ')}`);\n  }\n\n  private async sendSMSNotification(recipients: string[], template: string, data: any): Promise<void> {\n    this.logger.log(`Sending SMS notification to: ${recipients.join(', ')}`);\n  }\n\n  private initializeWorkflows(): void {\n    // Production access approval workflow\n    this.workflows.set('production-access', {\n      id: 'production-access',\n      name: 'Production Access Approval',\n      description: 'Approval workflow for production environment access',\n      requiredApprovals: 1,\n      steps: [\n        {\n          id: 'security-review',\n          name: 'Security Team Review',\n          approverGroups: ['security-team'],\n          timeoutMinutes: 60,\n          parallel: false,\n          required: true,\n        },\n      ],\n      escalationPolicy: {\n        timeoutMinutes: 120,\n        escalationLevels: [\n          {\n            level: 1,\n            approverGroups: ['security-lead'],\n            timeoutMinutes: 60,\n          },\n          {\n            level: 2,\n            approverGroups: ['ciso'],\n            timeoutMinutes: 30,\n          },\n        ],\n      },\n      notifications: [\n        {\n          trigger: 'REQUEST_CREATED',\n          recipients: ['security-team@company.com'],\n          channels: ['EMAIL', 'SLACK'],\n          template: 'access-request-created',\n        },\n        {\n          trigger: 'ESCALATED',\n          recipients: ['security-lead@company.com'],\n          channels: ['EMAIL', 'SMS'],\n          template: 'access-request-escalated',\n        },\n      ],\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"environment-isolation",children:"Environment Isolation"}),"\n",(0,r.jsx)(n.h3,{id:"environment-security-configuration",children:"Environment Security Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# scripts/setup-environment-isolation.sh\n\nset -e\n\nPROJECT_ID=${1:-"your-project-id"}\nENV=${2:-"staging"}\n\necho "Setting up environment isolation for: $ENV"\n\n# Create environment-specific VPC\ngcloud compute networks create "$ENV-vpc" \\\n    --subnet-mode=custom \\\n    --bgp-routing-mode=regional\n\n# Create environment-specific subnets\ngcloud compute networks subnets create "$ENV-app-subnet" \\\n    --network="$ENV-vpc" \\\n    --range="10.$((100 + ENV_NUM)).0.0/16" \\\n    --region="us-central1" \\\n    --secondary-range="pods=10.$((200 + ENV_NUM)).0.0/16,services=10.$((210 + ENV_NUM)).0.0/16"\n\n# Create firewall rules for environment isolation\ngcloud compute firewall-rules create "$ENV-deny-external" \\\n    --network="$ENV-vpc" \\\n    --action=DENY \\\n    --rules=tcp,udp,icmp \\\n    --source-ranges=0.0.0.0/0 \\\n    --target-tags="$ENV-app" \\\n    --priority=1000\n\n# Allow internal communication within environment\ngcloud compute firewall-rules create "$ENV-allow-internal" \\\n    --network="$ENV-vpc" \\\n    --action=ALLOW \\\n    --rules=tcp,udp,icmp \\\n    --source-ranges="10.$((100 + ENV_NUM)).0.0/16" \\\n    --target-tags="$ENV-app" \\\n    --priority=500\n\n# Allow specific external access for staging/development\nif [ "$ENV" != "production" ]; then\n    # Allow VPN access for development environments\n    gcloud compute firewall-rules create "$ENV-allow-vpn" \\\n        --network="$ENV-vpc" \\\n        --action=ALLOW \\\n        --rules=tcp:443,tcp:80 \\\n        --source-ranges="10.0.0.0/8" \\\n        --target-tags="$ENV-app" \\\n        --priority=800\n        \n    # Configure Identity-Aware Proxy for staging access\n    gcloud compute firewall-rules create "$ENV-allow-iap" \\\n        --network="$ENV-vpc" \\\n        --action=ALLOW \\\n        --rules=tcp:443,tcp:80 \\\n        --source-ranges="130.211.0.0/22,35.191.0.0/16" \\\n        --target-tags="$ENV-app" \\\n        --priority=700\nfi\n\necho "Environment isolation setup completed for: $ENV"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"environment-access-control",children:"Environment Access Control"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/environment/environment-access.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class EnvironmentAccessService {\n  private readonly logger = new Logger(EnvironmentAccessService.name);\n\n  constructor(private configService: ConfigService) {}\n\n  async validateEnvironmentAccess(userId: string, environment: string): Promise<boolean> {\n    const userRoles = await this.getUserRoles(userId);\n    const environmentPolicy = this.getEnvironmentPolicy(environment);\n\n    // Production requires special approval\n    if (environment === 'production') {\n      return await this.validateProductionAccess(userId);\n    }\n\n    // Check if user has required roles for non-production environments\n    return environmentPolicy.allowedRoles.some(role => userRoles.includes(role));\n  }\n\n  async setupEnvironmentIsolation(environment: string): Promise<void> {\n    await this.configureNetworkIsolation(environment);\n    await this.configureAccessControls(environment);\n    await this.configureDNSIsolation(environment);\n    await this.configureSecretsIsolation(environment);\n  }\n\n  private async validateProductionAccess(userId: string): Promise<boolean> {\n    // Production access requires active approval\n    // This would check against the access approval service\n    return false; // Deny by default\n  }\n\n  private async configureNetworkIsolation(environment: string): Promise<void> {\n    // Configure network policies for environment isolation\n    this.logger.log(`Configuring network isolation for: ${environment}`);\n  }\n\n  private async configureAccessControls(environment: string): Promise<void> {\n    // Configure RBAC and access controls\n    this.logger.log(`Configuring access controls for: ${environment}`);\n  }\n\n  private async configureDNSIsolation(environment: string): Promise<void> {\n    // Configure DNS isolation\n    this.logger.log(`Configuring DNS isolation for: ${environment}`);\n  }\n\n  private async configureSecretsIsolation(environment: string): Promise<void> {\n    // Configure secrets isolation\n    this.logger.log(`Configuring secrets isolation for: ${environment}`);\n  }\n\n  private getEnvironmentPolicy(environment: string): any {\n    const policies = {\n      development: {\n        allowedRoles: ['developer', 'qa', 'devops'],\n        requiresApproval: false,\n        maxSessionDuration: 480, // 8 hours\n      },\n      staging: {\n        allowedRoles: ['developer', 'qa', 'devops', 'product-manager'],\n        requiresApproval: false,\n        maxSessionDuration: 240, // 4 hours\n      },\n      production: {\n        allowedRoles: ['devops-lead', 'security-engineer'],\n        requiresApproval: true,\n        maxSessionDuration: 60, // 1 hour\n      },\n    };\n\n    return policies[environment] || policies.development;\n  }\n\n  private async getUserRoles(userId: string): Promise<string[]> {\n    // Get user roles from identity provider\n    return ['developer']; // Placeholder\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"development-tools-security",children:"Development Tools Security"}),"\n",(0,r.jsx)(n.h3,{id:"tool-approval-service",children:"Tool Approval Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/tools/tool-approval.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\ninterface DevelopmentTool {\n  id: string;\n  name: string;\n  category: 'IDE' | 'LIBRARY' | 'CLOUD_SERVICE' | 'DESKTOP_APP' | 'BROWSER_EXTENSION';\n  vendor: string;\n  version: string;\n  approvalStatus: 'APPROVED' | 'PENDING' | 'DENIED' | 'CONDITIONAL';\n  securityRating: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  approvedBy: string;\n  approvedAt: Date;\n  conditions?: string[];\n  riskAssessment: RiskAssessment;\n}\n\ninterface RiskAssessment {\n  dataAccess: boolean;\n  networkAccess: boolean;\n  systemAccess: boolean;\n  credentialAccess: boolean;\n  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  mitigations: string[];\n}\n\n@Injectable()\nexport class ToolApprovalService {\n  private readonly logger = new Logger(ToolApprovalService.name);\n  private readonly approvedTools = new Map<string, DevelopmentTool>();\n\n  constructor() {\n    this.initializePreApprovedTools();\n  }\n\n  async requestToolApproval(\n    toolName: string,\n    category: string,\n    vendor: string,\n    version: string,\n    justification: string,\n    requesterId: string\n  ): Promise<string> {\n    const toolId = this.generateToolId(toolName, vendor, version);\n    \n    // Check if tool is already approved\n    if (this.approvedTools.has(toolId)) {\n      return toolId;\n    }\n\n    // Perform automated security assessment\n    const riskAssessment = await this.assessToolSecurity(toolName, vendor, category);\n\n    const tool: DevelopmentTool = {\n      id: toolId,\n      name: toolName,\n      category: category as any,\n      vendor,\n      version,\n      approvalStatus: riskAssessment.riskLevel === 'LOW' ? 'APPROVED' : 'PENDING',\n      securityRating: riskAssessment.riskLevel,\n      approvedBy: riskAssessment.riskLevel === 'LOW' ? 'auto-approval' : '',\n      approvedAt: riskAssessment.riskLevel === 'LOW' ? new Date() : null,\n      riskAssessment,\n    };\n\n    if (tool.approvalStatus === 'PENDING') {\n      await this.sendForManualReview(tool, justification, requesterId);\n    } else {\n      this.approvedTools.set(toolId, tool);\n    }\n\n    this.logger.log(`Tool approval request: ${toolId} - Status: ${tool.approvalStatus}`);\n    return toolId;\n  }\n\n  async isToolApproved(toolName: string, vendor: string, version: string): Promise<boolean> {\n    const toolId = this.generateToolId(toolName, vendor, version);\n    const tool = this.approvedTools.get(toolId);\n    return tool?.approvalStatus === 'APPROVED';\n  }\n\n  async getApprovedTools(): Promise<DevelopmentTool[]> {\n    return Array.from(this.approvedTools.values()).filter(\n      tool => tool.approvalStatus === 'APPROVED'\n    );\n  }\n\n  async monitorToolUsage(): Promise<void> {\n    // Monitor usage of development tools in the environment\n    await this.scanDevelopmentEnvironments();\n    await this.detectUnauthorizedTools();\n    await this.generateComplianceReport();\n  }\n\n  private async assessToolSecurity(\n    toolName: string,\n    vendor: string,\n    category: string\n  ): Promise<RiskAssessment> {\n    // Perform automated security assessment\n    const knownRisks = this.getKnownToolRisks(toolName, vendor);\n    const categoryRisks = this.getCategoryRisks(category);\n\n    return {\n      dataAccess: this.assessDataAccess(toolName, category),\n      networkAccess: this.assessNetworkAccess(toolName, category),\n      systemAccess: this.assessSystemAccess(toolName, category),\n      credentialAccess: this.assessCredentialAccess(toolName, category),\n      riskLevel: this.calculateOverallRisk(knownRisks, categoryRisks),\n      mitigations: this.suggestMitigations(toolName, category),\n    };\n  }\n\n  private async sendForManualReview(\n    tool: DevelopmentTool,\n    justification: string,\n    requesterId: string\n  ): Promise<void> {\n    // Send tool for manual security review\n    this.logger.log(`Sending tool for manual review: ${tool.name}`);\n  }\n\n  private async scanDevelopmentEnvironments(): Promise<void> {\n    // Scan development environments for installed tools\n    this.logger.log('Scanning development environments for tool usage');\n  }\n\n  private async detectUnauthorizedTools(): Promise<void> {\n    // Detect usage of unauthorized tools\n    this.logger.log('Detecting unauthorized tool usage');\n  }\n\n  private async generateComplianceReport(): Promise<void> {\n    // Generate compliance report for tool usage\n    this.logger.log('Generating tool compliance report');\n  }\n\n  private generateToolId(name: string, vendor: string, version: string): string {\n    return `${vendor}-${name}-${version}`.toLowerCase().replace(/[^a-z0-9-]/g, '-');\n  }\n\n  private getKnownToolRisks(toolName: string, vendor: string): string[] {\n    // Database of known tool risks\n    const riskDatabase = {\n      'npm': ['dependency-confusion', 'malicious-packages'],\n      'docker': ['container-escape', 'privilege-escalation'],\n      'vscode': ['extension-risks', 'workspace-trust'],\n    };\n\n    return riskDatabase[toolName.toLowerCase()] || [];\n  }\n\n  private getCategoryRisks(category: string): string[] {\n    const categoryRisks = {\n      'CLOUD_SERVICE': ['data-exfiltration', 'unauthorized-access'],\n      'BROWSER_EXTENSION': ['data-theft', 'session-hijacking'],\n      'DESKTOP_APP': ['system-access', 'file-access'],\n    };\n\n    return categoryRisks[category] || [];\n  }\n\n  private assessDataAccess(toolName: string, category: string): boolean {\n    // Assess if tool requires data access\n    const dataAccessCategories = ['IDE', 'CLOUD_SERVICE', 'DESKTOP_APP'];\n    return dataAccessCategories.includes(category);\n  }\n\n  private assessNetworkAccess(toolName: string, category: string): boolean {\n    // Assess if tool requires network access\n    const networkAccessCategories = ['CLOUD_SERVICE', 'BROWSER_EXTENSION'];\n    return networkAccessCategories.includes(category);\n  }\n\n  private assessSystemAccess(toolName: string, category: string): boolean {\n    // Assess if tool requires system-level access\n    return category === 'DESKTOP_APP';\n  }\n\n  private assessCredentialAccess(toolName: string, category: string): boolean {\n    // Assess if tool might access credentials\n    const credentialRiskTools = ['git', 'docker', 'kubectl'];\n    return credentialRiskTools.some(risk => toolName.toLowerCase().includes(risk));\n  }\n\n  private calculateOverallRisk(knownRisks: string[], categoryRisks: string[]): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {\n    const totalRisks = knownRisks.length + categoryRisks.length;\n    \n    if (totalRisks === 0) return 'LOW';\n    if (totalRisks <= 2) return 'MEDIUM';\n    if (totalRisks <= 4) return 'HIGH';\n    return 'CRITICAL';\n  }\n\n  private suggestMitigations(toolName: string, category: string): string[] {\n    const baseMitigations = [\n      'Regular security updates',\n      'Principle of least privilege',\n      'Network isolation',\n    ];\n\n    const categoryMitigations = {\n      'CLOUD_SERVICE': ['Data encryption', 'Access logging'],\n      'BROWSER_EXTENSION': ['Sandbox execution', 'Permission review'],\n      'DESKTOP_APP': ['Application sandboxing', 'File system isolation'],\n    };\n\n    return [...baseMitigations, ...(categoryMitigations[category] || [])];\n  }\n\n  private initializePreApprovedTools(): void {\n    // Initialize pre-approved development tools\n    const preApprovedTools = [\n      {\n        name: 'Visual Studio Code',\n        vendor: 'Microsoft',\n        version: 'latest',\n        category: 'IDE' as const,\n        securityRating: 'MEDIUM' as const,\n      },\n      {\n        name: 'Node.js',\n        vendor: 'Node.js Foundation',\n        version: '18.x',\n        category: 'LIBRARY' as const,\n        securityRating: 'LOW' as const,\n      },\n      // Add more pre-approved tools\n    ];\n\n    preApprovedTools.forEach(tool => {\n      const toolId = this.generateToolId(tool.name, tool.vendor, tool.version);\n      this.approvedTools.set(toolId, {\n        id: toolId,\n        ...tool,\n        approvalStatus: 'APPROVED',\n        approvedBy: 'security-team',\n        approvedAt: new Date(),\n        riskAssessment: {\n          dataAccess: false,\n          networkAccess: false,\n          systemAccess: false,\n          credentialAccess: false,\n          riskLevel: 'LOW',\n          mitigations: ['Regular updates', 'Official distribution'],\n        },\n      });\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"cicd-security-pipeline",children:"CI/CD Security Pipeline"}),"\n",(0,r.jsx)(n.h3,{id:"cicd-security-configuration",children:"CI/CD Security Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# .github/workflows/secure-cicd.yml\nname: Secure CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  security-checks:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      \n      # Code security scanning\n      - name: Run CodeQL Analysis\n        uses: github/codeql-action/init@v2\n        with:\n          languages: typescript, javascript\n      \n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n      \n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n      \n      # Dependency vulnerability scanning\n      - name: Run Snyk Security Scan\n        uses: snyk/actions/node@master\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n        with:\n          args: --severity-threshold=high\n      \n      # Secret scanning\n      - name: Run TruffleHog OSS\n        uses: trufflesecurity/trufflehog@main\n        with:\n          path: ./\n          base: main\n          head: HEAD\n      \n      # Container security scanning\n      - name: Build Docker image\n        run: docker build -t app:${{ github.sha }} .\n      \n      - name: Run Trivy vulnerability scanner\n        uses: aquasecurity/trivy-action@master\n        with:\n          image-ref: 'app:${{ github.sha }}'\n          format: 'sarif'\n          output: 'trivy-results.sarif'\n      \n      - name: Upload Trivy scan results\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: 'trivy-results.sarif'\n      \n      # SAST scanning\n      - name: SonarQube Scan\n        uses: sonarqube-quality-gate-action@master\n        env:\n          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}\n      \n      # Infrastructure as Code scanning\n      - name: Run Checkov\n        uses: bridgecrewio/checkov-action@master\n        with:\n          directory: .\n          framework: kubernetes,dockerfile\n      \n      # License compliance check\n      - name: License compliance check\n        run: |\n          npm install -g license-checker\n          license-checker --onlyAllow 'MIT;Apache-2.0;BSD-3-Clause;BSD-2-Clause;ISC'\n\n  deployment-security:\n    runs-on: ubuntu-latest\n    needs: security-checks\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      # Secure deployment process\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v1\n        with:\n          credentials_json: ${{ secrets.GCP_SA_KEY }}\n      \n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v1\n      \n      - name: Deploy with security validation\n        run: |\n          # Validate Kubernetes manifests\n          kubectl apply --dry-run=client -f k8s/\n          \n          # Deploy with security policies\n          kubectl apply -f k8s/security-policies/\n          kubectl apply -f k8s/\n          \n          # Verify security policies are active\n          kubectl get networkpolicies\n          kubectl get podsecuritypolicies\n"})}),"\n",(0,r.jsx)(n.h2,{id:"compliance--auditing",children:"Compliance & Auditing"}),"\n",(0,r.jsx)(n.h3,{id:"compliance-monitoring-service",children:"Compliance Monitoring Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/compliance/compliance-monitoring.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\n\ninterface ComplianceRule {\n  id: string;\n  category: 'ACCESS_CONTROL' | 'DATA_PROTECTION' | 'AUDIT_LOGGING' | 'ENVIRONMENT_ISOLATION';\n  description: string;\n  requirement: string;\n  checkFunction: string;\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  frequency: 'DAILY' | 'WEEKLY' | 'MONTHLY';\n}\n\ninterface ComplianceCheck {\n  ruleId: string;\n  status: 'PASS' | 'FAIL' | 'WARNING';\n  timestamp: Date;\n  details: string;\n  evidence?: string[];\n  remediation?: string;\n}\n\n@Injectable()\nexport class ComplianceMonitoringService {\n  private readonly logger = new Logger(ComplianceMonitoringService.name);\n  private readonly complianceRules = new Map<string, ComplianceRule>();\n  private readonly complianceHistory: ComplianceCheck[] = [];\n\n  constructor() {\n    this.initializeComplianceRules();\n  }\n\n  @Cron(CronExpression.EVERY_DAY_AT_2AM)\n  async runDailyComplianceChecks(): Promise<void> {\n    const dailyRules = Array.from(this.complianceRules.values())\n      .filter(rule => rule.frequency === 'DAILY');\n\n    for (const rule of dailyRules) {\n      await this.executeComplianceCheck(rule);\n    }\n\n    await this.generateComplianceReport('DAILY');\n  }\n\n  @Cron(CronExpression.EVERY_WEEK_ON_MONDAY_AT_6AM)\n  async runWeeklyComplianceChecks(): Promise<void> {\n    const weeklyRules = Array.from(this.complianceRules.values())\n      .filter(rule => rule.frequency === 'WEEKLY');\n\n    for (const rule of weeklyRules) {\n      await this.executeComplianceCheck(rule);\n    }\n\n    await this.generateComplianceReport('WEEKLY');\n  }\n\n  async executeComplianceCheck(rule: ComplianceRule): Promise<ComplianceCheck> {\n    this.logger.log(`Executing compliance check: ${rule.id}`);\n\n    try {\n      const result = await this.runComplianceCheck(rule);\n      this.complianceHistory.push(result);\n\n      if (result.status === 'FAIL' && rule.severity === 'CRITICAL') {\n        await this.alertComplianceFailure(rule, result);\n      }\n\n      return result;\n    } catch (error) {\n      const failedCheck: ComplianceCheck = {\n        ruleId: rule.id,\n        status: 'FAIL',\n        timestamp: new Date(),\n        details: `Check execution failed: ${error.message}`,\n        remediation: 'Fix the compliance check execution issue',\n      };\n\n      this.complianceHistory.push(failedCheck);\n      return failedCheck;\n    }\n  }\n\n  private async runComplianceCheck(rule: ComplianceRule): Promise<ComplianceCheck> {\n    switch (rule.checkFunction) {\n      case 'checkProductionAccess':\n        return await this.checkProductionAccess(rule);\n      case 'checkAccessApprovalProcess':\n        return await this.checkAccessApprovalProcess(rule);\n      case 'checkEnvironmentIsolation':\n        return await this.checkEnvironmentIsolation(rule);\n      case 'checkAuditLogging':\n        return await this.checkAuditLogging(rule);\n      case 'checkSecretsManagement':\n        return await this.checkSecretsManagement(rule);\n      default:\n        throw new Error(`Unknown compliance check function: ${rule.checkFunction}`);\n    }\n  }\n\n  private async checkProductionAccess(rule: ComplianceRule): Promise<ComplianceCheck> {\n    // Check that no developers have direct production access\n    const productionAccess = await this.getProductionAccessList();\n    const unauthorizedAccess = productionAccess.filter(access => \n      access.role === 'developer' && !access.approved\n    );\n\n    return {\n      ruleId: rule.id,\n      status: unauthorizedAccess.length === 0 ? 'PASS' : 'FAIL',\n      timestamp: new Date(),\n      details: unauthorizedAccess.length === 0 \n        ? 'No unauthorized production access detected'\n        : `Found ${unauthorizedAccess.length} unauthorized production access`,\n      evidence: unauthorizedAccess.map(access => access.userId),\n      remediation: 'Revoke unauthorized production access and ensure proper approval process',\n    };\n  }\n\n  private async checkAccessApprovalProcess(rule: ComplianceRule): Promise<ComplianceCheck> {\n    // Check that access approval process is being followed\n    const recentAccessRequests = await this.getRecentAccessRequests();\n    const unapprovedAccess = recentAccessRequests.filter(request => \n      !request.approved && request.granted\n    );\n\n    return {\n      ruleId: rule.id,\n      status: unapprovedAccess.length === 0 ? 'PASS' : 'FAIL',\n      timestamp: new Date(),\n      details: unapprovedAccess.length === 0\n        ? 'All access requests properly approved'\n        : `Found ${unapprovedAccess.length} grants without approval`,\n      evidence: unapprovedAccess.map(request => request.id),\n      remediation: 'Ensure all access grants go through approval process',\n    };\n  }\n\n  private async checkEnvironmentIsolation(rule: ComplianceRule): Promise<ComplianceCheck> {\n    // Check that environments are properly isolated\n    const crossEnvironmentAccess = await this.detectCrossEnvironmentAccess();\n\n    return {\n      ruleId: rule.id,\n      status: crossEnvironmentAccess.length === 0 ? 'PASS' : 'FAIL',\n      timestamp: new Date(),\n      details: crossEnvironmentAccess.length === 0\n        ? 'Environment isolation properly maintained'\n        : `Found ${crossEnvironmentAccess.length} cross-environment access violations`,\n      evidence: crossEnvironmentAccess.map(violation => violation.description),\n      remediation: 'Review and fix environment isolation configurations',\n    };\n  }\n\n  private async checkAuditLogging(rule: ComplianceRule): Promise<ComplianceCheck> {\n    // Check that audit logging is properly configured and working\n    const auditLogStatus = await this.verifyAuditLogging();\n\n    return {\n      ruleId: rule.id,\n      status: auditLogStatus.healthy ? 'PASS' : 'FAIL',\n      timestamp: new Date(),\n      details: auditLogStatus.healthy\n        ? 'Audit logging properly configured and functioning'\n        : `Audit logging issues detected: ${auditLogStatus.issues.join(', ')}`,\n      evidence: auditLogStatus.evidence,\n      remediation: 'Fix audit logging configuration and ensure proper retention',\n    };\n  }\n\n  private async checkSecretsManagement(rule: ComplianceRule): Promise<ComplianceCheck> {\n    // Check that secrets are properly managed\n    const secretsAudit = await this.auditSecretsManagement();\n\n    return {\n      ruleId: rule.id,\n      status: secretsAudit.compliant ? 'PASS' : 'FAIL',\n      timestamp: new Date(),\n      details: secretsAudit.compliant\n        ? 'Secrets properly managed in secure storage'\n        : `Secrets management issues: ${secretsAudit.issues.join(', ')}`,\n      evidence: secretsAudit.evidence,\n      remediation: 'Migrate secrets to secure storage and implement rotation',\n    };\n  }\n\n  private async generateComplianceReport(frequency: string): Promise<void> {\n    const recentChecks = this.complianceHistory.filter(check => \n      check.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000)\n    );\n\n    const report = {\n      frequency,\n      timestamp: new Date(),\n      totalChecks: recentChecks.length,\n      passed: recentChecks.filter(check => check.status === 'PASS').length,\n      failed: recentChecks.filter(check => check.status === 'FAIL').length,\n      warnings: recentChecks.filter(check => check.status === 'WARNING').length,\n      criticalFailures: recentChecks.filter(check => \n        check.status === 'FAIL' && this.complianceRules.get(check.ruleId)?.severity === 'CRITICAL'\n      ).length,\n      checks: recentChecks,\n    };\n\n    this.logger.log(`Compliance report generated: ${JSON.stringify(report)}`);\n    \n    // Send report to compliance team\n    await this.sendComplianceReport(report);\n  }\n\n  private async alertComplianceFailure(rule: ComplianceRule, check: ComplianceCheck): Promise<void> {\n    this.logger.error(`CRITICAL COMPLIANCE FAILURE: ${rule.id}`, check);\n    // Send immediate alert to compliance and security teams\n  }\n\n  private async sendComplianceReport(report: any): Promise<void> {\n    // Send compliance report to stakeholders\n    this.logger.log('Sending compliance report to stakeholders');\n  }\n\n  // Placeholder methods for actual compliance checks\n  private async getProductionAccessList(): Promise<any[]> { return []; }\n  private async getRecentAccessRequests(): Promise<any[]> { return []; }\n  private async detectCrossEnvironmentAccess(): Promise<any[]> { return []; }\n  private async verifyAuditLogging(): Promise<any> { return { healthy: true, issues: [], evidence: [] }; }\n  private async auditSecretsManagement(): Promise<any> { return { compliant: true, issues: [], evidence: [] }; }\n\n  private initializeComplianceRules(): void {\n    const rules: ComplianceRule[] = [\n      {\n        id: 'PROD_ACCESS_001',\n        category: 'ACCESS_CONTROL',\n        description: 'No direct developer access to production',\n        requirement: 'Developers must not have direct access to production environment',\n        checkFunction: 'checkProductionAccess',\n        severity: 'CRITICAL',\n        frequency: 'DAILY',\n      },\n      {\n        id: 'APPROVAL_001',\n        category: 'ACCESS_CONTROL',\n        description: 'Access approval process compliance',\n        requirement: 'All access must go through defined approval process',\n        checkFunction: 'checkAccessApprovalProcess',\n        severity: 'HIGH',\n        frequency: 'DAILY',\n      },\n      {\n        id: 'ISOLATION_001',\n        category: 'ENVIRONMENT_ISOLATION',\n        description: 'Environment isolation verification',\n        requirement: 'Environments must be properly isolated',\n        checkFunction: 'checkEnvironmentIsolation',\n        severity: 'HIGH',\n        frequency: 'WEEKLY',\n      },\n      {\n        id: 'AUDIT_001',\n        category: 'AUDIT_LOGGING',\n        description: 'Audit logging verification',\n        requirement: 'All access and activities must be logged',\n        checkFunction: 'checkAuditLogging',\n        severity: 'HIGH',\n        frequency: 'DAILY',\n      },\n      {\n        id: 'SECRETS_001',\n        category: 'DATA_PROTECTION',\n        description: 'Secrets management verification',\n        requirement: 'Secrets must be stored in secure storage',\n        checkFunction: 'checkSecretsManagement',\n        severity: 'CRITICAL',\n        frequency: 'WEEKLY',\n      },\n    ];\n\n    rules.forEach(rule => {\n      this.complianceRules.set(rule.id, rule);\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This comprehensive Secure SDLC implementation provides:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Production access controls"})," with approval workflows and emergency access procedures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Access approval process"})," with multi-step workflows and escalation policies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Environment isolation"})," with network security and access controls"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Development tools security"})," with approval processes and risk assessment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CI/CD security pipeline"})," with comprehensive security scanning and validation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compliance and auditing"})," with automated compliance checks and reporting"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The implementation ensures that the entire software development lifecycle follows security best practices and maintains compliance with organizational policies."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},5741:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var t=s(9729);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);