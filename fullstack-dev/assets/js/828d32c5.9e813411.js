"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[4346],{2572:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"security-practices/security-implementation/network-security","title":"Network Security Implementation Guide","description":"This guide provides comprehensive network security implementation for NestJS/Next.js applications on GCP Kubernetes, covering firewall configuration, network policies, and access controls.","source":"@site/docs/security-practices/security-implementation/network-security.md","sourceDirName":"security-practices/security-implementation","slug":"/security-practices/security-implementation/network-security","permalink":"/fullstack-dev/docs/security-practices/security-implementation/network-security","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/security-practices/security-implementation/network-security.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Security Compliance Automation Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/compliance-automation"},"next":{"title":"Session Management Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/session-management"}}');var o=t(5813),i=t(5741);const s={},a="Network Security Implementation Guide",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"GCP VPC and Firewall Setup",id:"gcp-vpc-and-firewall-setup",level:2},{value:"VPC Network Configuration",id:"vpc-network-configuration",level:3},{value:"Firewall Rules Configuration",id:"firewall-rules-configuration",level:3},{value:"Network Access Control Service",id:"network-access-control-service",level:3},{value:"Kubernetes Network Policies",id:"kubernetes-network-policies",level:2},{value:"Network Policy Configuration",id:"network-policy-configuration",level:3},{value:"Network Policy Manager",id:"network-policy-manager",level:3},{value:"Load Balancer Security",id:"load-balancer-security",level:2},{value:"Google Cloud Load Balancer Configuration",id:"google-cloud-load-balancer-configuration",level:3},{value:"Cloud Armor Security Policy",id:"cloud-armor-security-policy",level:3},{value:"Service Mesh Security",id:"service-mesh-security",level:2},{value:"Istio Security Configuration",id:"istio-security-configuration",level:3},{value:"Service Mesh Security Manager",id:"service-mesh-security-manager",level:3},{value:"WAF and DDoS Protection",id:"waf-and-ddos-protection",level:2},{value:"Rate Limiting Middleware",id:"rate-limiting-middleware",level:3},{value:"DDoS Protection Service",id:"ddos-protection-service",level:3},{value:"Network Monitoring",id:"network-monitoring",level:2},{value:"Network Monitoring Service",id:"network-monitoring-service",level:3}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"network-security-implementation-guide",children:"Network Security Implementation Guide"})}),"\n",(0,o.jsx)(n.p,{children:"This guide provides comprehensive network security implementation for NestJS/Next.js applications on GCP Kubernetes, covering firewall configuration, network policies, and access controls."}),"\n",(0,o.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#gcp-vpc-and-firewall-setup",children:"GCP VPC and Firewall Setup"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#kubernetes-network-policies",children:"Kubernetes Network Policies"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#load-balancer-security",children:"Load Balancer Security"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#service-mesh-security",children:"Service Mesh Security"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#waf-and-ddos-protection",children:"WAF and DDoS Protection"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#network-monitoring",children:"Network Monitoring"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"gcp-vpc-and-firewall-setup",children:"GCP VPC and Firewall Setup"}),"\n",(0,o.jsx)(n.h3,{id:"vpc-network-configuration",children:"VPC Network Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"#!/bin/bash\n# scripts/setup-vpc-network.sh\n\n# Create custom VPC\ngcloud compute networks create ecom-vpc \\\n    --subnet-mode=custom \\\n    --bgp-routing-mode=regional\n\n# Create private subnet for GKE cluster\ngcloud compute networks subnets create ecom-gke-subnet \\\n    --network=ecom-vpc \\\n    --range=10.1.0.0/16 \\\n    --region=us-central1 \\\n    --secondary-range=pods=10.2.0.0/16,services=10.3.0.0/16\n\n# Create subnet for database and internal services\ngcloud compute networks subnets create ecom-internal-subnet \\\n    --network=ecom-vpc \\\n    --range=10.4.0.0/16 \\\n    --region=us-central1\n\n# Create subnet for load balancers\ngcloud compute networks subnets create ecom-lb-subnet \\\n    --network=ecom-vpc \\\n    --range=10.5.0.0/24 \\\n    --region=us-central1\n"})}),"\n",(0,o.jsx)(n.h3,{id:"firewall-rules-configuration",children:"Firewall Rules Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// infrastructure/firewall-rules.ts\nimport { Firewall } from '@google-cloud/compute';\n\nexport class FirewallManager {\n  private firewall: Firewall;\n\n  constructor(projectId: string) {\n    this.firewall = new Firewall({ projectId });\n  }\n\n  async createSecurityFirewallRules(): Promise<void> {\n    const rules = [\n      {\n        name: 'ecom-deny-all-default',\n        direction: 'INGRESS',\n        action: 'DENY',\n        priority: 65534,\n        network: 'projects/PROJECT_ID/global/networks/ecom-vpc',\n        sourceRanges: ['0.0.0.0/0'],\n        targetTags: ['ecom-app'],\n      },\n      {\n        name: 'ecom-allow-https-from-lb',\n        direction: 'INGRESS',\n        action: 'ALLOW',\n        priority: 1000,\n        network: 'projects/PROJECT_ID/global/networks/ecom-vpc',\n        sourceRanges: ['10.5.0.0/24'], // Load balancer subnet\n        targetTags: ['ecom-app'],\n        allowed: [{ IPProtocol: 'tcp', ports: ['443', '80'] }],\n      },\n      {\n        name: 'ecom-allow-internal-communication',\n        direction: 'INGRESS',\n        action: 'ALLOW',\n        priority: 1000,\n        network: 'projects/PROJECT_ID/global/networks/ecom-vpc',\n        sourceRanges: ['10.1.0.0/16', '10.2.0.0/16'], // GKE subnets\n        targetTags: ['ecom-internal'],\n        allowed: [\n          { IPProtocol: 'tcp', ports: ['3000', '5432', '6379'] },\n          { IPProtocol: 'udp', ports: ['53'] },\n        ],\n      },\n      {\n        name: 'ecom-allow-health-checks',\n        direction: 'INGRESS',\n        action: 'ALLOW',\n        priority: 1000,\n        network: 'projects/PROJECT_ID/global/networks/ecom-vpc',\n        sourceRanges: ['130.211.0.0/22', '35.191.0.0/16'], // Google health check ranges\n        targetTags: ['ecom-app'],\n        allowed: [{ IPProtocol: 'tcp', ports: ['80', '443', '8080'] }],\n      },\n      {\n        name: 'ecom-deny-database-external',\n        direction: 'INGRESS',\n        action: 'DENY',\n        priority: 500,\n        network: 'projects/PROJECT_ID/global/networks/ecom-vpc',\n        sourceRanges: ['0.0.0.0/0'],\n        targetTags: ['database'],\n        denied: [{ IPProtocol: 'tcp', ports: ['5432', '3306', '6379'] }],\n      },\n    ];\n\n    for (const rule of rules) {\n      try {\n        await this.firewall.create(rule.name, rule);\n        console.log(`Created firewall rule: ${rule.name}`);\n      } catch (error) {\n        console.error(`Failed to create firewall rule ${rule.name}:`, error);\n      }\n    }\n  }\n\n  async createEgressRules(): Promise<void> {\n    const egressRules = [\n      {\n        name: 'ecom-allow-external-apis',\n        direction: 'EGRESS',\n        action: 'ALLOW',\n        priority: 1000,\n        network: 'projects/PROJECT_ID/global/networks/ecom-vpc',\n        destinationRanges: ['0.0.0.0/0'],\n        targetTags: ['ecom-app'],\n        allowed: [{ IPProtocol: 'tcp', ports: ['443', '80'] }],\n      },\n      {\n        name: 'ecom-allow-dns',\n        direction: 'EGRESS',\n        action: 'ALLOW',\n        priority: 1000,\n        network: 'projects/PROJECT_ID/global/networks/ecom-vpc',\n        destinationRanges: ['8.8.8.8/32', '8.8.4.4/32'],\n        targetTags: ['ecom-app'],\n        allowed: [{ IPProtocol: 'udp', ports: ['53'] }],\n      },\n      {\n        name: 'ecom-deny-internal-to-external-db',\n        direction: 'EGRESS',\n        action: 'DENY',\n        priority: 500,\n        network: 'projects/PROJECT_ID/global/networks/ecom-vpc',\n        destinationRanges: ['0.0.0.0/0'],\n        targetTags: ['ecom-app'],\n        denied: [{ IPProtocol: 'tcp', ports: ['5432', '3306', '6379'] }],\n      },\n    ];\n\n    for (const rule of egressRules) {\n      try {\n        await this.firewall.create(rule.name, rule);\n        console.log(`Created egress rule: ${rule.name}`);\n      } catch (error) {\n        console.error(`Failed to create egress rule ${rule.name}:`, error);\n      }\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"network-access-control-service",children:"Network Access Control Service"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/security/network-access-control.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\ninterface NetworkRule {\n  id: string;\n  source: string;\n  destination: string;\n  port: number;\n  protocol: 'TCP' | 'UDP';\n  action: 'ALLOW' | 'DENY';\n  priority: number;\n}\n\n@Injectable()\nexport class NetworkAccessControlService {\n  private readonly logger = new Logger(NetworkAccessControlService.name);\n  private readonly allowedNetworks: string[];\n  private readonly blockedIPs: Set<string> = new Set();\n\n  constructor(private configService: ConfigService) {\n    this.allowedNetworks = this.configService\n      .get<string>('ALLOWED_NETWORKS', '10.0.0.0/8,172.16.0.0/12,192.168.0.0/16')\n      .split(',');\n  }\n\n  isIPAllowed(ip: string): boolean {\n    if (this.blockedIPs.has(ip)) {\n      this.logger.warn(`Blocked IP attempted access: ${ip}`);\n      return false;\n    }\n\n    // Check if IP is in allowed networks\n    for (const network of this.allowedNetworks) {\n      if (this.isIPInNetwork(ip, network)) {\n        return true;\n      }\n    }\n\n    // For production, deny by default\n    if (this.configService.get('NODE_ENV') === 'production') {\n      this.logger.warn(`IP not in allowed networks: ${ip}`);\n      return false;\n    }\n\n    return true;\n  }\n\n  blockIP(ip: string, reason: string): void {\n    this.blockedIPs.add(ip);\n    this.logger.warn(`Blocked IP ${ip}: ${reason}`);\n  }\n\n  unblockIP(ip: string): void {\n    this.blockedIPs.delete(ip);\n    this.logger.log(`Unblocked IP: ${ip}`);\n  }\n\n  private isIPInNetwork(ip: string, network: string): boolean {\n    const [networkAddr, prefixLength] = network.split('/');\n    const networkInt = this.ipToInt(networkAddr);\n    const ipInt = this.ipToInt(ip);\n    const mask = (0xffffffff << (32 - parseInt(prefixLength))) >>> 0;\n    \n    return (networkInt & mask) === (ipInt & mask);\n  }\n\n  private ipToInt(ip: string): number {\n    return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0) >>> 0;\n  }\n\n  getNetworkRules(): NetworkRule[] {\n    return [\n      {\n        id: 'allow-https',\n        source: '0.0.0.0/0',\n        destination: 'app-pods',\n        port: 443,\n        protocol: 'TCP',\n        action: 'ALLOW',\n        priority: 1000,\n      },\n      {\n        id: 'allow-internal-db',\n        source: 'app-pods',\n        destination: 'database-pods',\n        port: 5432,\n        protocol: 'TCP',\n        action: 'ALLOW',\n        priority: 1000,\n      },\n      {\n        id: 'deny-external-db',\n        source: '0.0.0.0/0',\n        destination: 'database-pods',\n        port: 5432,\n        protocol: 'TCP',\n        action: 'DENY',\n        priority: 500,\n      },\n    ];\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"kubernetes-network-policies",children:"Kubernetes Network Policies"}),"\n",(0,o.jsx)(n.h3,{id:"network-policy-configuration",children:"Network Policy Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"# k8s/network-policies/app-network-policy.yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: ecom-app-network-policy\n  namespace: ecom\nspec:\n  podSelector:\n    matchLabels:\n      app: ecom-app\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  # Allow traffic from ingress controller\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: ingress-nginx\n    - podSelector:\n        matchLabels:\n          app.kubernetes.io/name: ingress-nginx\n    ports:\n    - protocol: TCP\n      port: 3000\n  # Allow traffic from monitoring\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: monitoring\n    ports:\n    - protocol: TCP\n      port: 9090 # Metrics port\n  egress:\n  # Allow DNS resolution\n  - to: []\n    ports:\n    - protocol: UDP\n      port: 53\n  # Allow access to database\n  - to:\n    - podSelector:\n        matchLabels:\n          app: postgres\n    ports:\n    - protocol: TCP\n      port: 5432\n  # Allow access to Redis\n  - to:\n    - podSelector:\n        matchLabels:\n          app: redis\n    ports:\n    - protocol: TCP\n      port: 6379\n  # Allow HTTPS external access\n  - to: []\n    ports:\n    - protocol: TCP\n      port: 443\n    - protocol: TCP\n      port: 80\n\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: ecom-database-network-policy\n  namespace: ecom\nspec:\n  podSelector:\n    matchLabels:\n      app: postgres\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  # Only allow traffic from app pods\n  - from:\n    - podSelector:\n        matchLabels:\n          app: ecom-app\n    ports:\n    - protocol: TCP\n      port: 5432\n  # Allow backup jobs\n  - from:\n    - podSelector:\n        matchLabels:\n          job: backup\n    ports:\n    - protocol: TCP\n      port: 5432\n  egress:\n  # Allow DNS\n  - to: []\n    ports:\n    - protocol: UDP\n      port: 53\n  # Deny all other egress\n  - to: []\n    ports: []\n\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny-all\n  namespace: ecom\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  - Egress\n"})}),"\n",(0,o.jsx)(n.h3,{id:"network-policy-manager",children:"Network Policy Manager"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/kubernetes/network-policy-manager.ts\nimport * as k8s from '@kubernetes/client-node';\nimport { Injectable, Logger } from '@nestjs/common';\n\ninterface NetworkPolicySpec {\n  name: string;\n  namespace: string;\n  podSelector: Record<string, string>;\n  ingress?: IngressRule[];\n  egress?: EgressRule[];\n}\n\ninterface IngressRule {\n  from?: Array<{\n    podSelector?: Record<string, string>;\n    namespaceSelector?: Record<string, string>;\n  }>;\n  ports?: Array<{\n    protocol: string;\n    port: number;\n  }>;\n}\n\ninterface EgressRule {\n  to?: Array<{\n    podSelector?: Record<string, string>;\n    namespaceSelector?: Record<string, string>;\n  }>;\n  ports?: Array<{\n    protocol: string;\n    port: number;\n  }>;\n}\n\n@Injectable()\nexport class NetworkPolicyManager {\n  private readonly logger = new Logger(NetworkPolicyManager.name);\n  private readonly k8sApi: k8s.NetworkingV1Api;\n\n  constructor() {\n    const kc = new k8s.KubeConfig();\n    kc.loadFromDefault();\n    this.k8sApi = kc.makeApiClient(k8s.NetworkingV1Api);\n  }\n\n  async createNetworkPolicy(spec: NetworkPolicySpec): Promise<void> {\n    const networkPolicy: k8s.V1NetworkPolicy = {\n      apiVersion: 'networking.k8s.io/v1',\n      kind: 'NetworkPolicy',\n      metadata: {\n        name: spec.name,\n        namespace: spec.namespace,\n      },\n      spec: {\n        podSelector: {\n          matchLabels: spec.podSelector,\n        },\n        policyTypes: [],\n        ingress: spec.ingress,\n        egress: spec.egress,\n      },\n    };\n\n    if (spec.ingress) {\n      networkPolicy.spec!.policyTypes!.push('Ingress');\n    }\n    if (spec.egress) {\n      networkPolicy.spec!.policyTypes!.push('Egress');\n    }\n\n    try {\n      await this.k8sApi.createNamespacedNetworkPolicy(\n        spec.namespace,\n        networkPolicy\n      );\n      this.logger.log(`Created network policy: ${spec.name}`);\n    } catch (error) {\n      this.logger.error(`Failed to create network policy ${spec.name}:`, error);\n      throw error;\n    }\n  }\n\n  async createDefaultSecurityPolicies(): Promise<void> {\n    const policies: NetworkPolicySpec[] = [\n      {\n        name: 'ecom-app-isolation',\n        namespace: 'ecom',\n        podSelector: { app: 'ecom-app' },\n        ingress: [\n          {\n            from: [{ namespaceSelector: { name: 'ingress-nginx' } }],\n            ports: [{ protocol: 'TCP', port: 3000 }],\n          },\n        ],\n        egress: [\n          {\n            ports: [{ protocol: 'UDP', port: 53 }], // DNS\n          },\n          {\n            to: [{ podSelector: { app: 'postgres' } }],\n            ports: [{ protocol: 'TCP', port: 5432 }],\n          },\n          {\n            to: [{ podSelector: { app: 'redis' } }],\n            ports: [{ protocol: 'TCP', port: 6379 }],\n          },\n        ],\n      },\n      {\n        name: 'database-isolation',\n        namespace: 'ecom',\n        podSelector: { app: 'postgres' },\n        ingress: [\n          {\n            from: [{ podSelector: { app: 'ecom-app' } }],\n            ports: [{ protocol: 'TCP', port: 5432 }],\n          },\n        ],\n        egress: [\n          {\n            ports: [{ protocol: 'UDP', port: 53 }], // DNS only\n          },\n        ],\n      },\n    ];\n\n    for (const policy of policies) {\n      await this.createNetworkPolicy(policy);\n    }\n  }\n\n  async validateNetworkPolicies(): Promise<boolean> {\n    try {\n      const { body } = await this.k8sApi.listNamespacedNetworkPolicy('ecom');\n      const policies = body.items;\n\n      const requiredPolicies = ['ecom-app-isolation', 'database-isolation'];\n      const existingPolicies = policies.map(p => p.metadata?.name || '');\n\n      const missingPolicies = requiredPolicies.filter(\n        policy => !existingPolicies.includes(policy)\n      );\n\n      if (missingPolicies.length > 0) {\n        this.logger.warn(`Missing network policies: ${missingPolicies.join(', ')}`);\n        return false;\n      }\n\n      this.logger.log('All required network policies are in place');\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to validate network policies:', error);\n      return false;\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"load-balancer-security",children:"Load Balancer Security"}),"\n",(0,o.jsx)(n.h3,{id:"google-cloud-load-balancer-configuration",children:"Google Cloud Load Balancer Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'# k8s/ingress/secure-ingress.yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ecom-secure-ingress\n  namespace: ecom\n  annotations:\n    kubernetes.io/ingress.class: "gce"\n    kubernetes.io/ingress.global-static-ip-name: "ecom-ip"\n    networking.gke.io/managed-certificates: "ecom-ssl-cert"\n    kubernetes.io/ingress.allow-http: "false"\n    ingress.gcp.kubernetes.io/load-balancer-type: "External"\n    cloud.google.com/armor-config: \'{"ecom-security-policy": "ecom-armor-policy"}\'\nspec:\n  rules:\n  - host: api.ecom.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: ecom-app-service\n            port:\n              number: 80\n  - host: www.ecom.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: ecom-frontend-service\n            port:\n              number: 80\n\n---\napiVersion: networking.gke.io/v1\nkind: ManagedCertificate\nmetadata:\n  name: ecom-ssl-cert\n  namespace: ecom\nspec:\n  domains:\n    - api.ecom.example.com\n    - www.ecom.example.com\n'})}),"\n",(0,o.jsx)(n.h3,{id:"cloud-armor-security-policy",children:"Cloud Armor Security Policy"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"#!/bin/bash\n# scripts/setup-cloud-armor.sh\n\n# Create Cloud Armor security policy\ngcloud compute security-policies create ecom-armor-policy \\\n    --description \"Security policy for ecom application\"\n\n# Rate limiting rule\ngcloud compute security-policies rules create 1000 \\\n    --security-policy ecom-armor-policy \\\n    --expression \"true\" \\\n    --action \"rate-based-ban\" \\\n    --rate-limit-threshold-count 100 \\\n    --rate-limit-threshold-interval-sec 60 \\\n    --ban-duration-sec 600 \\\n    --conform-action allow \\\n    --exceed-action deny-429 \\\n    --enforce-on-key IP\n\n# Block malicious countries (example)\ngcloud compute security-policies rules create 2000 \\\n    --security-policy ecom-armor-policy \\\n    --expression \"origin.region_code == 'CN' || origin.region_code == 'RU'\" \\\n    --action deny-403\n\n# Block SQL injection attempts\ngcloud compute security-policies rules create 3000 \\\n    --security-policy ecom-armor-policy \\\n    --expression \"has(request.headers['user-agent']) && request.headers['user-agent'].contains('sqlmap')\" \\\n    --action deny-403\n\n# Block XSS attempts\ngcloud compute security-policies rules create 4000 \\\n    --security-policy ecom-armor-policy \\\n    --expression \"request.url_map.contains('<script>') || request.headers['referer'].contains('<script>')\" \\\n    --action deny-403\n\n# Allow Google Cloud health checks\ngcloud compute security-policies rules create 100 \\\n    --security-policy ecom-armor-policy \\\n    --src-ip-ranges 130.211.0.0/22,35.191.0.0/16 \\\n    --action allow\n\n# Default deny rule (optional, as default is allow)\ngcloud compute security-policies rules create 2147483647 \\\n    --security-policy ecom-armor-policy \\\n    --expression \"true\" \\\n    --action allow\n"})}),"\n",(0,o.jsx)(n.h2,{id:"service-mesh-security",children:"Service Mesh Security"}),"\n",(0,o.jsx)(n.h3,{id:"istio-security-configuration",children:"Istio Security Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'# istio/security/peer-authentication.yaml\napiVersion: security.istio.io/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: default\n  namespace: ecom\nspec:\n  mtls:\n    mode: STRICT\n\n---\napiVersion: security.istio.io/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: ecom-app-authz\n  namespace: ecom\nspec:\n  selector:\n    matchLabels:\n      app: ecom-app\n  rules:\n  - from:\n    - source:\n        principals: ["cluster.local/ns/ingress-nginx/sa/ingress-nginx"]\n  - to:\n    - operation:\n        methods: ["GET", "POST", "PUT", "DELETE"]\n        paths: ["/api/*"]\n  - when:\n    - key: request.headers[authorization]\n      values: ["Bearer *"]\n\n---\napiVersion: security.istio.io/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: database-access-policy\n  namespace: ecom\nspec:\n  selector:\n    matchLabels:\n      app: postgres\n  rules:\n  - from:\n    - source:\n        principals: ["cluster.local/ns/ecom/sa/ecom-app"]\n  - to:\n    - operation:\n        ports: ["5432"]\n'})}),"\n",(0,o.jsx)(n.h3,{id:"service-mesh-security-manager",children:"Service Mesh Security Manager"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/istio/security-manager.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport * as k8s from '@kubernetes/client-node';\n\n@Injectable()\nexport class ServiceMeshSecurityManager {\n  private readonly logger = new Logger(ServiceMeshSecurityManager.name);\n  private readonly k8sApi: k8s.CustomObjectsApi;\n\n  constructor() {\n    const kc = new k8s.KubeConfig();\n    kc.loadFromDefault();\n    this.k8sApi = kc.makeApiClient(k8s.CustomObjectsApi);\n  }\n\n  async enableMTLS(namespace: string): Promise<void> {\n    const peerAuthentication = {\n      apiVersion: 'security.istio.io/v1beta1',\n      kind: 'PeerAuthentication',\n      metadata: {\n        name: 'default',\n        namespace,\n      },\n      spec: {\n        mtls: {\n          mode: 'STRICT',\n        },\n      },\n    };\n\n    try {\n      await this.k8sApi.createNamespacedCustomObject(\n        'security.istio.io',\n        'v1beta1',\n        namespace,\n        'peerauthentications',\n        peerAuthentication\n      );\n      this.logger.log(`Enabled strict mTLS for namespace: ${namespace}`);\n    } catch (error) {\n      this.logger.error(`Failed to enable mTLS for ${namespace}:`, error);\n      throw error;\n    }\n  }\n\n  async createAuthorizationPolicy(\n    name: string,\n    namespace: string,\n    spec: any\n  ): Promise<void> {\n    const authzPolicy = {\n      apiVersion: 'security.istio.io/v1beta1',\n      kind: 'AuthorizationPolicy',\n      metadata: { name, namespace },\n      spec,\n    };\n\n    try {\n      await this.k8sApi.createNamespacedCustomObject(\n        'security.istio.io',\n        'v1beta1',\n        namespace,\n        'authorizationpolicies',\n        authzPolicy\n      );\n      this.logger.log(`Created authorization policy: ${name}`);\n    } catch (error) {\n      this.logger.error(`Failed to create authorization policy ${name}:`, error);\n      throw error;\n    }\n  }\n\n  async validateSecurityPolicies(namespace: string): Promise<boolean> {\n    try {\n      // Check PeerAuthentication\n      const peerAuthList = await this.k8sApi.listNamespacedCustomObject(\n        'security.istio.io',\n        'v1beta1',\n        namespace,\n        'peerauthentications'\n      );\n\n      // Check AuthorizationPolicies\n      const authzList = await this.k8sApi.listNamespacedCustomObject(\n        'security.istio.io',\n        'v1beta1',\n        namespace,\n        'authorizationpolicies'\n      );\n\n      const hasStrictMTLS = (peerAuthList.body as any).items.some(\n        (item: any) => item.spec?.mtls?.mode === 'STRICT'\n      );\n\n      const hasAuthzPolicies = (authzList.body as any).items.length > 0;\n\n      if (!hasStrictMTLS) {\n        this.logger.warn(`No strict mTLS policy found in namespace: ${namespace}`);\n        return false;\n      }\n\n      if (!hasAuthzPolicies) {\n        this.logger.warn(`No authorization policies found in namespace: ${namespace}`);\n        return false;\n      }\n\n      this.logger.log(`Security policies validated for namespace: ${namespace}`);\n      return true;\n    } catch (error) {\n      this.logger.error(`Failed to validate security policies:`, error);\n      return false;\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"waf-and-ddos-protection",children:"WAF and DDoS Protection"}),"\n",(0,o.jsx)(n.h3,{id:"rate-limiting-middleware",children:"Rate Limiting Middleware"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/middleware/rate-limiting.middleware.ts\nimport { Injectable, NestMiddleware, HttpException, HttpStatus } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport { ConfigService } from '@nestjs/config';\nimport { Redis } from 'ioredis';\n\ninterface RateLimitConfig {\n  windowMs: number;\n  maxRequests: number;\n  keyGenerator: (req: Request) => string;\n}\n\n@Injectable()\nexport class RateLimitingMiddleware implements NestMiddleware {\n  private redis: Redis;\n\n  constructor(private configService: ConfigService) {\n    this.redis = new Redis({\n      host: this.configService.get('REDIS_HOST'),\n      port: this.configService.get('REDIS_PORT'),\n      password: this.configService.get('REDIS_PASSWORD'),\n    });\n  }\n\n  async use(req: Request, res: Response, next: NextFunction): Promise<void> {\n    const config = this.getRateLimitConfig(req);\n    const key = config.keyGenerator(req);\n    const window = Math.floor(Date.now() / config.windowMs);\n    const redisKey = `rate_limit:${key}:${window}`;\n\n    try {\n      const current = await this.redis.incr(redisKey);\n      \n      if (current === 1) {\n        await this.redis.expire(redisKey, Math.ceil(config.windowMs / 1000));\n      }\n\n      if (current > config.maxRequests) {\n        const retryAfter = Math.ceil(config.windowMs / 1000);\n        res.set({\n          'X-RateLimit-Limit': config.maxRequests.toString(),\n          'X-RateLimit-Remaining': '0',\n          'X-RateLimit-Reset': (Date.now() + config.windowMs).toString(),\n          'Retry-After': retryAfter.toString(),\n        });\n\n        throw new HttpException(\n          'Too Many Requests',\n          HttpStatus.TOO_MANY_REQUESTS\n        );\n      }\n\n      res.set({\n        'X-RateLimit-Limit': config.maxRequests.toString(),\n        'X-RateLimit-Remaining': (config.maxRequests - current).toString(),\n        'X-RateLimit-Reset': (Date.now() + config.windowMs).toString(),\n      });\n\n      next();\n    } catch (error) {\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      next(error);\n    }\n  }\n\n  private getRateLimitConfig(req: Request): RateLimitConfig {\n    // Different limits for different endpoints\n    if (req.path.startsWith('/auth/login')) {\n      return {\n        windowMs: 15 * 60 * 1000, // 15 minutes\n        maxRequests: 5,\n        keyGenerator: (req) => req.ip,\n      };\n    }\n\n    if (req.path.startsWith('/api/')) {\n      return {\n        windowMs: 15 * 60 * 1000, // 15 minutes\n        maxRequests: 100,\n        keyGenerator: (req) => req.ip,\n      };\n    }\n\n    // Default rate limit\n    return {\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      maxRequests: 1000,\n      keyGenerator: (req) => req.ip,\n    };\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"ddos-protection-service",children:"DDoS Protection Service"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/security/ddos-protection.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Redis } from 'ioredis';\n\ninterface DDoSMetrics {\n  requestCount: number;\n  uniqueIPs: number;\n  suspiciousPatterns: string[];\n  isUnderAttack: boolean;\n}\n\n@Injectable()\nexport class DDoSProtectionService {\n  private readonly logger = new Logger(DDoSProtectionService.name);\n  private redis: Redis;\n\n  constructor(private configService: ConfigService) {\n    this.redis = new Redis({\n      host: this.configService.get('REDIS_HOST'),\n      port: this.configService.get('REDIS_PORT'),\n    });\n  }\n\n  async analyzeTraffic(): Promise<DDoSMetrics> {\n    const now = Date.now();\n    const windowStart = now - 60000; // 1 minute window\n\n    try {\n      // Get request counts by IP in the last minute\n      const requestKeys = await this.redis.keys('request:*');\n      const requestCounts = new Map<string, number>();\n      let totalRequests = 0;\n\n      for (const key of requestKeys) {\n        const timestamp = await this.redis.get(key);\n        if (timestamp && parseInt(timestamp) > windowStart) {\n          const ip = key.split(':')[1];\n          requestCounts.set(ip, (requestCounts.get(ip) || 0) + 1);\n          totalRequests++;\n        }\n      }\n\n      const suspiciousPatterns = this.detectSuspiciousPatterns(requestCounts);\n      const isUnderAttack = this.determineAttackStatus(totalRequests, requestCounts);\n\n      return {\n        requestCount: totalRequests,\n        uniqueIPs: requestCounts.size,\n        suspiciousPatterns,\n        isUnderAttack,\n      };\n    } catch (error) {\n      this.logger.error('Failed to analyze traffic:', error);\n      return {\n        requestCount: 0,\n        uniqueIPs: 0,\n        suspiciousPatterns: [],\n        isUnderAttack: false,\n      };\n    }\n  }\n\n  async recordRequest(ip: string): Promise<void> {\n    const key = `request:${ip}:${Date.now()}`;\n    await this.redis.setex(key, 60, Date.now().toString());\n  }\n\n  private detectSuspiciousPatterns(requestCounts: Map<string, number>): string[] {\n    const patterns: string[] = [];\n\n    // Check for single IP with too many requests\n    for (const [ip, count] of requestCounts.entries()) {\n      if (count > 100) { // More than 100 requests per minute\n        patterns.push(`High request rate from IP: ${ip} (${count} requests)`);\n      }\n    }\n\n    // Check for distributed attack (many IPs with moderate requests)\n    const moderateRequestIPs = Array.from(requestCounts.entries())\n      .filter(([_, count]) => count > 20 && count <= 100);\n    \n    if (moderateRequestIPs.length > 50) {\n      patterns.push(`Potential distributed attack: ${moderateRequestIPs.length} IPs with moderate request rates`);\n    }\n\n    return patterns;\n  }\n\n  private determineAttackStatus(\n    totalRequests: number,\n    requestCounts: Map<string, number>\n  ): boolean {\n    // High total request count\n    if (totalRequests > 10000) {\n      this.logger.warn(`High traffic detected: ${totalRequests} requests in last minute`);\n      return true;\n    }\n\n    // Single IP with excessive requests\n    const maxRequestsFromSingleIP = Math.max(...Array.from(requestCounts.values()));\n    if (maxRequestsFromSingleIP > 500) {\n      this.logger.warn(`Single IP attack detected: ${maxRequestsFromSingleIP} requests`);\n      return true;\n    }\n\n    return false;\n  }\n\n  async enableEmergencyMode(): Promise<void> {\n    await this.redis.setex('emergency_mode', 300, 'true'); // 5 minutes\n    this.logger.warn('Emergency mode enabled - enhanced rate limiting active');\n  }\n\n  async isEmergencyModeActive(): Promise<boolean> {\n    const emergencyMode = await this.redis.get('emergency_mode');\n    return emergencyMode === 'true';\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"network-monitoring",children:"Network Monitoring"}),"\n",(0,o.jsx)(n.h3,{id:"network-monitoring-service",children:"Network Monitoring Service"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// src/monitoring/network-monitoring.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { DDoSProtectionService } from '../security/ddos-protection.service';\nimport { NetworkAccessControlService } from '../security/network-access-control.service';\n\n@Injectable()\nexport class NetworkMonitoringService {\n  private readonly logger = new Logger(NetworkMonitoringService.name);\n\n  constructor(\n    private ddosProtection: DDoSProtectionService,\n    private networkAcl: NetworkAccessControlService\n  ) {}\n\n  @Cron(CronExpression.EVERY_MINUTE)\n  async monitorNetworkTraffic(): Promise<void> {\n    try {\n      const metrics = await this.ddosProtection.analyzeTraffic();\n      \n      this.logger.log(`Network metrics: ${JSON.stringify(metrics)}`);\n\n      if (metrics.isUnderAttack) {\n        await this.handleDDoSAttack(metrics);\n      }\n\n      if (metrics.suspiciousPatterns.length > 0) {\n        this.logger.warn(`Suspicious patterns detected: ${metrics.suspiciousPatterns.join(', ')}`);\n      }\n    } catch (error) {\n      this.logger.error('Network monitoring failed:', error);\n    }\n  }\n\n  private async handleDDoSAttack(metrics: any): Promise<void> {\n    this.logger.error('DDoS attack detected! Initiating protection measures...');\n    \n    // Enable emergency mode\n    await this.ddosProtection.enableEmergencyMode();\n    \n    // Send alerts\n    await this.sendSecurityAlert('DDoS Attack Detected', {\n      requestCount: metrics.requestCount,\n      uniqueIPs: metrics.uniqueIPs,\n      patterns: metrics.suspiciousPatterns,\n    });\n  }\n\n  private async sendSecurityAlert(title: string, details: any): Promise<void> {\n    // Implementation for sending alerts (Slack, email, PagerDuty, etc.)\n    this.logger.warn(`SECURITY ALERT: ${title}`, details);\n  }\n\n  async getNetworkSecurityStatus(): Promise<any> {\n    const emergencyMode = await this.ddosProtection.isEmergencyModeActive();\n    const networkRules = this.networkAcl.getNetworkRules();\n    \n    return {\n      emergencyMode,\n      networkRules,\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This comprehensive network security implementation provides:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"VPC and firewall configuration"})," with defense-in-depth approach"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Kubernetes network policies"})," for pod-level isolation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Load balancer security"})," with Cloud Armor integration"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Service mesh security"})," with Istio mTLS and authorization"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"WAF and DDoS protection"})," with rate limiting and traffic analysis"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Network monitoring"})," with automated threat detection and response"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The implementation ensures that network security is layered, automated, and continuously monitored for threats."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},5741:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(9729);const o={},i=r.createContext(o);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);