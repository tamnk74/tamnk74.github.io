"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[5629],{5741:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var a=t(9729);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},8898:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"architecture-practices/architecture-definition/backup-recovery","title":"Backup and Recovery Strategy","description":"This guide provides comprehensive backup and recovery strategies for NestJS microservices and Next.js microfrontend applications, ensuring business continuity and data protection in production environments.","source":"@site/docs/architecture-practices/architecture-definition/backup-recovery.md","sourceDirName":"architecture-practices/architecture-definition","slug":"/architecture-practices/architecture-definition/backup-recovery","permalink":"/fullstack-dev/docs/architecture-practices/architecture-definition/backup-recovery","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-definition/backup-recovery.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Third-Party Integration Strategy","permalink":"/fullstack-dev/docs/architecture-practices/architecture-definition/third-party-integration"},"next":{"title":"CI/CD Pipeline for NestJS & Next.js Microservices","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline"}}');var s=t(5813),i=t(5741);const r={},c="Backup and Recovery Strategy",o={},p=[{value:"Overview",id:"overview",level:2},{value:"Backup Architecture",id:"backup-architecture",level:2},{value:"Multi-Tier Backup Strategy",id:"multi-tier-backup-strategy",level:3},{value:"Database Backup Strategy",id:"database-backup-strategy",level:2},{value:"PostgreSQL Backup Implementation",id:"postgresql-backup-implementation",level:3},{value:"Redis Backup Service",id:"redis-backup-service",level:3},{value:"Application State Backup",id:"application-state-backup",level:2},{value:"State Snapshot Service",id:"state-snapshot-service",level:3},{value:"Disaster Recovery",id:"disaster-recovery",level:2},{value:"Recovery Orchestration Service",id:"recovery-orchestration-service",level:3},{value:"Next.js Static Asset Backup",id:"nextjs-static-asset-backup",level:2},{value:"Static Asset Backup Strategy",id:"static-asset-backup-strategy",level:3},{value:"Monitoring and Alerting",id:"monitoring-and-alerting",level:2},{value:"Backup Monitoring Service",id:"backup-monitoring-service",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Backup Strategy Guidelines",id:"backup-strategy-guidelines",level:3},{value:"Recovery Time and Point Objectives",id:"recovery-time-and-point-objectives",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"backup-and-recovery-strategy",children:"Backup and Recovery Strategy"})}),"\n",(0,s.jsx)(n.p,{children:"This guide provides comprehensive backup and recovery strategies for NestJS microservices and Next.js microfrontend applications, ensuring business continuity and data protection in production environments."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"A robust backup and recovery strategy is essential for maintaining data integrity, ensuring business continuity, and meeting compliance requirements. This guide covers database backups, application state recovery, disaster recovery planning, and automated recovery procedures."}),"\n",(0,s.jsx)(n.h2,{id:"backup-architecture",children:"Backup Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"multi-tier-backup-strategy",children:"Multi-Tier Backup Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Production Data] --\x3e B[Real-time Replication]\n    A --\x3e C[Hot Backup - Hourly]\n    A --\x3e D[Warm Backup - Daily]\n    A --\x3e E[Cold Backup - Weekly]\n    \n    B --\x3e F[Standby Database]\n    C --\x3e G[Local Storage]\n    D --\x3e H[Cloud Storage]\n    E --\x3e I[Archive Storage]\n    \n    J[Monitoring] --\x3e A\n    K[Alerting] --\x3e J\n    L[Recovery Automation] --\x3e F\n    L --\x3e G\n    L --\x3e H\n"})}),"\n",(0,s.jsx)(n.h2,{id:"database-backup-strategy",children:"Database Backup Strategy"}),"\n",(0,s.jsx)(n.h3,{id:"postgresql-backup-implementation",children:"PostgreSQL Backup Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/backup/database-backup.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as AWS from 'aws-sdk';\n\nconst execAsync = promisify(exec);\n\nexport interface BackupMetadata {\n  id: string;\n  timestamp: Date;\n  type: 'full' | 'incremental' | 'differential';\n  size: number;\n  duration: number;\n  location: string;\n  checksum: string;\n  status: 'success' | 'failed' | 'partial';\n}\n\n@Injectable()\nexport class DatabaseBackupService {\n  private readonly logger = new Logger(DatabaseBackupService.name);\n  private readonly s3: AWS.S3;\n  private readonly backupDir: string;\n\n  constructor(private readonly configService: ConfigService) {\n    this.s3 = new AWS.S3({\n      region: this.configService.get('AWS_REGION'),\n      accessKeyId: this.configService.get('AWS_ACCESS_KEY_ID'),\n      secretAccessKey: this.configService.get('AWS_SECRET_ACCESS_KEY'),\n    });\n\n    this.backupDir = this.configService.get('BACKUP_DIRECTORY', '/tmp/backups');\n  }\n\n  // Full backup every day at 2 AM\n  @Cron('0 2 * * *')\n  async createFullBackup(): Promise<BackupMetadata> {\n    const startTime = Date.now();\n    const backupId = `full_${Date.now()}`;\n    \n    this.logger.log('Starting full database backup');\n\n    try {\n      // Create backup directory if it doesn't exist\n      await fs.mkdir(this.backupDir, { recursive: true });\n\n      const filename = `${backupId}.sql`;\n      const filepath = path.join(this.backupDir, filename);\n\n      // Create PostgreSQL dump\n      const dumpCommand = this.buildPgDumpCommand(filepath, 'full');\n      await execAsync(dumpCommand);\n\n      // Compress the backup\n      const compressedPath = `${filepath}.gz`;\n      await execAsync(`gzip ${filepath}`);\n\n      // Calculate file size and checksum\n      const stats = await fs.stat(compressedPath);\n      const checksum = await this.calculateChecksum(compressedPath);\n\n      // Upload to S3\n      await this.uploadToS3(compressedPath, `backups/full/${filename}.gz`);\n\n      // Clean up local file\n      await fs.unlink(compressedPath);\n\n      const duration = Date.now() - startTime;\n      const metadata: BackupMetadata = {\n        id: backupId,\n        timestamp: new Date(),\n        type: 'full',\n        size: stats.size,\n        duration,\n        location: `s3://backups/full/${filename}.gz`,\n        checksum,\n        status: 'success',\n      };\n\n      await this.saveBackupMetadata(metadata);\n      this.logger.log(`Full backup completed successfully: ${backupId}`);\n\n      return metadata;\n    } catch (error) {\n      this.logger.error(`Full backup failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  // Incremental backup every hour\n  @Cron(CronExpression.EVERY_HOUR)\n  async createIncrementalBackup(): Promise<BackupMetadata> {\n    const startTime = Date.now();\n    const backupId = `incremental_${Date.now()}`;\n    \n    this.logger.log('Starting incremental backup');\n\n    try {\n      // Get the last backup timestamp\n      const lastBackup = await this.getLastBackupTimestamp();\n      \n      // Create WAL-E backup or transaction log backup\n      const filename = `${backupId}.wal`;\n      const filepath = path.join(this.backupDir, filename);\n\n      // Archive WAL files since last backup\n      await this.archiveWALFiles(lastBackup, filepath);\n\n      // Compress and upload\n      const compressedPath = `${filepath}.gz`;\n      await execAsync(`gzip ${filepath}`);\n\n      const stats = await fs.stat(compressedPath);\n      const checksum = await this.calculateChecksum(compressedPath);\n\n      await this.uploadToS3(compressedPath, `backups/incremental/${filename}.gz`);\n      await fs.unlink(compressedPath);\n\n      const duration = Date.now() - startTime;\n      const metadata: BackupMetadata = {\n        id: backupId,\n        timestamp: new Date(),\n        type: 'incremental',\n        size: stats.size,\n        duration,\n        location: `s3://backups/incremental/${filename}.gz`,\n        checksum,\n        status: 'success',\n      };\n\n      await this.saveBackupMetadata(metadata);\n      this.logger.log(`Incremental backup completed: ${backupId}`);\n\n      return metadata;\n    } catch (error) {\n      this.logger.error(`Incremental backup failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async restoreFromBackup(\n    backupId: string,\n    targetDatabase?: string,\n  ): Promise<void> {\n    this.logger.log(`Starting database restore from backup: ${backupId}`);\n\n    try {\n      const metadata = await this.getBackupMetadata(backupId);\n      if (!metadata) {\n        throw new Error(`Backup not found: ${backupId}`);\n      }\n\n      // Download backup from S3\n      const localPath = await this.downloadFromS3(metadata.location);\n\n      // Verify checksum\n      const downloadedChecksum = await this.calculateChecksum(localPath);\n      if (downloadedChecksum !== metadata.checksum) {\n        throw new Error('Backup file corrupted - checksum mismatch');\n      }\n\n      // Decompress if needed\n      const decompressedPath = localPath.replace('.gz', '');\n      if (localPath.endsWith('.gz')) {\n        await execAsync(`gunzip ${localPath}`);\n      }\n\n      // Create target database if specified\n      const dbName = targetDatabase || this.configService.get('DB_NAME');\n      if (targetDatabase) {\n        await this.createDatabase(targetDatabase);\n      }\n\n      // Restore the backup\n      const restoreCommand = this.buildPgRestoreCommand(decompressedPath, dbName);\n      await execAsync(restoreCommand);\n\n      // Clean up\n      await fs.unlink(decompressedPath);\n\n      this.logger.log(`Database restore completed successfully: ${backupId}`);\n    } catch (error) {\n      this.logger.error(`Database restore failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  private buildPgDumpCommand(filepath: string, type: 'full' | 'schema-only'): string {\n    const host = this.configService.get('DB_HOST');\n    const port = this.configService.get('DB_PORT');\n    const username = this.configService.get('DB_USERNAME');\n    const database = this.configService.get('DB_NAME');\n\n    let command = `pg_dump -h ${host} -p ${port} -U ${username} -d ${database}`;\n    \n    if (type === 'schema-only') {\n      command += ' --schema-only';\n    } else {\n      command += ' --verbose --no-owner --no-acl';\n    }\n\n    command += ` > ${filepath}`;\n    \n    return `PGPASSWORD=${this.configService.get('DB_PASSWORD')} ${command}`;\n  }\n\n  private buildPgRestoreCommand(filepath: string, database: string): string {\n    const host = this.configService.get('DB_HOST');\n    const port = this.configService.get('DB_PORT');\n    const username = this.configService.get('DB_USERNAME');\n\n    const command = `psql -h ${host} -p ${port} -U ${username} -d ${database} < ${filepath}`;\n    \n    return `PGPASSWORD=${this.configService.get('DB_PASSWORD')} ${command}`;\n  }\n\n  private async uploadToS3(localPath: string, s3Key: string): Promise<void> {\n    const fileContent = await fs.readFile(localPath);\n    \n    await this.s3.upload({\n      Bucket: this.configService.get('BACKUP_S3_BUCKET'),\n      Key: s3Key,\n      Body: fileContent,\n      StorageClass: 'STANDARD_IA', // Infrequent Access for cost optimization\n      ServerSideEncryption: 'AES256',\n    }).promise();\n  }\n\n  private async downloadFromS3(s3Location: string): Promise<string> {\n    const [, , bucket, ...keyParts] = s3Location.split('/');\n    const key = keyParts.join('/');\n    \n    const response = await this.s3.getObject({\n      Bucket: bucket,\n      Key: key,\n    }).promise();\n\n    const localPath = path.join(this.backupDir, path.basename(key));\n    await fs.writeFile(localPath, response.Body as Buffer);\n    \n    return localPath;\n  }\n\n  private async calculateChecksum(filepath: string): Promise<string> {\n    const { stdout } = await execAsync(`sha256sum ${filepath}`);\n    return stdout.split(' ')[0];\n  }\n\n  private async saveBackupMetadata(metadata: BackupMetadata): Promise<void> {\n    // Save to database or metadata store\n    // Implementation depends on your metadata storage strategy\n  }\n\n  private async getBackupMetadata(backupId: string): Promise<BackupMetadata | null> {\n    // Retrieve from database or metadata store\n    // Implementation depends on your metadata storage strategy\n    return null;\n  }\n\n  private async getLastBackupTimestamp(): Promise<Date> {\n    // Get timestamp of last backup for incremental backups\n    return new Date(Date.now() - 3600000); // Default to 1 hour ago\n  }\n\n  private async archiveWALFiles(since: Date, outputPath: string): Promise<void> {\n    // Archive PostgreSQL WAL files for incremental backup\n    // This would typically use WAL-E or similar tool\n  }\n\n  private async createDatabase(name: string): Promise<void> {\n    const command = this.buildCreateDatabaseCommand(name);\n    await execAsync(command);\n  }\n\n  private buildCreateDatabaseCommand(database: string): string {\n    const host = this.configService.get('DB_HOST');\n    const port = this.configService.get('DB_PORT');\n    const username = this.configService.get('DB_USERNAME');\n\n    const command = `createdb -h ${host} -p ${port} -U ${username} ${database}`;\n    \n    return `PGPASSWORD=${this.configService.get('DB_PASSWORD')} ${command}`;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"redis-backup-service",children:"Redis Backup Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/backup/redis-backup.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport Redis from 'ioredis';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\n@Injectable()\nexport class RedisBackupService {\n  private readonly logger = new Logger(RedisBackupService.name);\n  private readonly redis: Redis;\n  private readonly backupDir: string;\n\n  constructor(private readonly configService: ConfigService) {\n    this.redis = new Redis({\n      host: this.configService.get('REDIS_HOST'),\n      port: this.configService.get('REDIS_PORT'),\n      password: this.configService.get('REDIS_PASSWORD'),\n    });\n\n    this.backupDir = this.configService.get('REDIS_BACKUP_DIR', '/tmp/redis-backups');\n  }\n\n  // Redis backup every 6 hours\n  @Cron('0 */6 * * *')\n  async createRedisBackup(): Promise<void> {\n    this.logger.log('Starting Redis backup');\n\n    try {\n      await fs.mkdir(this.backupDir, { recursive: true });\n\n      const timestamp = new Date().toISOString().replace(/:/g, '-');\n      const filename = `redis-backup-${timestamp}.rdb`;\n      const filepath = path.join(this.backupDir, filename);\n\n      // Trigger BGSAVE for point-in-time backup\n      await this.redis.bgsave();\n\n      // Wait for background save to complete\n      await this.waitForBgsaveCompletion();\n\n      // Copy the RDB file\n      const rdbPath = await this.getRdbPath();\n      await fs.copyFile(rdbPath, filepath);\n\n      // Compress and upload to S3\n      await this.compressAndUpload(filepath, `redis-backups/${filename}`);\n\n      this.logger.log(`Redis backup completed: ${filename}`);\n    } catch (error) {\n      this.logger.error(`Redis backup failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  private async waitForBgsaveCompletion(): Promise<void> {\n    let isRunning = true;\n    while (isRunning) {\n      const result = await this.redis.lastsave();\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      const newResult = await this.redis.lastsave();\n      isRunning = result === newResult;\n    }\n  }\n\n  private async getRdbPath(): Promise<string> {\n    const info = await this.redis.config('GET', 'dir');\n    const dbfilename = await this.redis.config('GET', 'dbfilename');\n    return path.join(info[1], dbfilename[1]);\n  }\n\n  private async compressAndUpload(filepath: string, s3Key: string): Promise<void> {\n    // Implementation similar to database backup service\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"application-state-backup",children:"Application State Backup"}),"\n",(0,s.jsx)(n.h3,{id:"state-snapshot-service",children:"State Snapshot Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/backup/state-snapshot.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Cron, CronExpression } from '@nestjs/schedule';\n\nexport interface ApplicationSnapshot {\n  timestamp: Date;\n  version: string;\n  configuration: Record<string, any>;\n  activeConnections: number;\n  queueStates: Record<string, any>;\n  cacheStates: Record<string, any>;\n  metrics: Record<string, number>;\n}\n\n@Injectable()\nexport class StateSnapshotService {\n  private readonly logger = new Logger(StateSnapshotService.name);\n\n  constructor(private readonly configService: ConfigService) {}\n\n  // Create state snapshot every hour\n  @Cron(CronExpression.EVERY_HOUR)\n  async createStateSnapshot(): Promise<ApplicationSnapshot> {\n    this.logger.log('Creating application state snapshot');\n\n    try {\n      const snapshot: ApplicationSnapshot = {\n        timestamp: new Date(),\n        version: process.env.npm_package_version || '1.0.0',\n        configuration: await this.captureConfiguration(),\n        activeConnections: await this.getActiveConnections(),\n        queueStates: await this.captureQueueStates(),\n        cacheStates: await this.captureCacheStates(),\n        metrics: await this.captureMetrics(),\n      };\n\n      await this.saveSnapshot(snapshot);\n      \n      this.logger.log('State snapshot created successfully');\n      return snapshot;\n    } catch (error) {\n      this.logger.error(`State snapshot failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async restoreFromSnapshot(snapshotId: string): Promise<void> {\n    this.logger.log(`Restoring from state snapshot: ${snapshotId}`);\n\n    try {\n      const snapshot = await this.loadSnapshot(snapshotId);\n      if (!snapshot) {\n        throw new Error(`Snapshot not found: ${snapshotId}`);\n      }\n\n      // Restore queue states\n      await this.restoreQueueStates(snapshot.queueStates);\n\n      // Restore cache states\n      await this.restoreCacheStates(snapshot.cacheStates);\n\n      // Apply configuration changes\n      await this.applyConfiguration(snapshot.configuration);\n\n      this.logger.log('State restoration completed successfully');\n    } catch (error) {\n      this.logger.error(`State restoration failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  private async captureConfiguration(): Promise<Record<string, any>> {\n    return {\n      database: {\n        host: this.configService.get('DB_HOST'),\n        port: this.configService.get('DB_PORT'),\n        // Don't include sensitive data like passwords\n      },\n      redis: {\n        host: this.configService.get('REDIS_HOST'),\n        port: this.configService.get('REDIS_PORT'),\n      },\n      // Add other non-sensitive configuration\n    };\n  }\n\n  private async getActiveConnections(): Promise<number> {\n    // Count active database connections, WebSocket connections, etc.\n    return 0;\n  }\n\n  private async captureQueueStates(): Promise<Record<string, any>> {\n    // Capture queue depths, pending jobs, etc.\n    return {};\n  }\n\n  private async captureCacheStates(): Promise<Record<string, any>> {\n    // Capture cache keys, hit rates, etc.\n    return {};\n  }\n\n  private async captureMetrics(): Promise<Record<string, number>> {\n    // Capture performance metrics, counters, etc.\n    return {};\n  }\n\n  private async saveSnapshot(snapshot: ApplicationSnapshot): Promise<void> {\n    // Save to persistent storage\n  }\n\n  private async loadSnapshot(snapshotId: string): Promise<ApplicationSnapshot | null> {\n    // Load from persistent storage\n    return null;\n  }\n\n  private async restoreQueueStates(queueStates: Record<string, any>): Promise<void> {\n    // Restore queue states\n  }\n\n  private async restoreCacheStates(cacheStates: Record<string, any>): Promise<void> {\n    // Restore cache states\n  }\n\n  private async applyConfiguration(configuration: Record<string, any>): Promise<void> {\n    // Apply configuration changes\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"disaster-recovery",children:"Disaster Recovery"}),"\n",(0,s.jsx)(n.h3,{id:"recovery-orchestration-service",children:"Recovery Orchestration Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/disaster-recovery/recovery-orchestrator.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\nexport interface DisasterRecoveryPlan {\n  id: string;\n  name: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  rto: number; // Recovery Time Objective in minutes\n  rpo: number; // Recovery Point Objective in minutes\n  steps: RecoveryStep[];\n}\n\nexport interface RecoveryStep {\n  id: string;\n  name: string;\n  type: 'database' | 'application' | 'infrastructure' | 'validation';\n  command: string;\n  timeout: number;\n  dependencies: string[];\n  rollbackCommand?: string;\n}\n\n@Injectable()\nexport class RecoveryOrchestratorService {\n  private readonly logger = new Logger(RecoveryOrchestratorService.name);\n\n  constructor(\n    private readonly configService: ConfigService,\n    private readonly databaseBackupService: DatabaseBackupService,\n    private readonly stateSnapshotService: StateSnapshotService,\n  ) {}\n\n  async executeDisasterRecovery(\n    planId: string,\n    targetEnvironment: string,\n  ): Promise<void> {\n    this.logger.log(`Starting disaster recovery: ${planId} -> ${targetEnvironment}`);\n\n    try {\n      const plan = await this.getRecoveryPlan(planId);\n      if (!plan) {\n        throw new Error(`Recovery plan not found: ${planId}`);\n      }\n\n      // Validate prerequisites\n      await this.validatePrerequisites(plan, targetEnvironment);\n\n      // Execute recovery steps\n      const results = await this.executeRecoverySteps(plan.steps);\n\n      // Validate recovery\n      await this.validateRecovery(plan, targetEnvironment);\n\n      this.logger.log(`Disaster recovery completed successfully: ${planId}`);\n    } catch (error) {\n      this.logger.error(`Disaster recovery failed: ${error.message}`);\n      await this.executeRollback(planId);\n      throw error;\n    }\n  }\n\n  private async getRecoveryPlan(planId: string): Promise<DisasterRecoveryPlan | null> {\n    // Load recovery plan from configuration or database\n    const plans: Record<string, DisasterRecoveryPlan> = {\n      'database-corruption': {\n        id: 'database-corruption',\n        name: 'Database Corruption Recovery',\n        priority: 'critical',\n        rto: 30, // 30 minutes\n        rpo: 60, // 1 hour data loss acceptable\n        steps: [\n          {\n            id: 'stop-services',\n            name: 'Stop Application Services',\n            type: 'application',\n            command: 'kubectl scale deployment --replicas=0',\n            timeout: 300,\n            dependencies: [],\n          },\n          {\n            id: 'restore-database',\n            name: 'Restore Database from Backup',\n            type: 'database',\n            command: 'restore-latest-backup',\n            timeout: 1800,\n            dependencies: ['stop-services'],\n          },\n          {\n            id: 'start-services',\n            name: 'Start Application Services',\n            type: 'application',\n            command: 'kubectl scale deployment --replicas=3',\n            timeout: 600,\n            dependencies: ['restore-database'],\n          },\n          {\n            id: 'validate-health',\n            name: 'Validate Application Health',\n            type: 'validation',\n            command: 'health-check',\n            timeout: 300,\n            dependencies: ['start-services'],\n          },\n        ],\n      },\n    };\n\n    return plans[planId] || null;\n  }\n\n  private async validatePrerequisites(\n    plan: DisasterRecoveryPlan,\n    targetEnvironment: string,\n  ): Promise<void> {\n    // Check if target environment is available\n    // Verify backup availability\n    // Check resource availability\n    // Validate access permissions\n  }\n\n  private async executeRecoverySteps(steps: RecoveryStep[]): Promise<void> {\n    const completed = new Set<string>();\n    const failed = new Set<string>();\n\n    while (completed.size < steps.length && failed.size === 0) {\n      for (const step of steps) {\n        if (completed.has(step.id) || failed.has(step.id)) {\n          continue;\n        }\n\n        // Check if all dependencies are completed\n        const dependenciesCompleted = step.dependencies.every(dep => completed.has(dep));\n        if (!dependenciesCompleted) {\n          continue;\n        }\n\n        try {\n          this.logger.log(`Executing recovery step: ${step.name}`);\n          await this.executeStep(step);\n          completed.add(step.id);\n          this.logger.log(`Recovery step completed: ${step.name}`);\n        } catch (error) {\n          this.logger.error(`Recovery step failed: ${step.name}`, error);\n          failed.add(step.id);\n          throw error;\n        }\n      }\n\n      // Prevent infinite loop\n      if (completed.size === 0 && failed.size === 0) {\n        throw new Error('No recovery steps can be executed - check dependencies');\n      }\n    }\n  }\n\n  private async executeStep(step: RecoveryStep): Promise<void> {\n    switch (step.type) {\n      case 'database':\n        if (step.command === 'restore-latest-backup') {\n          const latestBackup = await this.getLatestBackup();\n          await this.databaseBackupService.restoreFromBackup(latestBackup.id);\n        }\n        break;\n      \n      case 'application':\n        await this.executeCommand(step.command, step.timeout);\n        break;\n      \n      case 'infrastructure':\n        await this.executeInfrastructureCommand(step.command, step.timeout);\n        break;\n      \n      case 'validation':\n        await this.executeValidation(step.command, step.timeout);\n        break;\n    }\n  }\n\n  private async executeCommand(command: string, timeout: number): Promise<void> {\n    // Execute shell command with timeout\n  }\n\n  private async executeInfrastructureCommand(command: string, timeout: number): Promise<void> {\n    // Execute infrastructure commands (Terraform, CloudFormation, etc.)\n  }\n\n  private async executeValidation(command: string, timeout: number): Promise<void> {\n    // Execute validation commands (health checks, data integrity checks, etc.)\n  }\n\n  private async validateRecovery(\n    plan: DisasterRecoveryPlan,\n    targetEnvironment: string,\n  ): Promise<void> {\n    // Perform comprehensive validation\n    // Check application health\n    // Verify data integrity\n    // Test critical functionality\n  }\n\n  private async executeRollback(planId: string): Promise<void> {\n    // Execute rollback procedures if recovery fails\n  }\n\n  private async getLatestBackup(): Promise<BackupMetadata> {\n    // Get the most recent successful backup\n    throw new Error('Method not implemented');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"nextjs-static-asset-backup",children:"Next.js Static Asset Backup"}),"\n",(0,s.jsx)(n.h3,{id:"static-asset-backup-strategy",children:"Static Asset Backup Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// scripts/backup-static-assets.ts\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { S3 } from 'aws-sdk';\nimport { createHash } from 'crypto';\n\ninterface AssetManifest {\n  version: string;\n  timestamp: string;\n  assets: AssetInfo[];\n}\n\ninterface AssetInfo {\n  path: string;\n  hash: string;\n  size: number;\n  mimeType: string;\n}\n\nclass StaticAssetBackup {\n  private s3: S3;\n  private bucketName: string;\n\n  constructor() {\n    this.s3 = new S3({\n      region: process.env.AWS_REGION,\n      accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n    });\n    this.bucketName = process.env.BACKUP_BUCKET!;\n  }\n\n  async backupStaticAssets(buildDir: string): Promise<void> {\n    console.log('Starting static asset backup...');\n\n    try {\n      // Generate asset manifest\n      const manifest = await this.generateAssetManifest(buildDir);\n      \n      // Upload assets to S3\n      await this.uploadAssets(buildDir, manifest);\n      \n      // Upload manifest\n      await this.uploadManifest(manifest);\n      \n      console.log('Static asset backup completed successfully');\n    } catch (error) {\n      console.error('Static asset backup failed:', error);\n      throw error;\n    }\n  }\n\n  private async generateAssetManifest(buildDir: string): Promise<AssetManifest> {\n    const assets: AssetInfo[] = [];\n    \n    const traverseDirectory = async (dir: string, relativePath = ''): Promise<void> => {\n      const items = await fs.readdir(dir);\n      \n      for (const item of items) {\n        const fullPath = path.join(dir, item);\n        const stats = await fs.stat(fullPath);\n        \n        if (stats.isDirectory()) {\n          await traverseDirectory(fullPath, path.join(relativePath, item));\n        } else {\n          const content = await fs.readFile(fullPath);\n          const hash = createHash('sha256').update(content).digest('hex');\n          \n          assets.push({\n            path: path.join(relativePath, item),\n            hash,\n            size: stats.size,\n            mimeType: this.getMimeType(item),\n          });\n        }\n      }\n    };\n\n    await traverseDirectory(buildDir);\n\n    return {\n      version: process.env.npm_package_version || '1.0.0',\n      timestamp: new Date().toISOString(),\n      assets,\n    };\n  }\n\n  private async uploadAssets(buildDir: string, manifest: AssetManifest): Promise<void> {\n    for (const asset of manifest.assets) {\n      const localPath = path.join(buildDir, asset.path);\n      const s3Key = `static-assets/${manifest.version}/${asset.path}`;\n      \n      const content = await fs.readFile(localPath);\n      \n      await this.s3.upload({\n        Bucket: this.bucketName,\n        Key: s3Key,\n        Body: content,\n        ContentType: asset.mimeType,\n        CacheControl: 'public, max-age=31536000', // 1 year\n        Metadata: {\n          originalHash: asset.hash,\n          originalSize: asset.size.toString(),\n        },\n      }).promise();\n      \n      console.log(`Uploaded: ${asset.path}`);\n    }\n  }\n\n  private async uploadManifest(manifest: AssetManifest): Promise<void> {\n    const manifestKey = `static-assets/${manifest.version}/manifest.json`;\n    \n    await this.s3.upload({\n      Bucket: this.bucketName,\n      Key: manifestKey,\n      Body: JSON.stringify(manifest, null, 2),\n      ContentType: 'application/json',\n    }).promise();\n    \n    console.log('Manifest uploaded successfully');\n  }\n\n  private getMimeType(filename: string): string {\n    const ext = path.extname(filename).toLowerCase();\n    const mimeTypes: Record<string, string> = {\n      '.html': 'text/html',\n      '.css': 'text/css',\n      '.js': 'application/javascript',\n      '.json': 'application/json',\n      '.png': 'image/png',\n      '.jpg': 'image/jpeg',\n      '.jpeg': 'image/jpeg',\n      '.gif': 'image/gif',\n      '.svg': 'image/svg+xml',\n      '.ico': 'image/x-icon',\n      '.woff': 'font/woff',\n      '.woff2': 'font/woff2',\n      '.ttf': 'font/ttf',\n      '.eot': 'application/vnd.ms-fontobject',\n    };\n    \n    return mimeTypes[ext] || 'application/octet-stream';\n  }\n}\n\n// Usage in package.json scripts:\n// \"backup:assets\": \"ts-node scripts/backup-static-assets.ts\"\n"})}),"\n",(0,s.jsx)(n.h2,{id:"monitoring-and-alerting",children:"Monitoring and Alerting"}),"\n",(0,s.jsx)(n.h3,{id:"backup-monitoring-service",children:"Backup Monitoring Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/monitoring/backup-monitoring.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class BackupMonitoringService {\n  private readonly logger = new Logger(BackupMonitoringService.name);\n\n  constructor(private readonly configService: ConfigService) {}\n\n  // Monitor backup health every 15 minutes\n  @Cron('*/15 * * * *')\n  async monitorBackupHealth(): Promise<void> {\n    try {\n      // Check recent backup completion\n      const recentBackups = await this.getRecentBackups(24); // Last 24 hours\n      \n      if (recentBackups.length === 0) {\n        await this.sendAlert('No backups completed in the last 24 hours', 'critical');\n        return;\n      }\n\n      // Check backup sizes\n      const avgSize = this.calculateAverageSize(recentBackups);\n      const latestBackup = recentBackups[0];\n      \n      if (latestBackup.size < avgSize * 0.5) {\n        await this.sendAlert(\n          `Latest backup size is significantly smaller than average: ${latestBackup.size} vs ${avgSize}`,\n          'warning'\n        );\n      }\n\n      // Check backup integrity\n      const integrityChecks = await this.performIntegrityChecks(recentBackups.slice(0, 3));\n      const failedChecks = integrityChecks.filter(check => !check.valid);\n      \n      if (failedChecks.length > 0) {\n        await this.sendAlert(\n          `Backup integrity check failed for: ${failedChecks.map(c => c.backupId).join(', ')}`,\n          'critical'\n        );\n      }\n\n      // Check storage space\n      const storageUsage = await this.checkStorageUsage();\n      if (storageUsage.percentage > 85) {\n        await this.sendAlert(\n          `Backup storage usage is high: ${storageUsage.percentage}%`,\n          'warning'\n        );\n      }\n\n      this.logger.log('Backup health monitoring completed successfully');\n    } catch (error) {\n      this.logger.error('Backup health monitoring failed', error);\n    }\n  }\n\n  private async getRecentBackups(hours: number): Promise<BackupMetadata[]> {\n    // Implementation to get recent backups\n    return [];\n  }\n\n  private calculateAverageSize(backups: BackupMetadata[]): number {\n    if (backups.length === 0) return 0;\n    return backups.reduce((sum, backup) => sum + backup.size, 0) / backups.length;\n  }\n\n  private async performIntegrityChecks(backups: BackupMetadata[]): Promise<Array<{ backupId: string; valid: boolean }>> {\n    // Implementation to check backup integrity\n    return [];\n  }\n\n  private async checkStorageUsage(): Promise<{ used: number; total: number; percentage: number }> {\n    // Implementation to check storage usage\n    return { used: 0, total: 0, percentage: 0 };\n  }\n\n  private async sendAlert(message: string, severity: 'info' | 'warning' | 'critical'): Promise<void> {\n    // Implementation to send alerts (email, Slack, PagerDuty, etc.)\n    this.logger.warn(`BACKUP ALERT [${severity.toUpperCase()}]: ${message}`);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"backup-strategy-guidelines",children:"Backup Strategy Guidelines"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"3-2-1 Rule"}),": 3 copies of data, 2 different media types, 1 offsite"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Regular Testing"}),": Test backup restoration procedures monthly"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Incremental Backups"}),": Use incremental backups to reduce storage costs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encryption"}),": Encrypt backups both in transit and at rest"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Retention Policies"}),": Define clear retention policies based on business requirements"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"recovery-time-and-point-objectives",children:"Recovery Time and Point Objectives"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/config/recovery-objectives.ts\nexport const RECOVERY_OBJECTIVES = {\n  CRITICAL_SERVICES: {\n    RTO: 30, // minutes\n    RPO: 60, // minutes\n  },\n  NORMAL_SERVICES: {\n    RTO: 240, // 4 hours\n    RPO: 360, // 6 hours\n  },\n  DEVELOPMENT_SERVICES: {\n    RTO: 1440, // 24 hours\n    RPO: 2880, // 48 hours\n  },\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-definition/dev-environment-setup",children:"Development Environment Setup"})})," - Development backup procedures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline",children:"CI/CD Pipeline"})})," - Automated backup integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-definition/architecture-foundation",children:"Architecture Foundation"})})," - Infrastructure patterns"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"This backup and recovery strategy should be regularly tested and updated to ensure effectiveness in real disaster scenarios."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);