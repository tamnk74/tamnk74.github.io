"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[9091],{7814:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>s});var t=r(9729);const a={},o=t.createContext(a);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(o.Provider,{value:n},e.children)}},8116:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"architecture-practices/architecture-execution/application-monitoring","title":"Application Performance Monitoring Guide","description":"This guide provides comprehensive application performance monitoring (APM) strategies for NestJS microservices and Next.js microfrontend applications, covering performance optimization, real user monitoring, and automated performance testing.","source":"@site/docs/architecture-practices/architecture-execution/application-monitoring.md","sourceDirName":"architecture-practices/architecture-execution","slug":"/architecture-practices/architecture-execution/application-monitoring","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/application-monitoring","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-execution/application-monitoring.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Infrastructure Monitoring Guide","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/infrastructure-monitoring"},"next":{"title":"Configuration Management Guide","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/configuration-management"}}');var a=r(5813),o=r(7814);const i={},s="Application Performance Monitoring Guide",c={},l=[{value:"Overview",id:"overview",level:2},{value:"APM Architecture",id:"apm-architecture",level:2},{value:"Complete Observability Stack",id:"complete-observability-stack",level:3},{value:"Server-Side APM Implementation",id:"server-side-apm-implementation",level:2},{value:"NestJS Performance Interceptor",id:"nestjs-performance-interceptor",level:3},{value:"Database Query Performance Monitor",id:"database-query-performance-monitor",level:3},{value:"Memory and CPU Profiling",id:"memory-and-cpu-profiling",level:3},{value:"Client-Side Performance Monitoring",id:"client-side-performance-monitoring",level:2},{value:"Next.js Performance Tracking",id:"nextjs-performance-tracking",level:3},{value:"Performance Monitoring Hook",id:"performance-monitoring-hook",level:3},{value:"Synthetic Monitoring",id:"synthetic-monitoring",level:2},{value:"Automated Performance Testing",id:"automated-performance-testing",level:3},{value:"Performance Alerting",id:"performance-alerting",level:2},{value:"Performance-Based Alerts",id:"performance-based-alerts",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance Monitoring Guidelines",id:"performance-monitoring-guidelines",level:3},{value:"Performance Optimization Strategies",id:"performance-optimization-strategies",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"application-performance-monitoring-guide",children:"Application Performance Monitoring Guide"})}),"\n",(0,a.jsx)(n.p,{children:"This guide provides comprehensive application performance monitoring (APM) strategies for NestJS microservices and Next.js microfrontend applications, covering performance optimization, real user monitoring, and automated performance testing."}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"Application Performance Monitoring (APM) ensures optimal user experience by tracking application-level metrics, identifying performance bottlenecks, and enabling proactive optimization. This guide covers both server-side and client-side performance monitoring with actionable insights."}),"\n",(0,a.jsx)(n.h2,{id:"apm-architecture",children:"APM Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"complete-observability-stack",children:"Complete Observability Stack"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[User Browser] --\x3e B[Next.js Frontend]\n    B --\x3e C[API Gateway]\n    C --\x3e D[NestJS Services]\n    D --\x3e E[Database]\n    \n    F[Client-Side APM] --\x3e G[Real User Monitoring]\n    G --\x3e H[Performance Analytics]\n    \n    I[Server-Side APM] --\x3e J[Distributed Tracing]\n    J --\x3e K[Service Mesh]\n    \n    L[Synthetic Monitoring] --\x3e M[Performance Tests]\n    M --\x3e N[Load Testing]\n    \n    O[APM Platform] --\x3e P[New Relic/DataDog]\n    O --\x3e Q[Custom Dashboard]\n    O --\x3e R[Alert System]\n    \n    B --\x3e F\n    D --\x3e I\n    H --\x3e O\n    J --\x3e O\n    N --\x3e O\n"})}),"\n",(0,a.jsx)(n.h2,{id:"server-side-apm-implementation",children:"Server-Side APM Implementation"}),"\n",(0,a.jsx)(n.h3,{id:"nestjs-performance-interceptor",children:"NestJS Performance Interceptor"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// src/interceptors/performance.interceptor.ts\nimport {\n  Injectable,\n  NestInterceptor,\n  ExecutionContext,\n  CallHandler,\n  Logger,\n} from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { tap, catchError } from 'rxjs/operators';\nimport { Request, Response } from 'express';\nimport { PerformanceService } from '../monitoring/performance.service';\n\n@Injectable()\nexport class PerformanceInterceptor implements NestInterceptor {\n  private readonly logger = new Logger(PerformanceInterceptor.name);\n\n  constructor(private readonly performanceService: PerformanceService) {}\n\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    const request = context.switchToHttp().getRequest<Request>();\n    const response = context.switchToHttp().getResponse<Response>();\n    \n    const startTime = Date.now();\n    const startMemory = process.memoryUsage();\n    const startCpuUsage = process.cpuUsage();\n\n    // Extract route information\n    const method = request.method;\n    const route = request.route?.path || request.url;\n    const userAgent = request.headers['user-agent'];\n    const requestId = request.headers['x-request-id'] as string;\n\n    return next.handle().pipe(\n      tap(() => {\n        this.recordPerformanceMetrics(\n          method,\n          route,\n          response.statusCode,\n          startTime,\n          startMemory,\n          startCpuUsage,\n          userAgent,\n          requestId,\n        );\n      }),\n      catchError((error) => {\n        this.recordPerformanceMetrics(\n          method,\n          route,\n          response.statusCode || 500,\n          startTime,\n          startMemory,\n          startCpuUsage,\n          userAgent,\n          requestId,\n          error,\n        );\n        throw error;\n      }),\n    );\n  }\n\n  private recordPerformanceMetrics(\n    method: string,\n    route: string,\n    statusCode: number,\n    startTime: number,\n    startMemory: NodeJS.MemoryUsage,\n    startCpuUsage: NodeJS.CpuUsage,\n    userAgent: string,\n    requestId: string,\n    error?: Error,\n  ): void {\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n    const endMemory = process.memoryUsage();\n    const endCpuUsage = process.cpuUsage(startCpuUsage);\n\n    const performanceData = {\n      method,\n      route,\n      statusCode,\n      duration,\n      memoryUsage: {\n        heapUsed: endMemory.heapUsed - startMemory.heapUsed,\n        heapTotal: endMemory.heapTotal - startMemory.heapTotal,\n        external: endMemory.external - startMemory.external,\n        rss: endMemory.rss - startMemory.rss,\n      },\n      cpuUsage: {\n        user: endCpuUsage.user,\n        system: endCpuUsage.system,\n      },\n      userAgent,\n      requestId,\n      timestamp: new Date(startTime).toISOString(),\n      error: error?.message,\n    };\n\n    // Record metrics\n    this.performanceService.recordRequestPerformance(performanceData);\n\n    // Log slow requests\n    if (duration > 1000) {\n      this.logger.warn(`Slow request detected: ${method} ${route} - ${duration}ms`, {\n        requestId,\n        performanceData,\n      });\n    }\n\n    // Log high memory usage\n    if (performanceData.memoryUsage.heapUsed > 50 * 1024 * 1024) { // 50MB\n      this.logger.warn(`High memory usage detected: ${method} ${route}`, {\n        requestId,\n        memoryUsage: performanceData.memoryUsage,\n      });\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"database-query-performance-monitor",children:"Database Query Performance Monitor"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// src/monitoring/database-performance.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { DataSource, QueryRunner } from 'typeorm';\nimport { Performance } from 'perf_hooks';\n\nexport interface QueryPerformanceData {\n  query: string;\n  parameters: any[];\n  duration: number;\n  rowCount?: number;\n  timestamp: Date;\n  executionPlan?: any;\n  stackTrace?: string;\n}\n\n@Injectable()\nexport class DatabasePerformanceService {\n  private readonly logger = new Logger(DatabasePerformanceService.name);\n  private readonly slowQueryThreshold = 1000; // 1 second\n  private readonly queryPerformanceData: QueryPerformanceData[] = [];\n\n  constructor(private readonly dataSource: DataSource) {\n    this.setupQueryLogging();\n  }\n\n  private setupQueryLogging(): void {\n    // Override the query method to add performance tracking\n    const originalQuery = this.dataSource.query.bind(this.dataSource);\n    \n    this.dataSource.query = async (query: string, parameters?: any[]): Promise<any> => {\n      const startTime = performance.now();\n      const stackTrace = new Error().stack;\n      \n      try {\n        const result = await originalQuery(query, parameters);\n        const duration = performance.now() - startTime;\n        \n        const performanceData: QueryPerformanceData = {\n          query: this.sanitizeQuery(query),\n          parameters: parameters || [],\n          duration,\n          rowCount: Array.isArray(result) ? result.length : undefined,\n          timestamp: new Date(),\n          stackTrace: this.extractRelevantStackTrace(stackTrace),\n        };\n\n        this.recordQueryPerformance(performanceData);\n        \n        return result;\n      } catch (error) {\n        const duration = performance.now() - startTime;\n        \n        this.logger.error(`Query failed after ${duration}ms: ${query}`, {\n          error: error.message,\n          parameters,\n          duration,\n        });\n        \n        throw error;\n      }\n    };\n  }\n\n  private recordQueryPerformance(data: QueryPerformanceData): void {\n    // Store recent query performance data\n    this.queryPerformanceData.push(data);\n    \n    // Keep only last 1000 queries to prevent memory leaks\n    if (this.queryPerformanceData.length > 1000) {\n      this.queryPerformanceData.shift();\n    }\n\n    // Log slow queries\n    if (data.duration > this.slowQueryThreshold) {\n      this.logger.warn(`Slow query detected: ${data.duration}ms`, {\n        query: data.query,\n        parameters: data.parameters,\n        rowCount: data.rowCount,\n        stackTrace: data.stackTrace,\n      });\n\n      // Get execution plan for slow queries\n      this.getExecutionPlan(data.query, data.parameters).then(plan => {\n        if (plan) {\n          this.logger.warn(`Execution plan for slow query:`, plan);\n        }\n      });\n    }\n  }\n\n  async getQueryPerformanceReport(): Promise<{\n    slowQueries: QueryPerformanceData[];\n    averageDuration: number;\n    totalQueries: number;\n    queryPatterns: Record<string, number>;\n  }> {\n    const slowQueries = this.queryPerformanceData.filter(q => q.duration > this.slowQueryThreshold);\n    const averageDuration = this.queryPerformanceData.reduce((sum, q) => sum + q.duration, 0) / this.queryPerformanceData.length;\n    \n    const queryPatterns = this.queryPerformanceData.reduce((patterns, query) => {\n      const pattern = this.extractQueryPattern(query.query);\n      patterns[pattern] = (patterns[pattern] || 0) + 1;\n      return patterns;\n    }, {} as Record<string, number>);\n\n    return {\n      slowQueries: slowQueries.slice(-10), // Last 10 slow queries\n      averageDuration,\n      totalQueries: this.queryPerformanceData.length,\n      queryPatterns,\n    };\n  }\n\n  private async getExecutionPlan(query: string, parameters?: any[]): Promise<any> {\n    try {\n      const explainQuery = `EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) ${query}`;\n      const result = await this.dataSource.query(explainQuery, parameters);\n      return result[0]['QUERY PLAN'];\n    } catch (error) {\n      this.logger.error('Failed to get execution plan', error);\n      return null;\n    }\n  }\n\n  private sanitizeQuery(query: string): string {\n    // Remove sensitive data from query logs\n    return query.replace(/\\$\\d+/g, '?'); // Replace parameter placeholders\n  }\n\n  private extractQueryPattern(query: string): string {\n    // Extract query pattern for grouping similar queries\n    return query\n      .replace(/\\s+/g, ' ')\n      .replace(/\\d+/g, 'N')\n      .replace(/'[^']*'/g, \"'VALUE'\")\n      .trim()\n      .substring(0, 100);\n  }\n\n  private extractRelevantStackTrace(stackTrace?: string): string {\n    if (!stackTrace) return '';\n    \n    const lines = stackTrace.split('\\n');\n    const relevantLines = lines.filter(line => \n      line.includes('src/') && \n      !line.includes('node_modules') &&\n      !line.includes('DatabasePerformanceService')\n    );\n    \n    return relevantLines.slice(0, 3).join('\\n');\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"memory-and-cpu-profiling",children:"Memory and CPU Profiling"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// src/monitoring/profiling.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport * as v8 from 'v8';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport interface ProfileData {\n  timestamp: Date;\n  memoryUsage: NodeJS.MemoryUsage;\n  cpuUsage: NodeJS.CpuUsage;\n  heapStatistics: v8.HeapStatistics;\n  heapSpaceStatistics: v8.HeapSpaceStatistics[];\n  eventLoopDelay?: number;\n}\n\n@Injectable()\nexport class ProfilingService {\n  private readonly logger = new Logger(ProfilingService.name);\n  private readonly profileDataHistory: ProfileData[] = [];\n  private cpuUsageStart: NodeJS.CpuUsage;\n  private eventLoopMonitor?: any;\n\n  constructor() {\n    this.cpuUsageStart = process.cpuUsage();\n    this.initializeEventLoopMonitoring();\n  }\n\n  @Cron(CronExpression.EVERY_30_SECONDS)\n  async collectProfileData(): Promise<void> {\n    try {\n      const profileData: ProfileData = {\n        timestamp: new Date(),\n        memoryUsage: process.memoryUsage(),\n        cpuUsage: process.cpuUsage(this.cpuUsageStart),\n        heapStatistics: v8.getHeapStatistics(),\n        heapSpaceStatistics: v8.getHeapSpaceStatistics(),\n        eventLoopDelay: this.eventLoopMonitor?.delay,\n      };\n\n      this.profileDataHistory.push(profileData);\n\n      // Keep only last 100 records to prevent memory leaks\n      if (this.profileDataHistory.length > 100) {\n        this.profileDataHistory.shift();\n      }\n\n      // Check for memory leaks\n      await this.checkForMemoryLeaks(profileData);\n\n      // Check for high CPU usage\n      this.checkForHighCpuUsage(profileData);\n\n      // Reset CPU usage baseline\n      this.cpuUsageStart = process.cpuUsage();\n    } catch (error) {\n      this.logger.error('Failed to collect profile data', error);\n    }\n  }\n\n  private initializeEventLoopMonitoring(): void {\n    if (typeof require !== 'undefined') {\n      try {\n        const { monitorEventLoopDelay } = require('perf_hooks');\n        this.eventLoopMonitor = monitorEventLoopDelay({ resolution: 20 });\n        this.eventLoopMonitor.enable();\n      } catch (error) {\n        this.logger.warn('Event loop monitoring not available', error);\n      }\n    }\n  }\n\n  private async checkForMemoryLeaks(currentProfile: ProfileData): Promise<void> {\n    if (this.profileDataHistory.length < 10) return; // Need at least 10 data points\n\n    const recentProfiles = this.profileDataHistory.slice(-10);\n    const memoryGrowth = recentProfiles.map(profile => profile.memoryUsage.heapUsed);\n    \n    // Check if memory is consistently growing\n    let consecutiveIncreases = 0;\n    for (let i = 1; i < memoryGrowth.length; i++) {\n      if (memoryGrowth[i] > memoryGrowth[i - 1]) {\n        consecutiveIncreases++;\n      } else {\n        consecutiveIncreases = 0;\n      }\n    }\n\n    if (consecutiveIncreases >= 8) { // 8 consecutive increases\n      this.logger.warn('Potential memory leak detected', {\n        currentHeapUsed: currentProfile.memoryUsage.heapUsed,\n        memoryGrowthPattern: memoryGrowth,\n      });\n\n      // Trigger heap snapshot for analysis\n      await this.createHeapSnapshot();\n    }\n\n    // Check for high memory usage\n    const heapUsedMB = currentProfile.memoryUsage.heapUsed / 1024 / 1024;\n    if (heapUsedMB > 512) { // Alert if heap usage exceeds 512MB\n      this.logger.warn(`High memory usage detected: ${heapUsedMB.toFixed(2)}MB`, {\n        memoryUsage: currentProfile.memoryUsage,\n        heapStatistics: currentProfile.heapStatistics,\n      });\n    }\n  }\n\n  private checkForHighCpuUsage(currentProfile: ProfileData): void {\n    const totalCpuTime = currentProfile.cpuUsage.user + currentProfile.cpuUsage.system;\n    const cpuUsagePercent = (totalCpuTime / 30000000) * 100; // 30 seconds in microseconds\n\n    if (cpuUsagePercent > 80) {\n      this.logger.warn(`High CPU usage detected: ${cpuUsagePercent.toFixed(2)}%`, {\n        cpuUsage: currentProfile.cpuUsage,\n      });\n    }\n\n    // Check event loop delay\n    if (currentProfile.eventLoopDelay && currentProfile.eventLoopDelay > 100) {\n      this.logger.warn(`High event loop delay detected: ${currentProfile.eventLoopDelay}ms`);\n    }\n  }\n\n  private async createHeapSnapshot(): Promise<void> {\n    try {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const filename = `heap-snapshot-${timestamp}.heapsnapshot`;\n      const filepath = path.join(process.cwd(), 'logs', filename);\n\n      // Ensure logs directory exists\n      await fs.mkdir(path.dirname(filepath), { recursive: true });\n\n      // Create heap snapshot\n      const heapSnapshot = v8.getHeapSnapshot();\n      const writeStream = require('fs').createWriteStream(filepath);\n      \n      heapSnapshot.pipe(writeStream);\n\n      this.logger.log(`Heap snapshot created: ${filename}`);\n    } catch (error) {\n      this.logger.error('Failed to create heap snapshot', error);\n    }\n  }\n\n  async getProfileReport(): Promise<{\n    current: ProfileData;\n    averages: {\n      memoryUsage: number;\n      cpuUsagePercent: number;\n      eventLoopDelay: number;\n    };\n    trends: {\n      memoryTrend: 'increasing' | 'decreasing' | 'stable';\n      cpuTrend: 'increasing' | 'decreasing' | 'stable';\n    };\n  }> {\n    const current = this.profileDataHistory[this.profileDataHistory.length - 1];\n    \n    if (!current) {\n      throw new Error('No profile data available');\n    }\n\n    const recentProfiles = this.profileDataHistory.slice(-20); // Last 20 samples\n    \n    const averageMemory = recentProfiles.reduce((sum, p) => sum + p.memoryUsage.heapUsed, 0) / recentProfiles.length;\n    const averageCpuPercent = recentProfiles.reduce((sum, p) => {\n      const totalCpu = p.cpuUsage.user + p.cpuUsage.system;\n      return sum + (totalCpu / 30000000) * 100;\n    }, 0) / recentProfiles.length;\n    const averageEventLoopDelay = recentProfiles.reduce((sum, p) => sum + (p.eventLoopDelay || 0), 0) / recentProfiles.length;\n\n    // Calculate trends\n    const memoryTrend = this.calculateTrend(recentProfiles.map(p => p.memoryUsage.heapUsed));\n    const cpuTrend = this.calculateTrend(recentProfiles.map(p => p.cpuUsage.user + p.cpuUsage.system));\n\n    return {\n      current,\n      averages: {\n        memoryUsage: averageMemory,\n        cpuUsagePercent: averageCpuPercent,\n        eventLoopDelay: averageEventLoopDelay,\n      },\n      trends: {\n        memoryTrend,\n        cpuTrend,\n      },\n    };\n  }\n\n  private calculateTrend(values: number[]): 'increasing' | 'decreasing' | 'stable' {\n    if (values.length < 2) return 'stable';\n\n    const first = values.slice(0, Math.floor(values.length / 2));\n    const second = values.slice(Math.floor(values.length / 2));\n\n    const firstAvg = first.reduce((sum, val) => sum + val, 0) / first.length;\n    const secondAvg = second.reduce((sum, val) => sum + val, 0) / second.length;\n\n    const changePercent = ((secondAvg - firstAvg) / firstAvg) * 100;\n\n    if (changePercent > 10) return 'increasing';\n    if (changePercent < -10) return 'decreasing';\n    return 'stable';\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"client-side-performance-monitoring",children:"Client-Side Performance Monitoring"}),"\n",(0,a.jsx)(n.h3,{id:"nextjs-performance-tracking",children:"Next.js Performance Tracking"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// lib/performance/client-performance.ts\nimport { NextWebVitalsMetric } from 'next/app';\n\nexport interface ClientPerformanceMetric {\n  id: string;\n  name: string;\n  value: number;\n  delta?: number;\n  rating: 'good' | 'needs-improvement' | 'poor';\n  navigationType: string;\n  url: string;\n  timestamp: number;\n  userAgent: string;\n  connectionType?: string;\n  deviceMemory?: number;\n}\n\nclass ClientPerformanceTracker {\n  private metrics: ClientPerformanceMetric[] = [];\n  private sessionId: string;\n  private userId?: string;\n\n  constructor() {\n    this.sessionId = this.generateSessionId();\n    this.initializePerformanceObserver();\n    this.trackPageVisibility();\n    this.trackUserInteractions();\n  }\n\n  setUserId(userId: string): void {\n    this.userId = userId;\n  }\n\n  // Track Core Web Vitals\n  trackWebVital(metric: NextWebVitalsMetric): void {\n    const performanceMetric: ClientPerformanceMetric = {\n      id: metric.id,\n      name: metric.name,\n      value: metric.value,\n      delta: metric.delta,\n      rating: this.getMetricRating(metric.name, metric.value),\n      navigationType: this.getNavigationType(),\n      url: window.location.href,\n      timestamp: Date.now(),\n      userAgent: navigator.userAgent,\n      connectionType: this.getConnectionType(),\n      deviceMemory: this.getDeviceMemory(),\n    };\n\n    this.metrics.push(performanceMetric);\n    this.sendMetric(performanceMetric);\n\n    // Log poor performance\n    if (performanceMetric.rating === 'poor') {\n      console.warn(`Poor ${metric.name} performance:`, {\n        value: metric.value,\n        url: window.location.href,\n      });\n    }\n  }\n\n  // Track custom performance metrics\n  trackCustomMetric(name: string, value: number, metadata?: Record<string, any>): void {\n    const metric: ClientPerformanceMetric = {\n      id: this.generateMetricId(),\n      name,\n      value,\n      rating: 'good', // Custom metrics don't have predefined thresholds\n      navigationType: this.getNavigationType(),\n      url: window.location.href,\n      timestamp: Date.now(),\n      userAgent: navigator.userAgent,\n      ...metadata,\n    };\n\n    this.metrics.push(metric);\n    this.sendMetric(metric);\n  }\n\n  // Track resource loading performance\n  private initializePerformanceObserver(): void {\n    if ('PerformanceObserver' in window) {\n      // Track resource timing\n      const resourceObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'resource') {\n            this.trackResourceTiming(entry as PerformanceResourceTiming);\n          }\n        }\n      });\n      resourceObserver.observe({ entryTypes: ['resource'] });\n\n      // Track navigation timing\n      const navigationObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'navigation') {\n            this.trackNavigationTiming(entry as PerformanceNavigationTiming);\n          }\n        }\n      });\n      navigationObserver.observe({ entryTypes: ['navigation'] });\n\n      // Track long tasks\n      const longTaskObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          this.trackLongTask(entry);\n        }\n      });\n      longTaskObserver.observe({ entryTypes: ['longtask'] });\n    }\n  }\n\n  private trackResourceTiming(entry: PerformanceResourceTiming): void {\n    const loadTime = entry.responseEnd - entry.requestStart;\n    \n    // Track slow resources\n    if (loadTime > 1000) { // More than 1 second\n      this.trackCustomMetric('slow_resource_load', loadTime, {\n        resourceName: entry.name,\n        resourceType: this.getResourceType(entry.name),\n        transferSize: entry.transferSize,\n        encodedBodySize: entry.encodedBodySize,\n      });\n    }\n\n    // Track failed resources\n    if (entry.responseStatus >= 400) {\n      this.trackCustomMetric('resource_error', entry.responseStatus, {\n        resourceName: entry.name,\n        resourceType: this.getResourceType(entry.name),\n      });\n    }\n  }\n\n  private trackNavigationTiming(entry: PerformanceNavigationTiming): void {\n    const metrics = {\n      dns_lookup: entry.domainLookupEnd - entry.domainLookupStart,\n      tcp_connection: entry.connectEnd - entry.connectStart,\n      ssl_handshake: entry.connectEnd - entry.secureConnectionStart,\n      ttfb: entry.responseStart - entry.requestStart,\n      dom_content_loaded: entry.domContentLoadedEventEnd - entry.navigationStart,\n      load_complete: entry.loadEventEnd - entry.navigationStart,\n    };\n\n    for (const [name, value] of Object.entries(metrics)) {\n      if (value > 0) {\n        this.trackCustomMetric(`navigation_${name}`, value);\n      }\n    }\n  }\n\n  private trackLongTask(entry: PerformanceEntry): void {\n    this.trackCustomMetric('long_task', entry.duration, {\n      taskType: (entry as any).name,\n      startTime: entry.startTime,\n    });\n  }\n\n  private trackPageVisibility(): void {\n    let visibilityStart = Date.now();\n    let isVisible = !document.hidden;\n\n    const handleVisibilityChange = () => {\n      const now = Date.now();\n      \n      if (document.hidden && isVisible) {\n        // Page became hidden\n        const visibleDuration = now - visibilityStart;\n        this.trackCustomMetric('page_visible_duration', visibleDuration);\n        isVisible = false;\n      } else if (!document.hidden && !isVisible) {\n        // Page became visible\n        visibilityStart = now;\n        isVisible = true;\n      }\n    };\n\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Track time on page when leaving\n    window.addEventListener('beforeunload', () => {\n      if (isVisible) {\n        const visibleDuration = Date.now() - visibilityStart;\n        this.trackCustomMetric('page_visible_duration', visibleDuration);\n      }\n    });\n  }\n\n  private trackUserInteractions(): void {\n    const interactionStart = Date.now();\n\n    // Track input delay\n    ['click', 'keydown', 'touchstart'].forEach(eventType => {\n      document.addEventListener(eventType, (event) => {\n        const interactionDelay = Date.now() - interactionStart;\n        \n        if (interactionDelay > 100) { // More than 100ms\n          this.trackCustomMetric('interaction_delay', interactionDelay, {\n            eventType,\n            targetElement: (event.target as Element)?.tagName,\n          });\n        }\n      }, { passive: true });\n    });\n\n    // Track scroll performance\n    let scrollStart = 0;\n    let scrollCount = 0;\n    \n    window.addEventListener('scroll', () => {\n      if (scrollStart === 0) {\n        scrollStart = performance.now();\n      }\n      scrollCount++;\n    }, { passive: true });\n\n    // Debounced scroll end detection\n    let scrollTimeout: NodeJS.Timeout;\n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = setTimeout(() => {\n        if (scrollStart > 0) {\n          const scrollDuration = performance.now() - scrollStart;\n          this.trackCustomMetric('scroll_session', scrollDuration, {\n            scrollCount,\n          });\n          scrollStart = 0;\n          scrollCount = 0;\n        }\n      }, 150);\n    }, { passive: true });\n  }\n\n  private async sendMetric(metric: ClientPerformanceMetric): Promise<void> {\n    try {\n      // Use sendBeacon for reliability, fallback to fetch\n      const data = JSON.stringify({\n        ...metric,\n        sessionId: this.sessionId,\n        userId: this.userId,\n      });\n\n      if (navigator.sendBeacon) {\n        navigator.sendBeacon('/api/metrics/performance', data);\n      } else {\n        fetch('/api/metrics/performance', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: data,\n        }).catch(error => {\n          console.error('Failed to send performance metric:', error);\n        });\n      }\n    } catch (error) {\n      console.error('Error sending performance metric:', error);\n    }\n  }\n\n  private getMetricRating(name: string, value: number): 'good' | 'needs-improvement' | 'poor' {\n    const thresholds = {\n      CLS: { good: 0.1, poor: 0.25 },\n      FID: { good: 100, poor: 300 },\n      FCP: { good: 1800, poor: 3000 },\n      LCP: { good: 2500, poor: 4000 },\n      TTFB: { good: 800, poor: 1800 },\n    };\n\n    const threshold = thresholds[name as keyof typeof thresholds];\n    if (!threshold) return 'good';\n\n    if (value <= threshold.good) return 'good';\n    if (value <= threshold.poor) return 'needs-improvement';\n    return 'poor';\n  }\n\n  private getNavigationType(): string {\n    if ('navigation' in performance) {\n      const navigation = performance.navigation;\n      const types = ['navigate', 'reload', 'back_forward', 'prerender'];\n      return types[navigation.type] || 'unknown';\n    }\n    return 'unknown';\n  }\n\n  private getConnectionType(): string | undefined {\n    const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection;\n    return connection?.effectiveType;\n  }\n\n  private getDeviceMemory(): number | undefined {\n    return (navigator as any).deviceMemory;\n  }\n\n  private getResourceType(url: string): string {\n    const extension = url.split('.').pop()?.toLowerCase();\n    \n    if (['js', 'mjs'].includes(extension || '')) return 'script';\n    if (['css'].includes(extension || '')) return 'stylesheet';\n    if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp'].includes(extension || '')) return 'image';\n    if (['woff', 'woff2', 'ttf', 'eot'].includes(extension || '')) return 'font';\n    if (url.includes('/api/')) return 'api';\n    \n    return 'other';\n  }\n\n  private generateSessionId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateMetricId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  // Get performance summary\n  getPerformanceSummary(): {\n    totalMetrics: number;\n    poorPerformanceCount: number;\n    averageLoadTime: number;\n    topIssues: Array<{ name: string; count: number; avgValue: number }>;\n  } {\n    const poorMetrics = this.metrics.filter(m => m.rating === 'poor');\n    \n    const issueGroups = this.metrics.reduce((groups, metric) => {\n      if (metric.rating === 'poor') {\n        const key = metric.name;\n        if (!groups[key]) {\n          groups[key] = { name: key, count: 0, totalValue: 0 };\n        }\n        groups[key].count++;\n        groups[key].totalValue += metric.value;\n      }\n      return groups;\n    }, {} as Record<string, { name: string; count: number; totalValue: number }>);\n\n    const topIssues = Object.values(issueGroups)\n      .map(group => ({\n        name: group.name,\n        count: group.count,\n        avgValue: group.totalValue / group.count,\n      }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 5);\n\n    const loadTimeMetrics = this.metrics.filter(m => m.name === 'LCP' || m.name === 'FCP');\n    const averageLoadTime = loadTimeMetrics.length > 0 \n      ? loadTimeMetrics.reduce((sum, m) => sum + m.value, 0) / loadTimeMetrics.length \n      : 0;\n\n    return {\n      totalMetrics: this.metrics.length,\n      poorPerformanceCount: poorMetrics.length,\n      averageLoadTime,\n      topIssues,\n    };\n  }\n}\n\nexport const clientPerformanceTracker = new ClientPerformanceTracker();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"performance-monitoring-hook",children:"Performance Monitoring Hook"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// hooks/use-performance-monitoring.ts\nimport { useEffect } from 'react';\nimport { useRouter } from 'next/router';\nimport { clientPerformanceTracker } from '../lib/performance/client-performance';\n\nexport const usePerformanceMonitoring = (userId?: string) => {\n  const router = useRouter();\n\n  useEffect(() => {\n    if (userId) {\n      clientPerformanceTracker.setUserId(userId);\n    }\n\n    // Track route changes\n    const handleRouteChangeStart = (url: string) => {\n      const startTime = performance.now();\n      \n      const handleRouteChangeComplete = () => {\n        const loadTime = performance.now() - startTime;\n        clientPerformanceTracker.trackCustomMetric('route_change_duration', loadTime, {\n          route: url,\n        });\n        router.events.off('routeChangeComplete', handleRouteChangeComplete);\n      };\n      \n      router.events.on('routeChangeComplete', handleRouteChangeComplete);\n    };\n\n    router.events.on('routeChangeStart', handleRouteChangeStart);\n\n    return () => {\n      router.events.off('routeChangeStart', handleRouteChangeStart);\n    };\n  }, [router, userId]);\n\n  // Manual performance tracking functions\n  const trackCustomMetric = (name: string, value: number, metadata?: Record<string, any>) => {\n    clientPerformanceTracker.trackCustomMetric(name, value, metadata);\n  };\n\n  const trackUserAction = (action: string, component: string, duration?: number) => {\n    clientPerformanceTracker.trackCustomMetric('user_action', duration || 1, {\n      action,\n      component,\n      url: window.location.pathname,\n    });\n  };\n\n  const trackApiCall = (endpoint: string, method: string, duration: number, status: number) => {\n    clientPerformanceTracker.trackCustomMetric('api_call_duration', duration, {\n      endpoint,\n      method,\n      status,\n    });\n  };\n\n  return {\n    trackCustomMetric,\n    trackUserAction,\n    trackApiCall,\n    getPerformanceSummary: () => clientPerformanceTracker.getPerformanceSummary(),\n  };\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"synthetic-monitoring",children:"Synthetic Monitoring"}),"\n",(0,a.jsx)(n.h3,{id:"automated-performance-testing",children:"Automated Performance Testing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// scripts/performance-tests.ts\nimport puppeteer from 'puppeteer';\nimport lighthouse from 'lighthouse';\n\ninterface PerformanceTestResult {\n  url: string;\n  timestamp: Date;\n  metrics: {\n    firstContentfulPaint: number;\n    largestContentfulPaint: number;\n    firstInputDelay: number;\n    cumulativeLayoutShift: number;\n    speedIndex: number;\n    timeToInteractive: number;\n  };\n  scores: {\n    performance: number;\n    accessibility: number;\n    bestPractices: number;\n    seo: number;\n  };\n  opportunities: Array<{\n    id: string;\n    title: string;\n    description: string;\n    score: number;\n  }>;\n}\n\nclass PerformanceTester {\n  private browser?: puppeteer.Browser;\n\n  async initialize(): Promise<void> {\n    this.browser = await puppeteer.launch({\n      headless: true,\n      args: ['--no-sandbox', '--disable-setuid-sandbox'],\n    });\n  }\n\n  async runPerformanceTest(url: string): Promise<PerformanceTestResult> {\n    if (!this.browser) {\n      await this.initialize();\n    }\n\n    const page = await this.browser!.newPage();\n    \n    try {\n      // Configure page for performance testing\n      await page.setCacheEnabled(false);\n      await page.setViewport({ width: 1920, height: 1080 });\n\n      // Run Lighthouse audit\n      const { lhr } = await lighthouse(url, {\n        port: new URL(this.browser!.wsEndpoint()).port,\n        onlyCategories: ['performance', 'accessibility', 'best-practices', 'seo'],\n        settings: {\n          preset: 'desktop',\n        },\n      });\n\n      const metrics = lhr.audits;\n      \n      return {\n        url,\n        timestamp: new Date(),\n        metrics: {\n          firstContentfulPaint: metrics['first-contentful-paint'].numericValue || 0,\n          largestContentfulPaint: metrics['largest-contentful-paint'].numericValue || 0,\n          firstInputDelay: metrics['max-potential-fid'].numericValue || 0,\n          cumulativeLayoutShift: metrics['cumulative-layout-shift'].numericValue || 0,\n          speedIndex: metrics['speed-index'].numericValue || 0,\n          timeToInteractive: metrics['interactive'].numericValue || 0,\n        },\n        scores: {\n          performance: (lhr.categories.performance?.score || 0) * 100,\n          accessibility: (lhr.categories.accessibility?.score || 0) * 100,\n          bestPractices: (lhr.categories['best-practices']?.score || 0) * 100,\n          seo: (lhr.categories.seo?.score || 0) * 100,\n        },\n        opportunities: Object.values(lhr.audits)\n          .filter(audit => audit.scoreDisplayMode === 'numeric' && audit.score !== null && audit.score < 0.9)\n          .map(audit => ({\n            id: audit.id,\n            title: audit.title,\n            description: audit.description,\n            score: audit.score || 0,\n          }))\n          .sort((a, b) => a.score - b.score),\n      };\n    } finally {\n      await page.close();\n    }\n  }\n\n  async runLoadTest(url: string, concurrency: number = 10, duration: number = 60): Promise<{\n    averageResponseTime: number;\n    requestsPerSecond: number;\n    errorRate: number;\n    p95ResponseTime: number;\n  }> {\n    const results: Array<{ duration: number; success: boolean }> = [];\n    const startTime = Date.now();\n    const endTime = startTime + (duration * 1000);\n\n    const runRequest = async (): Promise<void> => {\n      while (Date.now() < endTime) {\n        const requestStart = Date.now();\n        \n        try {\n          const page = await this.browser!.newPage();\n          await page.goto(url, { waitUntil: 'networkidle0' });\n          await page.close();\n          \n          results.push({\n            duration: Date.now() - requestStart,\n            success: true,\n          });\n        } catch (error) {\n          results.push({\n            duration: Date.now() - requestStart,\n            success: false,\n          });\n        }\n      }\n    };\n\n    // Run concurrent requests\n    const promises = Array(concurrency).fill(null).map(() => runRequest());\n    await Promise.all(promises);\n\n    // Calculate metrics\n    const successfulResults = results.filter(r => r.success);\n    const totalDuration = (Date.now() - startTime) / 1000;\n    \n    const averageResponseTime = successfulResults.length > 0 \n      ? successfulResults.reduce((sum, r) => sum + r.duration, 0) / successfulResults.length \n      : 0;\n    \n    const requestsPerSecond = results.length / totalDuration;\n    const errorRate = (results.length - successfulResults.length) / results.length;\n    \n    const sortedDurations = successfulResults.map(r => r.duration).sort((a, b) => a - b);\n    const p95Index = Math.floor(sortedDurations.length * 0.95);\n    const p95ResponseTime = sortedDurations[p95Index] || 0;\n\n    return {\n      averageResponseTime,\n      requestsPerSecond,\n      errorRate,\n      p95ResponseTime,\n    };\n  }\n\n  async close(): Promise<void> {\n    if (this.browser) {\n      await this.browser.close();\n    }\n  }\n}\n\n// Usage example\nexport async function runPerformanceTestSuite(): Promise<void> {\n  const tester = new PerformanceTester();\n  \n  const urls = [\n    'https://app.example.com',\n    'https://app.example.com/dashboard',\n    'https://app.example.com/profile',\n  ];\n\n  try {\n    for (const url of urls) {\n      console.log(`Testing ${url}...`);\n      \n      // Performance audit\n      const performanceResult = await tester.runPerformanceTest(url);\n      console.log(`Performance Score: ${performanceResult.scores.performance}`);\n      console.log(`LCP: ${performanceResult.metrics.largestContentfulPaint}ms`);\n      \n      // Load test\n      const loadResult = await tester.runLoadTest(url, 5, 30);\n      console.log(`Average Response Time: ${loadResult.averageResponseTime}ms`);\n      console.log(`Requests/sec: ${loadResult.requestsPerSecond}`);\n      \n      // Report issues\n      if (performanceResult.opportunities.length > 0) {\n        console.log('Performance Opportunities:');\n        performanceResult.opportunities.slice(0, 3).forEach(opp => {\n          console.log(`- ${opp.title} (Score: ${opp.score})`);\n        });\n      }\n    }\n  } finally {\n    await tester.close();\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-alerting",children:"Performance Alerting"}),"\n",(0,a.jsx)(n.h3,{id:"performance-based-alerts",children:"Performance-Based Alerts"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'# monitoring/rules/performance.yml\ngroups:\n- name: application-performance\n  rules:\n  - alert: HighResponseTime\n    expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2\n    for: 5m\n    labels:\n      severity: warning\n    annotations:\n      summary: "High application response time"\n      description: "95th percentile response time is {{ $value }}s for {{ $labels.service }}"\n\n  - alert: HighErrorRate\n    expr: rate(http_requests_total{status_code=~"5.."}[5m]) / rate(http_requests_total[5m]) > 0.05\n    for: 2m\n    labels:\n      severity: critical\n    annotations:\n      summary: "High error rate detected"\n      description: "Error rate is {{ $value | humanizePercentage }} for {{ $labels.service }}"\n\n  - alert: SlowDatabaseQueries\n    expr: avg(query_duration_seconds) > 1\n    for: 3m\n    labels:\n      severity: warning\n    annotations:\n      summary: "Slow database queries detected"\n      description: "Average query duration is {{ $value }}s"\n\n  - alert: MemoryLeakDetected\n    expr: increase(process_resident_memory_bytes[1h]) > 100000000\n    for: 15m\n    labels:\n      severity: critical\n    annotations:\n      summary: "Potential memory leak detected"\n      description: "Memory usage increased by {{ $value | humanizeBytes }} in the last hour"\n\n  - alert: HighCPUUsage\n    expr: rate(process_cpu_seconds_total[5m]) > 0.8\n    for: 10m\n    labels:\n      severity: warning\n    annotations:\n      summary: "High CPU usage detected"\n      description: "CPU usage is {{ $value | humanizePercentage }} for {{ $labels.service }}"\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"performance-monitoring-guidelines",children:"Performance Monitoring Guidelines"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Baseline Establishment"}),": Record performance baselines for comparison"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Real User Monitoring"}),": Combine synthetic and real user data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Progressive Enhancement"}),": Monitor impact of code changes on performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"User-Centric Metrics"}),": Focus on metrics that affect user experience"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Proactive Optimization"}),": Use monitoring data to guide optimization efforts"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"performance-optimization-strategies",children:"Performance Optimization Strategies"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Performance optimization helpers\nexport const PERFORMANCE_OPTIMIZATIONS = {\n  // Database query optimization\n  DATABASE: {\n    connectionPooling: true,\n    queryOptimization: true,\n    indexOptimization: true,\n    caching: true,\n  },\n  \n  // Frontend optimization\n  FRONTEND: {\n    codesplitting: true,\n    imageOptimization: true,\n    bundleOptimization: true,\n    caching: true,\n  },\n  \n  // API optimization\n  API: {\n    responseCompression: true,\n    requestBatching: true,\n    caching: true,\n    rateLimiting: true,\n  },\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/infrastructure-monitoring",children:"Infrastructure Monitoring"})})," - System-level monitoring and alerting"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline",children:"CI/CD Pipeline"})})," - Performance testing in CI/CD"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-definition/code-quality-tools",children:"Code Quality Tools"})})," - Performance linting and analysis"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"This application performance monitoring guide should be regularly updated to incorporate new performance metrics and optimization techniques."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);