"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[8519],{1854:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>g,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"security-practices/security-implementation/sensitive-data-protection","title":"Sensitive System Data Protection Implementation","description":"Overview","source":"@site/docs/security-practices/security-implementation/sensitive-data-protection.md","sourceDirName":"security-practices/security-implementation","slug":"/security-practices/security-implementation/sensitive-data-protection","permalink":"/fullstack-dev/docs/security-practices/security-implementation/sensitive-data-protection","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/security-practices/security-implementation/sensitive-data-protection.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Personal Identifiable Information (PII) Protection Implementation","permalink":"/fullstack-dev/docs/security-practices/security-implementation/pii-protection"},"next":{"title":"Log Data Security Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/log-data-security"}}');var s=t(5813),a=t(7814);const i={},c="Sensitive System Data Protection Implementation",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Google Secret Manager Integration",id:"google-secret-manager-integration",level:2},{value:"1. Secret Manager Service",id:"1-secret-manager-service",level:3},{value:"2. Configuration Service with Secret Manager",id:"2-configuration-service-with-secret-manager",level:3},{value:"Kubernetes Secrets Management",id:"kubernetes-secrets-management",level:2},{value:"1. Secret Store CSI Driver Configuration",id:"1-secret-store-csi-driver-configuration",level:3},{value:"2. Deployment with Secret Volumes",id:"2-deployment-with-secret-volumes",level:3},{value:"3. Workload Identity Configuration",id:"3-workload-identity-configuration",level:3},{value:"Key Rotation Strategies",id:"key-rotation-strategies",level:2},{value:"1. Automated Key Rotation Service",id:"1-automated-key-rotation-service",level:3},{value:"2. Database Password Rotation",id:"2-database-password-rotation",level:3},{value:"Environment-Based Configuration",id:"environment-based-configuration",level:2},{value:"1. Configuration Factory",id:"1-configuration-factory",level:3},{value:"2. Environment Validation",id:"2-environment-validation",level:3},{value:"Secret Scanning and Detection",id:"secret-scanning-and-detection",level:2},{value:"1. Pre-commit Hook for Secret Scanning",id:"1-pre-commit-hook-for-secret-scanning",level:3},{value:"2. CI/CD Secret Scanning",id:"2-cicd-secret-scanning",level:3},{value:"3. Runtime Secret Detection",id:"3-runtime-secret-detection",level:3},{value:"Audit and Monitoring",id:"audit-and-monitoring",level:2},{value:"1. Secret Access Logging",id:"1-secret-access-logging",level:3},{value:"2. Monitoring and Alerting",id:"2-monitoring-and-alerting",level:3},{value:"Testing",id:"testing",level:2},{value:"1. Secret Management Tests",id:"1-secret-management-tests",level:3},{value:"Deployment Checklist",id:"deployment-checklist",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"sensitive-system-data-protection-implementation",children:"Sensitive System Data Protection Implementation"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This document provides implementation guidelines for protecting sensitive system data including connection strings, cryptographic keys, API tokens, and other critical infrastructure secrets in NestJS/Next.js applications on GCP Kubernetes."}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#google-secret-manager-integration",children:"Google Secret Manager Integration"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#kubernetes-secrets-management",children:"Kubernetes Secrets Management"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#key-rotation-strategies",children:"Key Rotation Strategies"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#environment-based-configuration",children:"Environment-Based Configuration"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#secret-scanning-and-detection",children:"Secret Scanning and Detection"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#audit-and-monitoring",children:"Audit and Monitoring"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"google-secret-manager-integration",children:"Google Secret Manager Integration"}),"\n",(0,s.jsx)(n.h3,{id:"1-secret-manager-service",children:"1. Secret Manager Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/config/secret-manager.service.ts\nimport { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { SecretManagerServiceClient } from '@google-cloud/secret-manager';\n\n@Injectable()\nexport class SecretManagerService implements OnModuleInit {\n  private readonly logger = new Logger(SecretManagerService.name);\n  private client: SecretManagerServiceClient;\n  private projectId: string;\n\n  constructor() {\n    this.projectId = process.env.GCP_PROJECT_ID || '';\n    this.client = new SecretManagerServiceClient();\n  }\n\n  async onModuleInit() {\n    this.logger.log('Initializing Secret Manager Service');\n    await this.validateConnection();\n  }\n\n  async getSecret(secretName: string, version: string = 'latest'): Promise<string> {\n    try {\n      const secretPath = `projects/${this.projectId}/secrets/${secretName}/versions/${version}`;\n      \n      const [accessResponse] = await this.client.accessSecretVersion({\n        name: secretPath,\n      });\n\n      const secretValue = accessResponse.payload?.data?.toString();\n      if (!secretValue) {\n        throw new Error(`Secret ${secretName} is empty or undefined`);\n      }\n\n      this.logger.debug(`Successfully retrieved secret: ${secretName}`);\n      return secretValue;\n    } catch (error) {\n      this.logger.error(`Failed to retrieve secret ${secretName}:`, error);\n      throw new Error(`Failed to retrieve secret: ${secretName}`);\n    }\n  }\n\n  async createSecret(secretName: string, secretValue: string): Promise<void> {\n    try {\n      // Create the secret\n      await this.client.createSecret({\n        parent: `projects/${this.projectId}`,\n        secretId: secretName,\n        secret: {\n          replication: {\n            automatic: {},\n          },\n        },\n      });\n\n      // Add the secret version\n      await this.client.addSecretVersion({\n        parent: `projects/${this.projectId}/secrets/${secretName}`,\n        payload: {\n          data: Buffer.from(secretValue, 'utf8'),\n        },\n      });\n\n      this.logger.log(`Secret ${secretName} created successfully`);\n    } catch (error) {\n      this.logger.error(`Failed to create secret ${secretName}:`, error);\n      throw error;\n    }\n  }\n\n  async updateSecret(secretName: string, secretValue: string): Promise<void> {\n    try {\n      await this.client.addSecretVersion({\n        parent: `projects/${this.projectId}/secrets/${secretName}`,\n        payload: {\n          data: Buffer.from(secretValue, 'utf8'),\n        },\n      });\n\n      this.logger.log(`Secret ${secretName} updated successfully`);\n    } catch (error) {\n      this.logger.error(`Failed to update secret ${secretName}:`, error);\n      throw error;\n    }\n  }\n\n  async listSecrets(): Promise<string[]> {\n    try {\n      const [secrets] = await this.client.listSecrets({\n        parent: `projects/${this.projectId}`,\n      });\n\n      return secrets.map(secret => secret.name?.split('/').pop() || '');\n    } catch (error) {\n      this.logger.error('Failed to list secrets:', error);\n      throw error;\n    }\n  }\n\n  private async validateConnection(): Promise<void> {\n    try {\n      await this.client.listSecrets({\n        parent: `projects/${this.projectId}`,\n        pageSize: 1,\n      });\n      this.logger.log('Secret Manager connection validated');\n    } catch (error) {\n      this.logger.error('Failed to validate Secret Manager connection:', error);\n      throw error;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-configuration-service-with-secret-manager",children:"2. Configuration Service with Secret Manager"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/config/config.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { SecretManagerService } from './secret-manager.service';\n\n@Injectable()\nexport class ConfigService {\n  private secrets: Map<string, string> = new Map();\n\n  constructor(private secretManager: SecretManagerService) {}\n\n  async loadSecrets(): Promise<void> {\n    const secretNames = [\n      'database-password',\n      'jwt-secret',\n      'api-key-stripe',\n      'api-key-sendgrid',\n      'encryption-key',\n      'session-secret'\n    ];\n\n    for (const secretName of secretNames) {\n      try {\n        const secretValue = await this.secretManager.getSecret(secretName);\n        this.secrets.set(secretName, secretValue);\n      } catch (error) {\n        console.error(`Failed to load secret ${secretName}:`, error);\n        // Use environment variable as fallback\n        const envValue = process.env[secretName.toUpperCase().replace(/-/g, '_')];\n        if (envValue) {\n          this.secrets.set(secretName, envValue);\n        }\n      }\n    }\n  }\n\n  get(key: string): string {\n    const value = this.secrets.get(key) || process.env[key];\n    if (!value) {\n      throw new Error(`Configuration value for ${key} not found`);\n    }\n    return value;\n  }\n\n  getDatabaseConfig() {\n    return {\n      host: this.get('DB_HOST'),\n      port: parseInt(this.get('DB_PORT')),\n      username: this.get('DB_USERNAME'),\n      password: this.get('database-password'),\n      database: this.get('DB_NAME'),\n    };\n  }\n\n  getJwtConfig() {\n    return {\n      secret: this.get('jwt-secret'),\n      expiresIn: this.get('JWT_EXPIRES_IN') || '1h',\n    };\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"kubernetes-secrets-management",children:"Kubernetes Secrets Management"}),"\n",(0,s.jsx)(n.h3,{id:"1-secret-store-csi-driver-configuration",children:"1. Secret Store CSI Driver Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# k8s/secret-store-csi.yaml\napiVersion: v1\nkind: SecretProviderClass\nmetadata:\n  name: app-secrets\n  namespace: default\nspec:\n  provider: gcp\n  parameters:\n    secrets: |\n      - resourceName: "projects/PROJECT_ID/secrets/database-password/versions/latest"\n        path: "database-password"\n      - resourceName: "projects/PROJECT_ID/secrets/jwt-secret/versions/latest"\n        path: "jwt-secret"\n      - resourceName: "projects/PROJECT_ID/secrets/api-key-stripe/versions/latest"\n        path: "api-key-stripe"\n      - resourceName: "projects/PROJECT_ID/secrets/encryption-key/versions/latest"\n        path: "encryption-key"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-deployment-with-secret-volumes",children:"2. Deployment with Secret Volumes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# k8s/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ecom-api\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: ecom-api\n  template:\n    metadata:\n      labels:\n        app: ecom-api\n    spec:\n      serviceAccountName: workload-identity-sa\n      containers:\n      - name: api\n        image: gcr.io/PROJECT_ID/ecom-api:latest\n        env:\n        - name: DB_HOST\n          value: "localhost"\n        - name: DB_PORT\n          value: "5432"\n        - name: DB_USERNAME\n          value: "app_user"\n        - name: NODE_ENV\n          value: "production"\n        volumeMounts:\n        - name: secrets-store\n          mountPath: "/mnt/secrets"\n          readOnly: true\n        ports:\n        - containerPort: 3000\n      volumes:\n      - name: secrets-store\n        csi:\n          driver: secrets-store.csi.k8s.io\n          readOnly: true\n          volumeAttributes:\n            secretProviderClass: "app-secrets"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-workload-identity-configuration",children:"3. Workload Identity Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# k8s/workload-identity.yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: workload-identity-sa\n  namespace: default\n  annotations:\n    iam.gke.io/gcp-service-account: secret-accessor@PROJECT_ID.iam.gserviceaccount.com\n\n---\napiVersion: iam.cnrm.cloud.google.com/v1beta1\nkind: IAMServiceAccount\nmetadata:\n  name: secret-accessor\nspec:\n  displayName: "Secret Accessor Service Account"\n\n---\napiVersion: iam.cnrm.cloud.google.com/v1beta1\nkind: IAMPolicy\nmetadata:\n  name: secret-accessor-policy\nspec:\n  resourceRef:\n    apiVersion: secretmanager.cnrm.cloud.google.com/v1beta1\n    kind: Secret\n    name: database-password\n  bindings:\n  - role: roles/secretmanager.secretAccessor\n    members:\n    - serviceAccount:secret-accessor@PROJECT_ID.iam.gserviceaccount.com\n'})}),"\n",(0,s.jsx)(n.h2,{id:"key-rotation-strategies",children:"Key Rotation Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"1-automated-key-rotation-service",children:"1. Automated Key Rotation Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/security/key-rotation.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { SecretManagerService } from '../config/secret-manager.service';\nimport { randomBytes } from 'crypto';\n\n@Injectable()\nexport class KeyRotationService {\n  private readonly logger = new Logger(KeyRotationService.name);\n\n  constructor(private secretManager: SecretManagerService) {}\n\n  @Cron(CronExpression.EVERY_1ST_DAY_OF_MONTH_AT_MIDNIGHT)\n  async rotateKeys(): Promise<void> {\n    this.logger.log('Starting monthly key rotation');\n\n    try {\n      await this.rotateJwtSecret();\n      await this.rotateEncryptionKey();\n      await this.rotateSessionSecret();\n      \n      this.logger.log('Key rotation completed successfully');\n    } catch (error) {\n      this.logger.error('Key rotation failed:', error);\n      // Send alert to monitoring system\n      await this.sendRotationAlert('failed', error.message);\n    }\n  }\n\n  async rotateJwtSecret(): Promise<void> {\n    const newSecret = this.generateSecureSecret(64);\n    await this.secretManager.updateSecret('jwt-secret', newSecret);\n    this.logger.log('JWT secret rotated');\n  }\n\n  async rotateEncryptionKey(): Promise<void> {\n    const newKey = this.generateSecureSecret(32);\n    await this.secretManager.updateSecret('encryption-key', newKey);\n    this.logger.log('Encryption key rotated');\n  }\n\n  async rotateSessionSecret(): Promise<void> {\n    const newSecret = this.generateSecureSecret(64);\n    await this.secretManager.updateSecret('session-secret', newSecret);\n    this.logger.log('Session secret rotated');\n  }\n\n  private generateSecureSecret(length: number): string {\n    return randomBytes(length).toString('hex');\n  }\n\n  private async sendRotationAlert(status: 'success' | 'failed', message: string): Promise<void> {\n    // Implementation for sending alerts (Slack, email, etc.)\n    this.logger.log(`Key rotation ${status}: ${message}`);\n  }\n\n  // Manual rotation endpoint for emergency situations\n  async emergencyRotation(secretName: string): Promise<void> {\n    this.logger.warn(`Emergency rotation initiated for ${secretName}`);\n    \n    const newSecret = this.generateSecureSecret(64);\n    await this.secretManager.updateSecret(secretName, newSecret);\n    \n    await this.sendRotationAlert('success', `Emergency rotation completed for ${secretName}`);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-database-password-rotation",children:"2. Database Password Rotation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/security/db-rotation.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { SecretManagerService } from '../config/secret-manager.service';\nimport { DataSource } from 'typeorm';\n\n@Injectable()\nexport class DatabaseRotationService {\n  private readonly logger = new Logger(DatabaseRotationService.name);\n\n  constructor(\n    private secretManager: SecretManagerService,\n    private dataSource: DataSource\n  ) {}\n\n  async rotateDatabasePassword(): Promise<void> {\n    const newPassword = this.generatePassword(16);\n    const username = process.env.DB_USERNAME;\n\n    try {\n      // Update password in database\n      await this.dataSource.query(\n        `ALTER USER ${username} WITH PASSWORD $1`,\n        [newPassword]\n      );\n\n      // Update secret in Secret Manager\n      await this.secretManager.updateSecret('database-password', newPassword);\n\n      this.logger.log('Database password rotated successfully');\n    } catch (error) {\n      this.logger.error('Failed to rotate database password:', error);\n      throw error;\n    }\n  }\n\n  private generatePassword(length: number): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';\n    let password = '';\n    for (let i = 0; i < length; i++) {\n      password += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return password;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"environment-based-configuration",children:"Environment-Based Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"1-configuration-factory",children:"1. Configuration Factory"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/config/configuration.factory.ts\nimport { ConfigModule } from '@nestjs/config';\n\nexport const configurationFactory = async () => {\n  const env = process.env.NODE_ENV || 'development';\n  \n  const baseConfig = {\n    environment: env,\n    port: parseInt(process.env.PORT || '3000'),\n    database: {\n      host: process.env.DB_HOST,\n      port: parseInt(process.env.DB_PORT || '5432'),\n      username: process.env.DB_USERNAME,\n      database: process.env.DB_NAME,\n      ssl: env === 'production',\n    },\n    redis: {\n      host: process.env.REDIS_HOST,\n      port: parseInt(process.env.REDIS_PORT || '6379'),\n    },\n    cors: {\n      origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3000'],\n    },\n  };\n\n  // Load secrets from Secret Manager in production\n  if (env === 'production') {\n    try {\n      const { SecretManagerService } = await import('./secret-manager.service');\n      const secretManager = new SecretManagerService();\n      \n      baseConfig.database['password'] = await secretManager.getSecret('database-password');\n      baseConfig['jwtSecret'] = await secretManager.getSecret('jwt-secret');\n      baseConfig['encryptionKey'] = await secretManager.getSecret('encryption-key');\n    } catch (error) {\n      console.error('Failed to load secrets from Secret Manager:', error);\n      throw error;\n    }\n  }\n\n  return baseConfig;\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-environment-validation",children:"2. Environment Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/config/env.validation.ts\nimport { plainToClass } from 'class-transformer';\nimport { IsEnum, IsNumber, IsString, validateSync, IsOptional } from 'class-validator';\n\nenum Environment {\n  Development = 'development',\n  Production = 'production',\n  Test = 'test',\n}\n\nclass EnvironmentVariables {\n  @IsEnum(Environment)\n  NODE_ENV: Environment;\n\n  @IsNumber()\n  PORT: number;\n\n  @IsString()\n  DB_HOST: string;\n\n  @IsNumber()\n  DB_PORT: number;\n\n  @IsString()\n  DB_USERNAME: string;\n\n  @IsString()\n  DB_NAME: string;\n\n  @IsString()\n  @IsOptional()\n  DB_PASSWORD: string; // Optional as it comes from Secret Manager\n\n  @IsString()\n  GCP_PROJECT_ID: string;\n\n  @IsString()\n  @IsOptional()\n  CORS_ORIGIN: string;\n}\n\nexport function validate(config: Record<string, unknown>) {\n  const validatedConfig = plainToClass(EnvironmentVariables, config, {\n    enableImplicitConversion: true,\n  });\n\n  const errors = validateSync(validatedConfig, { skipMissingProperties: false });\n\n  if (errors.length > 0) {\n    throw new Error(errors.toString());\n  }\n  return validatedConfig;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"secret-scanning-and-detection",children:"Secret Scanning and Detection"}),"\n",(0,s.jsx)(n.h3,{id:"1-pre-commit-hook-for-secret-scanning",children:"1. Pre-commit Hook for Secret Scanning"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# .git/hooks/pre-commit\n\necho "Running secret scan..."\n\n# Install truffleHog if not present\nif ! command -v trufflehog &> /dev/null; then\n    echo "Installing truffleHog..."\n    go install github.com/trufflesecurity/trufflehog/v3@latest\nfi\n\n# Scan staged files for secrets\ntrufflehog git file://. --since-commit HEAD --only-verified --fail\n\nif [ $? -ne 0 ]; then\n    echo "\u274c Secret scan failed! Please remove secrets before committing."\n    exit 1\nfi\n\necho "\u2705 Secret scan passed!"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-cicd-secret-scanning",children:"2. CI/CD Secret Scanning"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"# .github/workflows/secret-scan.yml\nname: Secret Scanning\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  secret-scan:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n        \n    - name: Run TruffleHog\n      uses: trufflesecurity/trufflehog@main\n      with:\n        path: ./\n        base: main\n        head: HEAD\n        extra_args: --debug --only-verified\n        \n    - name: Run GitLeaks\n      uses: gitleaks/gitleaks-action@v2\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        \n    - name: SARIF Upload\n      uses: github/codeql-action/upload-sarif@v2\n      if: always()\n      with:\n        sarif_file: results.sarif\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-runtime-secret-detection",children:"3. Runtime Secret Detection"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/security/secret-detector.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\n@Injectable()\nexport class SecretDetectorService {\n  private readonly logger = new Logger(SecretDetectorService.name);\n  \n  private readonly patterns = {\n    awsAccessKey: /AKIA[0-9A-Z]{16}/g,\n    awsSecretKey: /[0-9a-zA-Z/+]{40}/g,\n    googleApiKey: /AIza[0-9A-Za-z-_]{35}/g,\n    githubToken: /gh[ospru]_[A-Za-z0-9_]{36}/g,\n    slackToken: /xox[baprs]-([0-9a-zA-Z]{10,48})/g,\n    jwt: /eyJ[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+/=]*/g,\n    genericSecret: /(?i)(secret|password|key|token|pwd|pass)[\\s]*[:=][\\s]*['\"]?[a-zA-Z0-9!@#$%^&*]{8,}/g,\n  };\n\n  scanText(text: string): { type: string; match: string; position: number }[] {\n    const findings: { type: string; match: string; position: number }[] = [];\n\n    Object.entries(this.patterns).forEach(([type, pattern]) => {\n      let match;\n      while ((match = pattern.exec(text)) !== null) {\n        findings.push({\n          type,\n          match: match[0],\n          position: match.index,\n        });\n      }\n    });\n\n    if (findings.length > 0) {\n      this.logger.warn(`Potential secrets detected:`, findings);\n    }\n\n    return findings;\n  }\n\n  scanObject(obj: any, path: string = ''): { type: string; path: string; value: string }[] {\n    const findings: { type: string; path: string; value: string }[] = [];\n\n    if (typeof obj === 'string') {\n      const textFindings = this.scanText(obj);\n      textFindings.forEach(finding => {\n        findings.push({\n          type: finding.type,\n          path,\n          value: finding.match,\n        });\n      });\n    } else if (typeof obj === 'object' && obj !== null) {\n      Object.entries(obj).forEach(([key, value]) => {\n        const newPath = path ? `${path}.${key}` : key;\n        findings.push(...this.scanObject(value, newPath));\n      });\n    }\n\n    return findings;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"audit-and-monitoring",children:"Audit and Monitoring"}),"\n",(0,s.jsx)(n.h3,{id:"1-secret-access-logging",children:"1. Secret Access Logging"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/audit/secret-access.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { SecretAccessLog } from './entities/secret-access-log.entity';\n\n@Injectable()\nexport class SecretAccessService {\n  private readonly logger = new Logger(SecretAccessService.name);\n\n  constructor(\n    @InjectRepository(SecretAccessLog)\n    private secretAccessRepository: Repository<SecretAccessLog>\n  ) {}\n\n  async logSecretAccess(data: {\n    secretName: string;\n    userId?: string;\n    serviceAccount?: string;\n    action: 'READ' | 'CREATE' | 'UPDATE' | 'DELETE';\n    source: string;\n    success: boolean;\n    reason?: string;\n  }): Promise<void> {\n    const log = this.secretAccessRepository.create({\n      ...data,\n      timestamp: new Date(),\n      ipAddress: this.getClientIP(),\n    });\n\n    await this.secretAccessRepository.save(log);\n    \n    this.logger.log(`Secret access logged: ${data.secretName} - ${data.action}`);\n  }\n\n  private getClientIP(): string {\n    // Implementation to get client IP\n    return 'unknown';\n  }\n\n  async getAuditLogs(filters: {\n    secretName?: string;\n    startDate?: Date;\n    endDate?: Date;\n    action?: string;\n  }): Promise<SecretAccessLog[]> {\n    const query = this.secretAccessRepository.createQueryBuilder('log');\n\n    if (filters.secretName) {\n      query.andWhere('log.secretName = :secretName', { secretName: filters.secretName });\n    }\n\n    if (filters.startDate) {\n      query.andWhere('log.timestamp >= :startDate', { startDate: filters.startDate });\n    }\n\n    if (filters.endDate) {\n      query.andWhere('log.timestamp <= :endDate', { endDate: filters.endDate });\n    }\n\n    if (filters.action) {\n      query.andWhere('log.action = :action', { action: filters.action });\n    }\n\n    return query.orderBy('log.timestamp', 'DESC').getMany();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-monitoring-and-alerting",children:"2. Monitoring and Alerting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/monitoring/secret-monitoring.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { SecretManagerService } from '../config/secret-manager.service';\n\n@Injectable()\nexport class SecretMonitoringService {\n  private readonly logger = new Logger(SecretMonitoringService.name);\n\n  constructor(private secretManager: SecretManagerService) {}\n\n  @Cron(CronExpression.EVERY_HOUR)\n  async checkSecretHealth(): Promise<void> {\n    const criticalSecrets = [\n      'database-password',\n      'jwt-secret',\n      'encryption-key',\n    ];\n\n    for (const secretName of criticalSecrets) {\n      try {\n        const secret = await this.secretManager.getSecret(secretName);\n        if (!secret) {\n          await this.alertSecretIssue(secretName, 'Secret is empty or null');\n        }\n      } catch (error) {\n        await this.alertSecretIssue(secretName, error.message);\n      }\n    }\n  }\n\n  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)\n  async checkSecretRotation(): Promise<void> {\n    // Check if secrets are due for rotation\n    const secrets = await this.secretManager.listSecrets();\n    \n    for (const secretName of secrets) {\n      const lastRotation = await this.getLastRotationDate(secretName);\n      const daysSinceRotation = this.getDaysSince(lastRotation);\n      \n      if (daysSinceRotation > 90) { // 90 days rotation policy\n        await this.alertRotationDue(secretName, daysSinceRotation);\n      }\n    }\n  }\n\n  private async alertSecretIssue(secretName: string, issue: string): Promise<void> {\n    this.logger.error(`Secret issue detected: ${secretName} - ${issue}`);\n    // Send alert to monitoring system\n  }\n\n  private async alertRotationDue(secretName: string, days: number): Promise<void> {\n    this.logger.warn(`Secret rotation overdue: ${secretName} (${days} days)`);\n    // Send rotation reminder\n  }\n\n  private async getLastRotationDate(secretName: string): Promise<Date> {\n    // Implementation to get last rotation date\n    return new Date();\n  }\n\n  private getDaysSince(date: Date): number {\n    const now = new Date();\n    const diffTime = Math.abs(now.getTime() - date.getTime());\n    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,s.jsx)(n.h3,{id:"1-secret-management-tests",children:"1. Secret Management Tests"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// test/secret-management.e2e-spec.ts\nimport { Test } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { SecretManagerService } from '../src/config/secret-manager.service';\n\ndescribe('Secret Management (e2e)', () => {\n  let app: INestApplication;\n  let secretManager: SecretManagerService;\n\n  beforeAll(async () => {\n    const moduleFixture = await Test.createTestingModule({\n      providers: [SecretManagerService],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    secretManager = moduleFixture.get<SecretManagerService>(SecretManagerService);\n    await app.init();\n  });\n\n  it('should retrieve secrets from Secret Manager', async () => {\n    const secret = await secretManager.getSecret('test-secret');\n    expect(secret).toBeDefined();\n    expect(typeof secret).toBe('string');\n  });\n\n  it('should handle non-existent secrets gracefully', async () => {\n    await expect(\n      secretManager.getSecret('non-existent-secret')\n    ).rejects.toThrow();\n  });\n\n  it('should create and retrieve new secrets', async () => {\n    const secretName = 'test-secret-' + Date.now();\n    const secretValue = 'test-value-' + Math.random();\n\n    await secretManager.createSecret(secretName, secretValue);\n    const retrievedSecret = await secretManager.getSecret(secretName);\n    \n    expect(retrievedSecret).toBe(secretValue);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"deployment-checklist",children:"Deployment Checklist"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","GCP Secret Manager API enabled"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Service account with appropriate permissions created"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Workload Identity configured for GKE"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Secret Store CSI driver installed"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All secrets migrated to Secret Manager"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Environment variables updated to reference secrets"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Key rotation schedule configured"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Monitoring and alerting set up"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Secret scanning tools integrated in CI/CD"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Team trained on secret management procedures"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This implementation ensures that sensitive system data is properly protected, rotated, and monitored throughout the application lifecycle."})]})}function g(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},7814:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var r=t(9729);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);