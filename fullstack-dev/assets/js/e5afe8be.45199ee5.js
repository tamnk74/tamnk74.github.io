"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[2876],{5741:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var i=t(9729);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}},6746:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"security-practices/security-implementation/security-monitoring","title":"Security Monitoring & Observability Implementation Guide","description":"Overview","source":"@site/docs/security-practices/security-implementation/security-monitoring.md","sourceDirName":"security-practices/security-implementation","slug":"/security-practices/security-implementation/security-monitoring","permalink":"/fullstack-dev/docs/security-practices/security-implementation/security-monitoring","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/security-practices/security-implementation/security-monitoring.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Dynamic Application Security Testing (DAST) with OWASP ZAP and GitHub Actions","permalink":"/fullstack-dev/docs/security-practices/dast-owasp-zap-github-actions"},"next":{"title":"Security Compliance Automation Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/compliance-automation"}}');var r=t(5813),s=t(5741);const o={},c="Security Monitoring & Observability Implementation Guide",a={},l=[{value:"Overview",id:"overview",level:2},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Security Monitoring Architecture",id:"security-monitoring-architecture",level:2},{value:"Component Overview",id:"component-overview",level:3},{value:"Google Cloud Security Center Integration",id:"google-cloud-security-center-integration",level:2},{value:"1. Security Command Center Setup",id:"1-security-command-center-setup",level:3},{value:"2. Security Findings Integration",id:"2-security-findings-integration",level:3},{value:"3. Security Events Detection",id:"3-security-events-detection",level:3},{value:"Application-Level Security Monitoring",id:"application-level-security-monitoring",level:2},{value:"1. Security Monitoring Middleware",id:"1-security-monitoring-middleware",level:3},{value:"2. Security Metrics Collection",id:"2-security-metrics-collection",level:3},{value:"Infrastructure Security Monitoring",id:"infrastructure-security-monitoring",level:2},{value:"1. GKE Security Monitoring Configuration",id:"1-gke-security-monitoring-configuration",level:3},{value:"2. Security Event Processing Service",id:"2-security-event-processing-service",level:3},{value:"Real-time Alerting &amp; Response",id:"real-time-alerting--response",level:2},{value:"1. Alerting Policy Configuration",id:"1-alerting-policy-configuration",level:3},{value:"2. Incident Response Automation",id:"2-incident-response-automation",level:3},{value:"Security Metrics &amp; Dashboards",id:"security-metrics--dashboards",level:2},{value:"1. Security Dashboard Configuration",id:"1-security-dashboard-configuration",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Monitoring Strategy",id:"1-monitoring-strategy",level:3},{value:"2. Incident Response",id:"2-incident-response",level:3},{value:"3. Compliance &amp; Governance",id:"3-compliance--governance",level:3},{value:"4. Performance Considerations",id:"4-performance-considerations",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Related Guides",id:"related-guides",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"security-monitoring--observability-implementation-guide",children:"Security Monitoring & Observability Implementation Guide"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"This guide provides comprehensive instructions for implementing security monitoring and observability in NestJS/Next.js applications deployed on Google Cloud Platform (GCP) Kubernetes, focusing on real-time threat detection, compliance monitoring, and incident response automation."}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#security-monitoring-architecture",children:"Security Monitoring Architecture"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#google-cloud-security-center-integration",children:"Google Cloud Security Center Integration"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#application-level-security-monitoring",children:"Application-Level Security Monitoring"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#infrastructure-security-monitoring",children:"Infrastructure Security Monitoring"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#real-time-alerting--response",children:"Real-time Alerting & Response"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#security-metrics--dashboards",children:"Security Metrics & Dashboards"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"security-monitoring-architecture",children:"Security Monitoring Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"component-overview",children:"Component Overview"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Security monitoring stack architecture\ninterface SecurityMonitoringStack {\n  detection: {\n    cloudSecurityCenter: 'Google Cloud Security Command Center',\n    applicationSecurity: 'NestJS Security Monitoring',\n    infrastructureSecurity: 'GKE Security Monitoring',\n    networkSecurity: 'VPC Flow Logs & Cloud Armor'\n  },\n  aggregation: {\n    logging: 'Google Cloud Logging',\n    metrics: 'Google Cloud Monitoring',\n    traces: 'Google Cloud Trace'\n  },\n  analysis: {\n    bigquery: 'Security Analytics',\n    aiPlatform: 'Anomaly Detection',\n    chronicles: 'SIEM Analysis'\n  },\n  response: {\n    alerting: 'Google Cloud Alerting',\n    automation: 'Cloud Functions',\n    incident: 'Cloud Incident Response'\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"google-cloud-security-center-integration",children:"Google Cloud Security Center Integration"}),"\n",(0,r.jsx)(n.h3,{id:"1-security-command-center-setup",children:"1. Security Command Center Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Enable Security Command Center API\ngcloud services enable securitycenter.googleapis.com\n\n# Create organization-level security findings\ngcloud scc sources create \\\n    --display-name="NestJS Application Security" \\\n    --description="Security findings from NestJS application"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-security-findings-integration",children:"2. Security Findings Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/security/security-center.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { SecurityCenterClient } from '@google-cloud/security-center';\n\n@Injectable()\nexport class SecurityCenterService {\n  private readonly logger = new Logger(SecurityCenterService.name);\n  private client: SecurityCenterClient;\n  private readonly sourceName: string;\n\n  constructor() {\n    this.client = new SecurityCenterClient();\n    this.sourceName = `organizations/${process.env.GOOGLE_CLOUD_ORGANIZATION}/sources/${process.env.SECURITY_SOURCE_ID}`;\n  }\n\n  async createSecurityFinding(\n    findingId: string,\n    severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW',\n    category: string,\n    description: string,\n    sourceProperties: Record<string, any>\n  ) {\n    try {\n      const finding = {\n        name: `${this.sourceName}/findings/${findingId}`,\n        parent: this.sourceName,\n        resourceName: `projects/${process.env.GOOGLE_CLOUD_PROJECT}`,\n        state: 'ACTIVE',\n        category,\n        severity,\n        description,\n        sourceProperties,\n        eventTime: {\n          seconds: Math.floor(Date.now() / 1000),\n        },\n      };\n\n      const [response] = await this.client.createFinding({\n        parent: this.sourceName,\n        findingId,\n        finding,\n      });\n\n      this.logger.log(`Security finding created: ${response.name}`);\n      return response;\n    } catch (error) {\n      this.logger.error(`Failed to create security finding: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async updateFindingState(findingId: string, state: 'ACTIVE' | 'INACTIVE') {\n    try {\n      const findingName = `${this.sourceName}/findings/${findingId}`;\n      \n      const [response] = await this.client.setFindingState({\n        name: findingName,\n        state,\n      });\n\n      this.logger.log(`Finding ${findingId} state updated to ${state}`);\n      return response;\n    } catch (error) {\n      this.logger.error(`Failed to update finding state: ${error.message}`);\n      throw error;\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-security-events-detection",children:"3. Security Events Detection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/security/security-events.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { SecurityCenterService } from './security-center.service';\n\ninterface SecurityEvent {\n  type: 'AUTHENTICATION_FAILURE' | 'AUTHORIZATION_VIOLATION' | 'SUSPICIOUS_ACTIVITY' | 'DATA_BREACH_ATTEMPT';\n  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';\n  userId?: string;\n  ipAddress: string;\n  userAgent: string;\n  resource: string;\n  details: Record<string, any>;\n}\n\n@Injectable()\nexport class SecurityEventsService {\n  constructor(private securityCenter: SecurityCenterService) {}\n\n  async reportSecurityEvent(event: SecurityEvent) {\n    const findingId = `${event.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    await this.securityCenter.createSecurityFinding(\n      findingId,\n      event.severity,\n      event.type,\n      this.generateEventDescription(event),\n      {\n        userId: event.userId,\n        ipAddress: event.ipAddress,\n        userAgent: event.userAgent,\n        resource: event.resource,\n        timestamp: new Date().toISOString(),\n        ...event.details\n      }\n    );\n\n    // Additional automated responses based on severity\n    if (event.severity === 'CRITICAL') {\n      await this.triggerEmergencyResponse(event);\n    }\n  }\n\n  private generateEventDescription(event: SecurityEvent): string {\n    switch (event.type) {\n      case 'AUTHENTICATION_FAILURE':\n        return `Multiple authentication failures detected from IP ${event.ipAddress}`;\n      case 'AUTHORIZATION_VIOLATION':\n        return `Unauthorized access attempt to ${event.resource} by user ${event.userId}`;\n      case 'SUSPICIOUS_ACTIVITY':\n        return `Suspicious activity detected from ${event.ipAddress}`;\n      case 'DATA_BREACH_ATTEMPT':\n        return `Potential data breach attempt detected on ${event.resource}`;\n      default:\n        return `Security event of type ${event.type} detected`;\n    }\n  }\n\n  private async triggerEmergencyResponse(event: SecurityEvent) {\n    // Implement emergency response procedures\n    // e.g., temporary IP blocking, user account suspension, etc.\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"application-level-security-monitoring",children:"Application-Level Security Monitoring"}),"\n",(0,r.jsx)(n.h3,{id:"1-security-monitoring-middleware",children:"1. Security Monitoring Middleware"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/security/security-monitoring.middleware.ts\nimport { Injectable, NestMiddleware, Logger } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport { SecurityEventsService } from './security-events.service';\n\n@Injectable()\nexport class SecurityMonitoringMiddleware implements NestMiddleware {\n  private readonly logger = new Logger(SecurityMonitoringMiddleware.name);\n  private readonly suspiciousPatterns = [\n    /\\b(script|javascript|vbscript)\\b/i,\n    /\\b(select|union|insert|update|delete)\\b.*\\b(from|where)\\b/i,\n    /\\.\\.\\//g,\n    /<script/i,\n    /javascript:/i\n  ];\n\n  constructor(private securityEvents: SecurityEventsService) {}\n\n  use(req: Request, res: Response, next: NextFunction) {\n    // Monitor for suspicious patterns in requests\n    this.detectSuspiciousPatterns(req);\n    \n    // Monitor for rate limiting violations\n    this.detectRateLimitViolations(req);\n    \n    // Monitor authentication failures\n    this.monitorAuthenticationAttempts(req, res);\n\n    next();\n  }\n\n  private detectSuspiciousPatterns(req: Request) {\n    const fullUrl = req.url;\n    const body = JSON.stringify(req.body || {});\n    const query = JSON.stringify(req.query || {});\n\n    const suspiciousContent = [fullUrl, body, query].join(' ');\n\n    for (const pattern of this.suspiciousPatterns) {\n      if (pattern.test(suspiciousContent)) {\n        this.securityEvents.reportSecurityEvent({\n          type: 'SUSPICIOUS_ACTIVITY',\n          severity: 'HIGH',\n          ipAddress: req.ip,\n          userAgent: req.get('User-Agent') || '',\n          resource: req.url,\n          details: {\n            pattern: pattern.toString(),\n            matchedContent: suspiciousContent.match(pattern)?.[0],\n            method: req.method,\n            headers: req.headers\n          }\n        });\n        break;\n      }\n    }\n  }\n\n  private detectRateLimitViolations(req: Request) {\n    // Implement rate limiting violation detection\n    // This would work with your rate limiting implementation\n  }\n\n  private monitorAuthenticationAttempts(req: Request, res: Response) {\n    // Monitor authentication endpoints\n    if (req.url.includes('/auth/login') && req.method === 'POST') {\n      const originalSend = res.send;\n      res.send = function(data) {\n        if (res.statusCode === 401 || res.statusCode === 403) {\n          // Authentication failure detected\n          // This would be implemented based on your auth response structure\n        }\n        return originalSend.call(this, data);\n      };\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-security-metrics-collection",children:"2. Security Metrics Collection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/security/security-metrics.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { Monitoring } from '@google-cloud/monitoring';\n\n@Injectable()\nexport class SecurityMetricsService {\n  private monitoringClient: Monitoring.MetricServiceClient;\n  private readonly projectId = process.env.GOOGLE_CLOUD_PROJECT;\n\n  constructor() {\n    this.monitoringClient = new Monitoring.MetricServiceClient();\n  }\n\n  async recordSecurityMetric(\n    metricType: string,\n    value: number,\n    labels: Record<string, string> = {}\n  ) {\n    const dataPoint = {\n      interval: {\n        endTime: {\n          seconds: Date.now() / 1000,\n        },\n      },\n      value: {\n        doubleValue: value,\n      },\n    };\n\n    const timeSeriesData = {\n      metric: {\n        type: `custom.googleapis.com/security/${metricType}`,\n        labels,\n      },\n      resource: {\n        type: 'gce_instance',\n        labels: {\n          instance_id: process.env.INSTANCE_ID || 'unknown',\n          zone: process.env.GOOGLE_CLOUD_ZONE || 'unknown',\n        },\n      },\n      points: [dataPoint],\n    };\n\n    try {\n      await this.monitoringClient.createTimeSeries({\n        name: `projects/${this.projectId}`,\n        timeSeries: [timeSeriesData],\n      });\n    } catch (error) {\n      console.error('Error recording security metric:', error);\n    }\n  }\n\n  // Predefined security metrics\n  async recordAuthenticationFailure(ipAddress: string, userId?: string) {\n    await this.recordSecurityMetric('authentication_failures', 1, {\n      ip_address: ipAddress,\n      user_id: userId || 'unknown',\n    });\n  }\n\n  async recordSuspiciousActivity(activityType: string, severity: string) {\n    await this.recordSecurityMetric('suspicious_activities', 1, {\n      activity_type: activityType,\n      severity,\n    });\n  }\n\n  async recordAccessViolation(resource: string, userId: string) {\n    await this.recordSecurityMetric('access_violations', 1, {\n      resource,\n      user_id: userId,\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"infrastructure-security-monitoring",children:"Infrastructure Security Monitoring"}),"\n",(0,r.jsx)(n.h3,{id:"1-gke-security-monitoring-configuration",children:"1. GKE Security Monitoring Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# k8s/security-monitoring.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: falco-config\n  namespace: security-monitoring\ndata:\n  falco.yaml: |\n    rules_file:\n      - /etc/falco/falco_rules.yaml\n      - /etc/falco/falco_rules.local.yaml\n      - /etc/falco/k8s_audit_rules.yaml\n    \n    json_output: true\n    json_include_output_property: true\n    \n    http_output:\n      enabled: true\n      url: "http://security-webhook-service:8080/falco-alerts"\n    \n    grpc:\n      enabled: true\n      bind_address: "0.0.0.0:5060"\n      threadiness: 8\n    \n    grpc_output:\n      enabled: false\n\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: falco\n  namespace: security-monitoring\nspec:\n  selector:\n    matchLabels:\n      app: falco\n  template:\n    metadata:\n      labels:\n        app: falco\n    spec:\n      serviceAccount: falco\n      hostNetwork: true\n      dnsPolicy: ClusterFirstWithHostNet\n      containers:\n      - name: falco\n        image: falcosecurity/falco:latest\n        securityContext:\n          privileged: true\n        volumeMounts:\n        - mountPath: /host/var/run/docker.sock\n          name: docker-socket\n        - mountPath: /host/dev\n          name: dev-fs\n        - mountPath: /host/proc\n          name: proc-fs\n        - mountPath: /host/boot\n          name: boot-fs\n        - mountPath: /host/lib/modules\n          name: lib-modules\n        - mountPath: /host/usr\n          name: usr-fs\n        - mountPath: /etc/falco\n          name: falco-config\n      volumes:\n      - name: docker-socket\n        hostPath:\n          path: /var/run/docker.sock\n      - name: dev-fs\n        hostPath:\n          path: /dev\n      - name: proc-fs\n        hostPath:\n          path: /proc\n      - name: boot-fs\n        hostPath:\n          path: /boot\n      - name: lib-modules\n        hostPath:\n          path: /lib/modules\n      - name: usr-fs\n        hostPath:\n          path: /usr\n      - name: falco-config\n        configMap:\n          name: falco-config\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-security-event-processing-service",children:"2. Security Event Processing Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/security/security-webhook.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { SecurityCenterService } from './security-center.service';\n\ninterface FalcoAlert {\n  output: string;\n  priority: 'Emergency' | 'Alert' | 'Critical' | 'Error' | 'Warning' | 'Notice' | 'Informational' | 'Debug';\n  rule: string;\n  time: string;\n  output_fields: Record<string, any>;\n}\n\n@Injectable()\nexport class SecurityWebhookService {\n  private readonly logger = new Logger(SecurityWebhookService.name);\n\n  constructor(private securityCenter: SecurityCenterService) {}\n\n  async processFalcoAlert(alert: FalcoAlert) {\n    this.logger.warn(`Falco security alert: ${alert.output}`);\n\n    const severity = this.mapPriorityToSeverity(alert.priority);\n    const findingId = `falco_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    await this.securityCenter.createSecurityFinding(\n      findingId,\n      severity,\n      'RUNTIME_SECURITY_VIOLATION',\n      alert.output,\n      {\n        rule: alert.rule,\n        priority: alert.priority,\n        time: alert.time,\n        ...alert.output_fields\n      }\n    );\n\n    // Trigger automated response for critical alerts\n    if (severity === 'CRITICAL') {\n      await this.triggerAutomatedResponse(alert);\n    }\n  }\n\n  private mapPriorityToSeverity(priority: string): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {\n    switch (priority) {\n      case 'Emergency':\n      case 'Alert':\n      case 'Critical':\n        return 'CRITICAL';\n      case 'Error':\n        return 'HIGH';\n      case 'Warning':\n        return 'MEDIUM';\n      default:\n        return 'LOW';\n    }\n  }\n\n  private async triggerAutomatedResponse(alert: FalcoAlert) {\n    // Implement automated response procedures\n    // e.g., isolate pod, scale down deployment, notify incident response team\n    this.logger.error(`CRITICAL SECURITY ALERT: ${alert.output}`);\n    \n    // Could trigger Cloud Function for automated remediation\n    // await this.cloudFunctionsService.triggerIncidentResponse(alert);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"real-time-alerting--response",children:"Real-time Alerting & Response"}),"\n",(0,r.jsx)(n.h3,{id:"1-alerting-policy-configuration",children:"1. Alerting Policy Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/security/alerting.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { Monitoring } from '@google-cloud/monitoring';\n\n@Injectable()\nexport class SecurityAlertingService {\n  private alertClient: Monitoring.AlertPolicyServiceClient;\n  private readonly projectId = process.env.GOOGLE_CLOUD_PROJECT;\n\n  constructor() {\n    this.alertClient = new Monitoring.AlertPolicyServiceClient();\n  }\n\n  async createSecurityAlertPolicy(\n    displayName: string,\n    metricFilter: string,\n    threshold: number,\n    notificationChannels: string[]\n  ) {\n    const alertPolicy = {\n      displayName,\n      conditions: [\n        {\n          displayName: `${displayName} Condition`,\n          conditionThreshold: {\n            filter: metricFilter,\n            comparison: 'COMPARISON_GREATER_THAN',\n            thresholdValue: { doubleValue: threshold },\n            duration: { seconds: 300 }, // 5 minutes\n            aggregations: [\n              {\n                alignmentPeriod: { seconds: 300 },\n                perSeriesAligner: 'ALIGN_RATE',\n                crossSeriesReducer: 'REDUCE_SUM',\n              },\n            ],\n          },\n        },\n      ],\n      notificationChannels,\n      alertStrategy: {\n        autoClose: { seconds: 86400 }, // 24 hours\n      },\n      enabled: { value: true },\n    };\n\n    try {\n      const [response] = await this.alertClient.createAlertPolicy({\n        name: `projects/${this.projectId}`,\n        alertPolicy,\n      });\n      return response;\n    } catch (error) {\n      console.error('Error creating alert policy:', error);\n      throw error;\n    }\n  }\n\n  async setupDefaultSecurityAlerts(notificationChannels: string[]) {\n    // Authentication failure alerts\n    await this.createSecurityAlertPolicy(\n      'High Authentication Failures',\n      'resource.type=\"gce_instance\" AND metric.type=\"custom.googleapis.com/security/authentication_failures\"',\n      10, // 10 failures in 5 minutes\n      notificationChannels\n    );\n\n    // Suspicious activity alerts\n    await this.createSecurityAlertPolicy(\n      'Suspicious Activity Detected',\n      'resource.type=\"gce_instance\" AND metric.type=\"custom.googleapis.com/security/suspicious_activities\"',\n      5, // 5 suspicious activities in 5 minutes\n      notificationChannels\n    );\n\n    // Access violation alerts\n    await this.createSecurityAlertPolicy(\n      'Unauthorized Access Attempts',\n      'resource.type=\"gce_instance\" AND metric.type=\"custom.googleapis.com/security/access_violations\"',\n      3, // 3 access violations in 5 minutes\n      notificationChannels\n    );\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-incident-response-automation",children:"2. Incident Response Automation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/security/incident-response.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\ninterface SecurityIncident {\n  id: string;\n  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';\n  type: string;\n  description: string;\n  affectedResources: string[];\n  detectionTime: Date;\n  sourceIP?: string;\n  userId?: string;\n}\n\n@Injectable()\nexport class IncidentResponseService {\n  private readonly logger = new Logger(IncidentResponseService.name);\n\n  async handleSecurityIncident(incident: SecurityIncident) {\n    this.logger.error(`Security incident detected: ${incident.id}`);\n\n    // Step 1: Initial containment\n    await this.performInitialContainment(incident);\n\n    // Step 2: Evidence collection\n    await this.collectEvidence(incident);\n\n    // Step 3: Notification\n    await this.notifySecurityTeam(incident);\n\n    // Step 4: Automated remediation (if applicable)\n    if (incident.severity === 'CRITICAL') {\n      await this.performAutomatedRemediation(incident);\n    }\n\n    // Step 5: Documentation\n    await this.documentIncident(incident);\n  }\n\n  private async performInitialContainment(incident: SecurityIncident) {\n    switch (incident.type) {\n      case 'AUTHENTICATION_FAILURE':\n        if (incident.sourceIP) {\n          await this.blockIPAddress(incident.sourceIP, '1h');\n        }\n        break;\n      \n      case 'SUSPICIOUS_ACTIVITY':\n        if (incident.userId) {\n          await this.suspendUserAccount(incident.userId);\n        }\n        break;\n      \n      case 'DATA_BREACH_ATTEMPT':\n        await this.isolateAffectedResources(incident.affectedResources);\n        break;\n    }\n  }\n\n  private async collectEvidence(incident: SecurityIncident) {\n    // Collect logs, metrics, and other evidence\n    const evidence = {\n      logs: await this.collectRelevantLogs(incident),\n      metrics: await this.collectSecurityMetrics(incident),\n      networkTraffic: await this.collectNetworkLogs(incident),\n      systemState: await this.captureSystemState(incident)\n    };\n\n    // Store evidence in secure location\n    await this.storeEvidence(incident.id, evidence);\n  }\n\n  private async notifySecurityTeam(incident: SecurityIncident) {\n    // Send notifications to security team via multiple channels\n    // e.g., PagerDuty, Slack, Email\n  }\n\n  private async performAutomatedRemediation(incident: SecurityIncident) {\n    // Implement automated remediation based on incident type\n    // This should be carefully designed to avoid false positives\n  }\n\n  private async documentIncident(incident: SecurityIncident) {\n    // Create incident documentation for post-incident review\n  }\n\n  // Helper methods\n  private async blockIPAddress(ip: string, duration: string) {\n    // Implement IP blocking via Cloud Armor or firewall rules\n  }\n\n  private async suspendUserAccount(userId: string) {\n    // Implement user account suspension\n  }\n\n  private async isolateAffectedResources(resources: string[]) {\n    // Implement resource isolation (e.g., network segmentation)\n  }\n\n  private async collectRelevantLogs(incident: SecurityIncident) {\n    // Collect relevant logs from Cloud Logging\n  }\n\n  private async collectSecurityMetrics(incident: SecurityIncident) {\n    // Collect relevant metrics from Cloud Monitoring\n  }\n\n  private async collectNetworkLogs(incident: SecurityIncident) {\n    // Collect VPC Flow Logs and other network data\n  }\n\n  private async captureSystemState(incident: SecurityIncident) {\n    // Capture current system state for forensic analysis\n  }\n\n  private async storeEvidence(incidentId: string, evidence: any) {\n    // Store evidence in tamper-proof storage (e.g., Cloud Storage with retention policies)\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"security-metrics--dashboards",children:"Security Metrics & Dashboards"}),"\n",(0,r.jsx)(n.h3,{id:"1-security-dashboard-configuration",children:"1. Security Dashboard Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "displayName": "Security Monitoring Dashboard",\n  "mosaicLayout": {\n    "tiles": [\n      {\n        "width": 6,\n        "height": 4,\n        "widget": {\n          "title": "Authentication Failures",\n          "xyChart": {\n            "dataSets": [\n              {\n                "timeSeriesQuery": {\n                  "timeSeriesFilter": {\n                    "filter": "metric.type=\\"custom.googleapis.com/security/authentication_failures\\"",\n                    "aggregation": {\n                      "alignmentPeriod": "300s",\n                      "perSeriesAligner": "ALIGN_RATE"\n                    }\n                  }\n                }\n              }\n            ]\n          }\n        }\n      },\n      {\n        "width": 6,\n        "height": 4,\n        "widget": {\n          "title": "Suspicious Activities",\n          "xyChart": {\n            "dataSets": [\n              {\n                "timeSeriesQuery": {\n                  "timeSeriesFilter": {\n                    "filter": "metric.type=\\"custom.googleapis.com/security/suspicious_activities\\"",\n                    "aggregation": {\n                      "alignmentPeriod": "300s",\n                      "perSeriesAligner": "ALIGN_RATE"\n                    }\n                  }\n                }\n              }\n            ]\n          }\n        }\n      },\n      {\n        "width": 12,\n        "height": 4,\n        "widget": {\n          "title": "Security Incidents by Severity",\n          "xyChart": {\n            "dataSets": [\n              {\n                "timeSeriesQuery": {\n                  "timeSeriesFilter": {\n                    "filter": "metric.type=\\"custom.googleapis.com/security/incidents\\"",\n                    "aggregation": {\n                      "alignmentPeriod": "3600s",\n                      "perSeriesAligner": "ALIGN_SUM",\n                      "groupByFields": ["metric.label.severity"]\n                    }\n                  }\n                }\n              }\n            ]\n          }\n        }\n      }\n    ]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-monitoring-strategy",children:"1. Monitoring Strategy"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Layered Monitoring"}),": Implement monitoring at application, infrastructure, and network layers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real-time Detection"}),": Use streaming analytics for immediate threat detection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Context Correlation"}),": Correlate events across different systems for better accuracy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"False Positive Reduction"}),": Continuously tune detection rules to minimize false positives"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-incident-response",children:"2. Incident Response"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automated Containment"}),": Implement automated initial response for known threat patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Evidence Preservation"}),": Ensure all security events and responses are logged and preserved"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Regular Testing"}),": Conduct regular incident response drills and tabletop exercises"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Continuous Improvement"}),": Update response procedures based on lessons learned"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-compliance--governance",children:"3. Compliance & Governance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Audit Trail"}),": Maintain comprehensive audit trails for all security events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Retention Policies"}),": Implement appropriate data retention policies for security logs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Access Controls"}),": Ensure security monitoring systems have appropriate access controls"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Regular Reviews"}),": Conduct regular reviews of monitoring effectiveness and coverage"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-performance-considerations",children:"4. Performance Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient Filtering"}),": Use efficient log filtering to reduce processing overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sampling Strategy"}),": Implement sampling for high-volume, low-risk events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource Management"}),": Monitor the resource usage of security monitoring components"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability Planning"}),": Design monitoring systems to scale with application growth"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"High False Positive Rate"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Review and tune detection rules"}),"\n",(0,r.jsx)(n.li,{children:"Implement machine learning-based anomaly detection"}),"\n",(0,r.jsx)(n.li,{children:"Use contextual information to improve accuracy"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Performance Impact"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Optimize monitoring queries and filters"}),"\n",(0,r.jsx)(n.li,{children:"Use asynchronous processing for security events"}),"\n",(0,r.jsx)(n.li,{children:"Implement proper indexing for log data"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Alert Fatigue"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement alert prioritization and escalation"}),"\n",(0,r.jsx)(n.li,{children:"Use alert correlation to reduce noise"}),"\n",(0,r.jsx)(n.li,{children:"Regular review and tuning of alert thresholds"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Integration Issues"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Verify API credentials and permissions"}),"\n",(0,r.jsx)(n.li,{children:"Check network connectivity and firewall rules"}),"\n",(0,r.jsx)(n.li,{children:"Validate data format and schema compatibility"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-guides",children:"Related Guides"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/fullstack-dev/docs/security-practices/security-implementation/log-data-security",children:"Log Data Security Implementation Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/fullstack-dev/docs/security-practices/security-implementation/incident-management",children:"Incident Management Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/fullstack-dev/docs/security-practices/security-implementation/network-security",children:"Network Security Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/fullstack-dev/docs/security-practices/security-implementation/security-testing",children:"Security Testing Guide"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);