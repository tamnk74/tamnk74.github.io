"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[9705],{4825:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"architecture-practices/architecture-validation/non-functional-requirements-validation","title":"Non-functional Requirements Validation","description":"This guide establishes comprehensive validation frameworks for non-functional requirements in NestJS microservices and Next.js microfrontend applications, covering performance testing, security validation, scalability assessment, and compliance verification through automated testing and monitoring strategies.","source":"@site/docs/architecture-practices/architecture-validation/non-functional-requirements-validation.md","sourceDirName":"architecture-practices/architecture-validation","slug":"/architecture-practices/architecture-validation/non-functional-requirements-validation","permalink":"/fullstack-dev/docs/architecture-practices/architecture-validation/non-functional-requirements-validation","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-validation/non-functional-requirements-validation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Continuous Testing Strategy","permalink":"/fullstack-dev/docs/architecture-practices/architecture-validation/continuous-testing"},"next":{"title":"Performance System Architecture for Ecommerce Platform","permalink":"/fullstack-dev/docs/architecture-practices/performance-system-architecture"}}');var s=t(5813),r=t(5741);const a={},o="Non-functional Requirements Validation",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Non-functional Requirements Framework",id:"non-functional-requirements-framework",level:2},{value:"Complete NFR Validation Process",id:"complete-nfr-validation-process",level:3},{value:"Performance Requirements Validation",id:"performance-requirements-validation",level:2},{value:"Load Testing with K6",id:"load-testing-with-k6",level:3},{value:"Frontend Performance Testing",id:"frontend-performance-testing",level:3},{value:"Security Requirements Validation",id:"security-requirements-validation",level:2},{value:"Automated Security Testing",id:"automated-security-testing",level:3},{value:"Scalability Testing",id:"scalability-testing",level:2},{value:"Auto-scaling Validation",id:"auto-scaling-validation",level:3},{value:"Accessibility Testing",id:"accessibility-testing",level:2},{value:"Automated Accessibility Validation",id:"automated-accessibility-validation",level:3},{value:"Compliance Validation",id:"compliance-validation",level:2},{value:"GDPR Compliance Testing",id:"gdpr-compliance-testing",level:3},{value:"Continuous NFR Monitoring",id:"continuous-nfr-monitoring",level:2},{value:"Real-time Quality Dashboard",id:"real-time-quality-dashboard",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"non-functional-requirements-validation",children:"Non-functional Requirements Validation"})}),"\n",(0,s.jsx)(n.p,{children:"This guide establishes comprehensive validation frameworks for non-functional requirements in NestJS microservices and Next.js microfrontend applications, covering performance testing, security validation, scalability assessment, and compliance verification through automated testing and monitoring strategies."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Non-functional requirements (NFRs) define system quality attributes such as performance, security, scalability, reliability, and usability. This validation framework ensures that applications meet these critical requirements through systematic testing, monitoring, and validation processes."}),"\n",(0,s.jsx)(n.h2,{id:"non-functional-requirements-framework",children:"Non-functional Requirements Framework"}),"\n",(0,s.jsx)(n.h3,{id:"complete-nfr-validation-process",children:"Complete NFR Validation Process"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[NFR Definition] --\x3e B[Validation Strategy]\n    B --\x3e C[Test Design]\n    C --\x3e D[Automated Testing]\n    D --\x3e E[Performance Monitoring]\n    \n    E --\x3e F[Security Validation]\n    F --\x3e G[Scalability Testing]\n    G --\x3e H[Reliability Testing]\n    H --\x3e I[Usability Testing]\n    \n    I --\x3e J[Compliance Check]\n    J --\x3e K[Results Analysis]\n    K --\x3e L[Reporting]\n    L --\x3e M[Continuous Monitoring]\n    \n    N[NFR Categories] --\x3e O[Performance]\n    N --\x3e P[Security]\n    N --\x3e Q[Scalability]\n    N --\x3e R[Reliability]\n    N --\x3e S[Usability]\n    N --\x3e T[Compliance]\n    \n    U[Testing Types] --\x3e V[Load Testing]\n    U --\x3e W[Stress Testing]\n    U --\x3e X[Security Testing]\n    U --\x3e Y[Penetration Testing]\n    U --\x3e Z[Accessibility Testing]\n    \n    AA[Validation Tools] --\x3e BB[K6/Artillery]\n    AA --\x3e CC[OWASP ZAP]\n    AA --\x3e DD[Lighthouse]\n    AA --\x3e EE[Axe/Pa11y]\n    AA --\x3e FF[SonarQube]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-requirements-validation",children:"Performance Requirements Validation"}),"\n",(0,s.jsx)(n.h3,{id:"load-testing-with-k6",children:"Load Testing with K6"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// tests/performance/load-tests/user-management.k6.js\nimport http from 'k6/http';\nimport { check, sleep } from 'k6';\nimport { Rate, Trend } from 'k6/metrics';\n\n// Custom metrics\nconst errorRate = new Rate('errors');\nconst responseTimeThreshold = new Trend('response_time_threshold');\n\n// Test configuration\nexport const options = {\n  stages: [\n    { duration: '5m', target: 100 }, // Ramp up to 100 users\n    { duration: '10m', target: 100 }, // Stay at 100 users\n    { duration: '5m', target: 200 }, // Ramp up to 200 users\n    { duration: '10m', target: 200 }, // Stay at 200 users\n    { duration: '5m', target: 0 }, // Ramp down\n  ],\n  thresholds: {\n    http_req_duration: ['p(95)<500'], // 95% of requests under 500ms\n    http_req_failed: ['rate<0.05'], // Error rate under 5%\n    errors: ['rate<0.05'],\n    response_time_threshold: ['p(99)<1000'], // 99% under 1s\n  },\n  ext: {\n    loadimpact: {\n      distribution: {\n        'amazon:us:ashburn': { loadZone: 'amazon:us:ashburn', percent: 50 },\n        'amazon:ie:dublin': { loadZone: 'amazon:ie:dublin', percent: 50 },\n      },\n    },\n  },\n};\n\nconst BASE_URL = __ENV.BASE_URL || 'http://localhost:3000';\nlet authToken;\n\nexport function setup() {\n  // Authenticate and get token\n  const loginResponse = http.post(`${BASE_URL}/auth/login`, {\n    email: 'test@example.com',\n    password: 'password123',\n  });\n\n  check(loginResponse, {\n    'login successful': (r) => r.status === 200,\n  });\n\n  const token = loginResponse.json('access_token');\n  return { authToken: token };\n}\n\nexport default function (data) {\n  authToken = data.authToken;\n\n  // Test user list endpoint\n  testUsersList();\n  sleep(1);\n\n  // Test user creation\n  testUserCreation();\n  sleep(1);\n\n  // Test user update\n  testUserUpdate();\n  sleep(2);\n}\n\nfunction testUsersList() {\n  const response = http.get(`${BASE_URL}/api/users`, {\n    headers: {\n      Authorization: `Bearer ${authToken}`,\n      'Content-Type': 'application/json',\n    },\n  });\n\n  const success = check(response, {\n    'users list status is 200': (r) => r.status === 200,\n    'users list response time < 200ms': (r) => r.timings.duration < 200,\n    'users list returns array': (r) => Array.isArray(r.json()),\n  });\n\n  errorRate.add(!success);\n  responseTimeThreshold.add(response.timings.duration);\n}\n\nfunction testUserCreation() {\n  const userData = {\n    name: `Test User ${__VU}-${__ITER}`,\n    email: `user-${__VU}-${__ITER}@example.com`,\n    password: 'password123',\n  };\n\n  const response = http.post(`${BASE_URL}/api/users`, JSON.stringify(userData), {\n    headers: {\n      Authorization: `Bearer ${authToken}`,\n      'Content-Type': 'application/json',\n    },\n  });\n\n  const success = check(response, {\n    'user creation status is 201': (r) => r.status === 201,\n    'user creation response time < 300ms': (r) => r.timings.duration < 300,\n    'user creation returns user id': (r) => r.json('id') !== undefined,\n  });\n\n  errorRate.add(!success);\n  responseTimeThreshold.add(response.timings.duration);\n\n  return response.json('id');\n}\n\nfunction testUserUpdate() {\n  const userId = Math.floor(Math.random() * 100) + 1;\n  const updateData = {\n    name: `Updated User ${__VU}-${__ITER}`,\n  };\n\n  const response = http.patch(`${BASE_URL}/api/users/${userId}`, JSON.stringify(updateData), {\n    headers: {\n      Authorization: `Bearer ${authToken}`,\n      'Content-Type': 'application/json',\n    },\n  });\n\n  const success = check(response, {\n    'user update status is 200 or 404': (r) => r.status === 200 || r.status === 404,\n    'user update response time < 250ms': (r) => r.timings.duration < 250,\n  });\n\n  errorRate.add(!success && response.status !== 404);\n  responseTimeThreshold.add(response.timings.duration);\n}\n\nexport function teardown(data) {\n  console.log('Load test completed');\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"frontend-performance-testing",children:"Frontend Performance Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// tests/performance/frontend/lighthouse-performance.ts\nimport lighthouse from 'lighthouse';\nimport * as chromeLauncher from 'chrome-launcher';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport interface PerformanceThresholds {\n  performance: number;\n  accessibility: number;\n  bestPractices: number;\n  seo: number;\n  firstContentfulPaint: number;\n  largestContentfulPaint: number;\n  firstInputDelay: number;\n  cumulativeLayoutShift: number;\n}\n\nexport class FrontendPerformanceTester {\n  private defaultThresholds: PerformanceThresholds = {\n    performance: 90,\n    accessibility: 95,\n    bestPractices: 90,\n    seo: 90,\n    firstContentfulPaint: 1500,\n    largestContentfulPaint: 2500,\n    firstInputDelay: 100,\n    cumulativeLayoutShift: 0.1,\n  };\n\n  async runPerformanceTests(\n    urls: string[],\n    thresholds: Partial<PerformanceThresholds> = {}\n  ): Promise<boolean> {\n    const finalThresholds = { ...this.defaultThresholds, ...thresholds };\n    let allTestsPassed = true;\n\n    for (const url of urls) {\n      console.log(`Testing performance for: ${url}`);\n      \n      const chrome = await chromeLauncher.launch({ chromeFlags: ['--headless'] });\n      \n      try {\n        const options = {\n          logLevel: 'info' as const,\n          output: 'json' as const,\n          onlyCategories: ['performance', 'accessibility', 'best-practices', 'seo'],\n          port: chrome.port,\n        };\n\n        const runnerResult = await lighthouse(url, options);\n        \n        if (!runnerResult || !runnerResult.report) {\n          console.error(`Failed to run Lighthouse for ${url}`);\n          allTestsPassed = false;\n          continue;\n        }\n\n        const report = JSON.parse(runnerResult.report);\n        const testResult = this.validatePerformanceResults(report, finalThresholds);\n        \n        if (!testResult.passed) {\n          console.error(`Performance test failed for ${url}:`);\n          testResult.failures.forEach(failure => console.error(`  - ${failure}`));\n          allTestsPassed = false;\n        } else {\n          console.log(`\u2705 Performance test passed for ${url}`);\n        }\n\n        // Save detailed report\n        await this.saveDetailedReport(url, report);\n        \n      } finally {\n        await chrome.kill();\n      }\n    }\n\n    return allTestsPassed;\n  }\n\n  private validatePerformanceResults(\n    report: any,\n    thresholds: PerformanceThresholds\n  ): { passed: boolean; failures: string[] } {\n    const failures: string[] = [];\n    const categories = report.categories;\n    const audits = report.audits;\n\n    // Check category scores\n    if (categories.performance.score * 100 < thresholds.performance) {\n      failures.push(`Performance score: ${Math.round(categories.performance.score * 100)} < ${thresholds.performance}`);\n    }\n\n    if (categories.accessibility.score * 100 < thresholds.accessibility) {\n      failures.push(`Accessibility score: ${Math.round(categories.accessibility.score * 100)} < ${thresholds.accessibility}`);\n    }\n\n    if (categories['best-practices'].score * 100 < thresholds.bestPractices) {\n      failures.push(`Best practices score: ${Math.round(categories['best-practices'].score * 100)} < ${thresholds.bestPractices}`);\n    }\n\n    if (categories.seo.score * 100 < thresholds.seo) {\n      failures.push(`SEO score: ${Math.round(categories.seo.score * 100)} < ${thresholds.seo}`);\n    }\n\n    // Check Core Web Vitals\n    const fcp = audits['first-contentful-paint'].numericValue;\n    if (fcp > thresholds.firstContentfulPaint) {\n      failures.push(`First Contentful Paint: ${Math.round(fcp)}ms > ${thresholds.firstContentfulPaint}ms`);\n    }\n\n    const lcp = audits['largest-contentful-paint'].numericValue;\n    if (lcp > thresholds.largestContentfulPaint) {\n      failures.push(`Largest Contentful Paint: ${Math.round(lcp)}ms > ${thresholds.largestContentfulPaint}ms`);\n    }\n\n    const cls = audits['cumulative-layout-shift'].numericValue;\n    if (cls > thresholds.cumulativeLayoutShift) {\n      failures.push(`Cumulative Layout Shift: ${cls.toFixed(3)} > ${thresholds.cumulativeLayoutShift}`);\n    }\n\n    return {\n      passed: failures.length === 0,\n      failures,\n    };\n  }\n\n  private async saveDetailedReport(url: string, report: any): Promise<void> {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const filename = `performance-${url.replace(/[^a-zA-Z0-9]/g, '_')}-${timestamp}.json`;\n    const filepath = path.join('reports', 'performance', filename);\n\n    // Ensure directory exists\n    const dir = path.dirname(filepath);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n\n    fs.writeFileSync(filepath, JSON.stringify(report, null, 2));\n    console.log(`Detailed performance report saved to: ${filepath}`);\n  }\n}\n\n// Usage example\nasync function runTests() {\n  const tester = new FrontendPerformanceTester();\n  \n  const urls = [\n    'http://localhost:3000',\n    'http://localhost:3000/users',\n    'http://localhost:3000/dashboard',\n  ];\n\n  const customThresholds = {\n    performance: 85, // Slightly lower threshold for complex pages\n    largestContentfulPaint: 3000, // Allow 3s for LCP\n  };\n\n  const passed = await tester.runPerformanceTests(urls, customThresholds);\n  \n  if (!passed) {\n    process.exit(1);\n  }\n}\n\nif (require.main === module) {\n  runTests().catch(console.error);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"security-requirements-validation",children:"Security Requirements Validation"}),"\n",(0,s.jsx)(n.h3,{id:"automated-security-testing",children:"Automated Security Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// tests/security/security-scanner.ts\nimport { ZAPClient } from 'zaproxy';\nimport axios from 'axios';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport interface SecurityTestConfig {\n  targetUrl: string;\n  apiEndpoints: string[];\n  authToken?: string;\n  excludeUrls: string[];\n  scanPolicies: string[];\n}\n\nexport interface SecurityVulnerability {\n  name: string;\n  risk: 'High' | 'Medium' | 'Low' | 'Informational';\n  confidence: 'High' | 'Medium' | 'Low';\n  url: string;\n  param: string;\n  attack: string;\n  evidence: string;\n  description: string;\n  solution: string;\n  cweid: string;\n  wascid: string;\n}\n\nexport class SecurityValidator {\n  private zap: ZAPClient;\n\n  constructor() {\n    this.zap = new ZAPClient({\n      proxy: 'http://localhost:8080',\n    });\n  }\n\n  async runSecurityScan(config: SecurityTestConfig): Promise<SecurityVulnerability[]> {\n    console.log('Starting security scan...');\n    \n    try {\n      // Start ZAP session\n      await this.zap.core.newSession();\n      \n      // Configure authentication if provided\n      if (config.authToken) {\n        await this.configureAuthentication(config);\n      }\n\n      // Spider the application\n      console.log('Spidering application...');\n      await this.spiderApplication(config.targetUrl, config.excludeUrls);\n\n      // Perform active scan\n      console.log('Performing active security scan...');\n      await this.performActiveScan(config.targetUrl, config.scanPolicies);\n\n      // Get results\n      const vulnerabilities = await this.getVulnerabilities();\n      \n      // Generate report\n      await this.generateSecurityReport(vulnerabilities);\n      \n      return vulnerabilities;\n      \n    } catch (error) {\n      console.error('Security scan failed:', error);\n      throw error;\n    }\n  }\n\n  private async configureAuthentication(config: SecurityTestConfig): Promise<void> {\n    // Configure session management\n    await this.zap.authentication.setAuthenticationMethod(0, 'httpAuthentication', \n      `authUrl=${config.targetUrl}/auth/login&loginUrl=${config.targetUrl}/auth/login`\n    );\n\n    // Set authentication headers\n    await this.zap.replacer.addRule('Authorization', `Bearer ${config.authToken}`, '', true, true);\n  }\n\n  private async spiderApplication(targetUrl: string, excludeUrls: string[]): Promise<void> {\n    // Add target to scope\n    await this.zap.core.includeInContext('Default Context', `${targetUrl}.*`);\n    \n    // Exclude URLs that shouldn't be tested\n    for (const excludeUrl of excludeUrls) {\n      await this.zap.core.excludeFromContext('Default Context', excludeUrl);\n    }\n\n    // Start spider\n    const spiderId = await this.zap.spider.scan(targetUrl);\n    \n    // Wait for spider to complete\n    let progress = 0;\n    while (progress < 100) {\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      const status = await this.zap.spider.status(spiderId);\n      progress = parseInt(status);\n      console.log(`Spider progress: ${progress}%`);\n    }\n  }\n\n  private async performActiveScan(targetUrl: string, scanPolicies: string[]): Promise<void> {\n    // Configure scan policies\n    for (const policy of scanPolicies) {\n      await this.zap.ascan.enableScanners(policy);\n    }\n\n    // Start active scan\n    const scanId = await this.zap.ascan.scan(targetUrl);\n    \n    // Wait for scan to complete\n    let progress = 0;\n    while (progress < 100) {\n      await new Promise(resolve => setTimeout(resolve, 5000));\n      const status = await this.zap.ascan.status(scanId);\n      progress = parseInt(status);\n      console.log(`Active scan progress: ${progress}%`);\n    }\n  }\n\n  private async getVulnerabilities(): Promise<SecurityVulnerability[]> {\n    const alerts = await this.zap.core.alerts();\n    \n    return alerts.map((alert: any) => ({\n      name: alert.name,\n      risk: alert.risk,\n      confidence: alert.confidence,\n      url: alert.url,\n      param: alert.param,\n      attack: alert.attack,\n      evidence: alert.evidence,\n      description: alert.description,\n      solution: alert.solution,\n      cweid: alert.cweid,\n      wascid: alert.wascid,\n    }));\n  }\n\n  private async generateSecurityReport(vulnerabilities: SecurityVulnerability[]): Promise<void> {\n    const report = {\n      timestamp: new Date().toISOString(),\n      totalVulnerabilities: vulnerabilities.length,\n      riskDistribution: this.calculateRiskDistribution(vulnerabilities),\n      vulnerabilities,\n    };\n\n    const reportPath = path.join('reports', 'security', `security-scan-${Date.now()}.json`);\n    \n    // Ensure directory exists\n    const dir = path.dirname(reportPath);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n\n    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\n    console.log(`Security report saved to: ${reportPath}`);\n  }\n\n  private calculateRiskDistribution(vulnerabilities: SecurityVulnerability[]) {\n    return vulnerabilities.reduce((acc, vuln) => {\n      acc[vuln.risk] = (acc[vuln.risk] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n  }\n}\n\n// API Security Testing\nexport class APISecurityTester {\n  async testAPIEndpoints(baseUrl: string, endpoints: string[], authToken?: string): Promise<void> {\n    const headers = authToken ? { Authorization: `Bearer ${authToken}` } : {};\n\n    for (const endpoint of endpoints) {\n      await this.testSQLInjection(baseUrl + endpoint, headers);\n      await this.testXSSVulnerabilities(baseUrl + endpoint, headers);\n      await this.testAuthentication(baseUrl + endpoint);\n      await this.testAuthorization(baseUrl + endpoint, headers);\n      await this.testRateLimiting(baseUrl + endpoint, headers);\n    }\n  }\n\n  private async testSQLInjection(url: string, headers: any): Promise<void> {\n    const sqlPayloads = [\n      \"' OR '1'='1\",\n      \"'; DROP TABLE users; --\",\n      \"' UNION SELECT * FROM users --\",\n      \"1' AND 1=1 --\",\n    ];\n\n    for (const payload of sqlPayloads) {\n      try {\n        const response = await axios.get(url, {\n          params: { q: payload },\n          headers,\n          timeout: 5000,\n        });\n\n        // Check for SQL error messages\n        if (response.data.includes('SQL') || \n            response.data.includes('mysql') || \n            response.data.includes('postgres')) {\n          console.warn(`\u26a0\ufe0f  Potential SQL injection vulnerability in ${url}`);\n        }\n      } catch (error) {\n        // Expected for malformed requests\n      }\n    }\n  }\n\n  private async testXSSVulnerabilities(url: string, headers: any): Promise<void> {\n    const xssPayloads = [\n      \"<script>alert('XSS')<\/script>\",\n      \"javascript:alert('XSS')\",\n      \"<img src=x onerror=alert('XSS')>\",\n      \"';alert('XSS');//\",\n    ];\n\n    for (const payload of xssPayloads) {\n      try {\n        const response = await axios.post(url, { data: payload }, { headers });\n\n        if (response.data.includes(payload)) {\n          console.warn(`\u26a0\ufe0f  Potential XSS vulnerability in ${url}`);\n        }\n      } catch (error) {\n        // Expected for malformed requests\n      }\n    }\n  }\n\n  private async testAuthentication(url: string): Promise<void> {\n    try {\n      const response = await axios.get(url);\n      \n      if (response.status === 200) {\n        console.warn(`\u26a0\ufe0f  Endpoint ${url} accessible without authentication`);\n      }\n    } catch (error) {\n      // Expected - endpoint should require authentication\n    }\n  }\n\n  private async testAuthorization(url: string, headers: any): Promise<void> {\n    // Test with modified/expired token\n    const modifiedHeaders = {\n      ...headers,\n      Authorization: headers.Authorization?.replace(/.$/, 'X'), // Modify last character\n    };\n\n    try {\n      const response = await axios.get(url, { headers: modifiedHeaders });\n      \n      if (response.status === 200) {\n        console.warn(`\u26a0\ufe0f  Endpoint ${url} accessible with invalid token`);\n      }\n    } catch (error) {\n      // Expected - should reject invalid tokens\n    }\n  }\n\n  private async testRateLimiting(url: string, headers: any): Promise<void> {\n    const requests = Array.from({ length: 100 }, () => \n      axios.get(url, { headers, timeout: 1000 }).catch(() => null)\n    );\n\n    const responses = await Promise.all(requests);\n    const successfulRequests = responses.filter(r => r && r.status === 200).length;\n\n    if (successfulRequests > 50) {\n      console.warn(`\u26a0\ufe0f  Potential rate limiting issue in ${url}: ${successfulRequests}/100 requests succeeded`);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"scalability-testing",children:"Scalability Testing"}),"\n",(0,s.jsx)(n.h3,{id:"auto-scaling-validation",children:"Auto-scaling Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// tests/scalability/auto-scaling-test.ts\nimport { execSync } from 'child_process';\nimport axios from 'axios';\nimport * as k8s from '@kubernetes/client-node';\n\nexport interface ScalabilityTest {\n  name: string;\n  targetLoad: number;\n  expectedScaling: {\n    minReplicas: number;\n    maxReplicas: number;\n    targetCPU: number;\n    targetMemory: number;\n  };\n  duration: number;\n}\n\nexport class ScalabilityValidator {\n  private k8sApi: k8s.AppsV1Api;\n  private metricsApi: k8s.Metrics;\n\n  constructor() {\n    const kc = new k8s.KubeConfig();\n    kc.loadFromDefault();\n    \n    this.k8sApi = kc.makeApiClient(k8s.AppsV1Api);\n    this.metricsApi = new k8s.Metrics(kc);\n  }\n\n  async runScalabilityTest(test: ScalabilityTest): Promise<boolean> {\n    console.log(`Starting scalability test: ${test.name}`);\n    \n    try {\n      // Record initial state\n      const initialMetrics = await this.getCurrentMetrics();\n      \n      // Generate load\n      await this.generateLoad(test.targetLoad, test.duration);\n      \n      // Monitor scaling behavior\n      const scalingResults = await this.monitorScaling(test);\n      \n      // Validate results\n      const passed = this.validateScalingBehavior(scalingResults, test.expectedScaling);\n      \n      // Generate report\n      await this.generateScalabilityReport(test, initialMetrics, scalingResults, passed);\n      \n      return passed;\n      \n    } catch (error) {\n      console.error(`Scalability test failed: ${error}`);\n      return false;\n    }\n  }\n\n  private async generateLoad(targetRPS: number, duration: number): Promise<void> {\n    const k6Script = `\n      import http from 'k6/http';\n      import { check } from 'k6';\n      \n      export let options = {\n        stages: [\n          { duration: '30s', target: ${targetRPS} },\n          { duration: '${duration}s', target: ${targetRPS} },\n          { duration: '30s', target: 0 },\n        ],\n      };\n      \n      export default function() {\n        let response = http.get('${process.env.TARGET_URL || 'http://localhost:3000'}/api/health');\n        check(response, {\n          'status is 200': (r) => r.status === 200,\n        });\n      }\n    `;\n\n    // Write temporary K6 script\n    require('fs').writeFileSync('/tmp/load-test.js', k6Script);\n    \n    // Run load test in background\n    const loadTestProcess = execSync('k6 run /tmp/load-test.js', { \n      stdio: 'pipe',\n      timeout: (duration + 120) * 1000,\n    });\n\n    console.log('Load test completed');\n  }\n\n  private async monitorScaling(test: ScalabilityTest): Promise<any> {\n    const metrics: any[] = [];\n    const startTime = Date.now();\n    const monitorDuration = (test.duration + 120) * 1000; // Monitor for test duration + buffer\n\n    while (Date.now() - startTime < monitorDuration) {\n      try {\n        const currentMetrics = await this.getCurrentMetrics();\n        metrics.push({\n          timestamp: new Date().toISOString(),\n          ...currentMetrics,\n        });\n\n        console.log(`Replicas: ${currentMetrics.replicas}, CPU: ${currentMetrics.avgCPU}%, Memory: ${currentMetrics.avgMemory}%`);\n        \n        // Wait 30 seconds before next measurement\n        await new Promise(resolve => setTimeout(resolve, 30000));\n        \n      } catch (error) {\n        console.error('Error collecting metrics:', error);\n      }\n    }\n\n    return metrics;\n  }\n\n  private async getCurrentMetrics(): Promise<any> {\n    // Get deployment info\n    const deployment = await this.k8sApi.readNamespacedDeployment('app-backend', 'default');\n    const replicas = deployment.body.status?.replicas || 0;\n\n    // Get pod metrics\n    const podMetrics = await this.metricsApi.getPodMetrics('default');\n    \n    let totalCPU = 0;\n    let totalMemory = 0;\n    let podCount = 0;\n\n    for (const pod of podMetrics.body.items) {\n      if (pod.metadata?.name?.startsWith('app-backend')) {\n        podCount++;\n        \n        for (const container of pod.containers) {\n          // Parse CPU usage (convert from nano cores)\n          const cpuUsage = parseInt(container.usage.cpu.replace('n', '')) / 1000000; // Convert to millicores\n          totalCPU += cpuUsage;\n          \n          // Parse memory usage (convert from Ki to MB)\n          const memoryUsage = parseInt(container.usage.memory.replace('Ki', '')) / 1024;\n          totalMemory += memoryUsage;\n        }\n      }\n    }\n\n    return {\n      replicas,\n      avgCPU: podCount > 0 ? totalCPU / podCount : 0,\n      avgMemory: podCount > 0 ? totalMemory / podCount : 0,\n      podCount,\n    };\n  }\n\n  private validateScalingBehavior(metrics: any[], expected: any): boolean {\n    if (metrics.length === 0) {\n      console.error('No metrics collected');\n      return false;\n    }\n\n    // Find peak metrics\n    const peakReplicas = Math.max(...metrics.map(m => m.replicas));\n    const peakCPU = Math.max(...metrics.map(m => m.avgCPU));\n    const peakMemory = Math.max(...metrics.map(m => m.avgMemory));\n\n    console.log(`Peak metrics - Replicas: ${peakReplicas}, CPU: ${peakCPU}%, Memory: ${peakMemory}%`);\n\n    // Validate scaling behavior\n    const scalingValidation = {\n      replicasInRange: peakReplicas >= expected.minReplicas && peakReplicas <= expected.maxReplicas,\n      cpuUnderLimit: peakCPU <= expected.targetCPU * 1.2, // Allow 20% buffer\n      memoryUnderLimit: peakMemory <= expected.targetMemory * 1.2,\n      scalingOccurred: peakReplicas > expected.minReplicas,\n    };\n\n    const passed = Object.values(scalingValidation).every(v => v);\n\n    if (!passed) {\n      console.error('Scaling validation failed:', scalingValidation);\n    }\n\n    return passed;\n  }\n\n  private async generateScalabilityReport(\n    test: ScalabilityTest,\n    initialMetrics: any,\n    scalingResults: any[],\n    passed: boolean\n  ): Promise<void> {\n    const report = {\n      testName: test.name,\n      timestamp: new Date().toISOString(),\n      passed,\n      initialMetrics,\n      scalingResults,\n      summary: {\n        maxReplicas: Math.max(...scalingResults.map(m => m.replicas)),\n        maxCPU: Math.max(...scalingResults.map(m => m.avgCPU)),\n        maxMemory: Math.max(...scalingResults.map(m => m.avgMemory)),\n        averageReplicas: scalingResults.reduce((sum, m) => sum + m.replicas, 0) / scalingResults.length,\n      },\n    };\n\n    const reportPath = `reports/scalability/scalability-${test.name}-${Date.now()}.json`;\n    require('fs').writeFileSync(reportPath, JSON.stringify(report, null, 2));\n    console.log(`Scalability report saved to: ${reportPath}`);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"accessibility-testing",children:"Accessibility Testing"}),"\n",(0,s.jsx)(n.h3,{id:"automated-accessibility-validation",children:"Automated Accessibility Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// tests/accessibility/accessibility-validator.ts\nimport { AxePuppeteer } from '@axe-core/puppeteer';\nimport puppeteer from 'puppeteer';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport interface AccessibilityTest {\n  url: string;\n  name: string;\n  tags?: string[];\n  rules?: string[];\n  disableRules?: string[];\n}\n\nexport interface AccessibilityViolation {\n  id: string;\n  impact: 'minor' | 'moderate' | 'serious' | 'critical';\n  description: string;\n  help: string;\n  helpUrl: string;\n  nodes: Array<{\n    html: string;\n    target: string[];\n    failureSummary: string;\n  }>;\n}\n\nexport class AccessibilityValidator {\n  async runAccessibilityTests(tests: AccessibilityTest[]): Promise<boolean> {\n    console.log('Starting accessibility validation...');\n    \n    const browser = await puppeteer.launch({\n      headless: true,\n      args: ['--no-sandbox', '--disable-setuid-sandbox'],\n    });\n\n    let allTestsPassed = true;\n\n    try {\n      for (const test of tests) {\n        console.log(`Testing accessibility for: ${test.name}`);\n        \n        const page = await browser.newPage();\n        \n        try {\n          // Navigate to page\n          await page.goto(test.url, { waitUntil: 'networkidle0' });\n          \n          // Wait for dynamic content\n          await page.waitForTimeout(2000);\n          \n          // Configure axe\n          const axe = new AxePuppeteer(page);\n          \n          if (test.tags) {\n            axe.withTags(test.tags);\n          }\n          \n          if (test.rules) {\n            axe.withRules(test.rules);\n          }\n          \n          if (test.disableRules) {\n            axe.disableRules(test.disableRules);\n          }\n\n          // Run accessibility scan\n          const results = await axe.analyze();\n          \n          // Process results\n          const testPassed = this.processResults(test, results);\n          \n          if (!testPassed) {\n            allTestsPassed = false;\n          }\n          \n        } finally {\n          await page.close();\n        }\n      }\n    } finally {\n      await browser.close();\n    }\n\n    return allTestsPassed;\n  }\n\n  private processResults(test: AccessibilityTest, results: any): boolean {\n    const violations: AccessibilityViolation[] = results.violations.map((violation: any) => ({\n      id: violation.id,\n      impact: violation.impact,\n      description: violation.description,\n      help: violation.help,\n      helpUrl: violation.helpUrl,\n      nodes: violation.nodes.map((node: any) => ({\n        html: node.html,\n        target: node.target,\n        failureSummary: node.failureSummary,\n      })),\n    }));\n\n    // Log results\n    if (violations.length === 0) {\n      console.log(`\u2705 ${test.name}: No accessibility violations found`);\n      return true;\n    } else {\n      console.error(`\u274c ${test.name}: ${violations.length} accessibility violations found`);\n      \n      // Group violations by impact\n      const violationsByImpact = violations.reduce((acc, violation) => {\n        acc[violation.impact] = (acc[violation.impact] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n\n      console.error('Violations by impact:', violationsByImpact);\n      \n      // Save detailed report\n      this.saveAccessibilityReport(test, violations);\n      \n      // Determine if test should fail based on impact\n      const criticalViolations = violations.filter(v => v.impact === 'critical').length;\n      const seriousViolations = violations.filter(v => v.impact === 'serious').length;\n      \n      // Fail test if there are critical or more than 5 serious violations\n      return criticalViolations === 0 && seriousViolations <= 5;\n    }\n  }\n\n  private saveAccessibilityReport(test: AccessibilityTest, violations: AccessibilityViolation[]): void {\n    const report = {\n      testName: test.name,\n      url: test.url,\n      timestamp: new Date().toISOString(),\n      violationCount: violations.length,\n      violations,\n    };\n\n    const reportPath = path.join('reports', 'accessibility', `a11y-${test.name.replace(/\\s+/g, '-')}-${Date.now()}.json`);\n    \n    // Ensure directory exists\n    const dir = path.dirname(reportPath);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n\n    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\n    console.log(`Accessibility report saved to: ${reportPath}`);\n  }\n}\n\n// Specific accessibility tests for common scenarios\nexport class AccessibilityTestSuite {\n  private validator = new AccessibilityValidator();\n\n  async runFullSuite(baseUrl: string): Promise<boolean> {\n    const tests: AccessibilityTest[] = [\n      {\n        name: 'Homepage',\n        url: `${baseUrl}/`,\n        tags: ['wcag2a', 'wcag2aa'],\n      },\n      {\n        name: 'Login Page',\n        url: `${baseUrl}/login`,\n        tags: ['wcag2a', 'wcag2aa'],\n      },\n      {\n        name: 'User Dashboard',\n        url: `${baseUrl}/dashboard`,\n        tags: ['wcag2a', 'wcag2aa'],\n      },\n      {\n        name: 'Forms - User Registration',\n        url: `${baseUrl}/register`,\n        tags: ['wcag2a', 'wcag2aa'],\n        rules: ['label', 'color-contrast', 'keyboard-navigation'],\n      },\n      {\n        name: 'Navigation and Menus',\n        url: `${baseUrl}/`,\n        tags: ['wcag2a'],\n        rules: ['focus-order-semantics', 'link-purpose', 'skip-link'],\n      },\n      {\n        name: 'Data Tables',\n        url: `${baseUrl}/users`,\n        tags: ['wcag2a', 'wcag2aa'],\n        rules: ['table-headers', 'table-caption'],\n      },\n    ];\n\n    return await this.validator.runAccessibilityTests(tests);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"compliance-validation",children:"Compliance Validation"}),"\n",(0,s.jsx)(n.h3,{id:"gdpr-compliance-testing",children:"GDPR Compliance Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// tests/compliance/gdpr-validator.ts\nimport axios from 'axios';\nimport * as puppeteer from 'puppeteer';\n\nexport interface GDPRComplianceCheck {\n  name: string;\n  endpoint?: string;\n  pageUrl?: string;\n  expected: {\n    cookieConsent: boolean;\n    privacyPolicy: boolean;\n    dataPortability: boolean;\n    rightToErasure: boolean;\n    consentWithdrawal: boolean;\n  };\n}\n\nexport class GDPRComplianceValidator {\n  async validateGDPRCompliance(baseUrl: string): Promise<boolean> {\n    console.log('Starting GDPR compliance validation...');\n    \n    const checks: GDPRComplianceCheck[] = [\n      {\n        name: 'Cookie Consent Banner',\n        pageUrl: `${baseUrl}/`,\n        expected: {\n          cookieConsent: true,\n          privacyPolicy: false,\n          dataPortability: false,\n          rightToErasure: false,\n          consentWithdrawal: false,\n        },\n      },\n      {\n        name: 'Privacy Policy Accessibility',\n        pageUrl: `${baseUrl}/privacy`,\n        expected: {\n          cookieConsent: false,\n          privacyPolicy: true,\n          dataPortability: false,\n          rightToErasure: false,\n          consentWithdrawal: false,\n        },\n      },\n      {\n        name: 'Data Export Functionality',\n        endpoint: `${baseUrl}/api/users/me/export`,\n        expected: {\n          cookieConsent: false,\n          privacyPolicy: false,\n          dataPortability: true,\n          rightToErasure: false,\n          consentWithdrawal: false,\n        },\n      },\n      {\n        name: 'Account Deletion',\n        endpoint: `${baseUrl}/api/users/me`,\n        expected: {\n          cookieConsent: false,\n          privacyPolicy: false,\n          dataPortability: false,\n          rightToErasure: true,\n          consentWithdrawal: false,\n        },\n      },\n      {\n        name: 'Consent Management',\n        pageUrl: `${baseUrl}/settings/privacy`,\n        expected: {\n          cookieConsent: false,\n          privacyPolicy: false,\n          dataPortability: false,\n          rightToErasure: false,\n          consentWithdrawal: true,\n        },\n      },\n    ];\n\n    let allChecksPassed = true;\n\n    for (const check of checks) {\n      try {\n        const result = await this.performGDPRCheck(check);\n        \n        if (!result) {\n          console.error(`\u274c GDPR check failed: ${check.name}`);\n          allChecksPassed = false;\n        } else {\n          console.log(`\u2705 GDPR check passed: ${check.name}`);\n        }\n      } catch (error) {\n        console.error(`\u274c GDPR check error for ${check.name}:`, error);\n        allChecksPassed = false;\n      }\n    }\n\n    return allChecksPassed;\n  }\n\n  private async performGDPRCheck(check: GDPRComplianceCheck): Promise<boolean> {\n    if (check.pageUrl) {\n      return this.checkPageCompliance(check);\n    } else if (check.endpoint) {\n      return this.checkAPICompliance(check);\n    }\n    \n    return false;\n  }\n\n  private async checkPageCompliance(check: GDPRComplianceCheck): Promise<boolean> {\n    const browser = await puppeteer.launch({ headless: true });\n    \n    try {\n      const page = await browser.newPage();\n      await page.goto(check.pageUrl!, { waitUntil: 'networkidle0' });\n\n      let checksPassed = true;\n\n      if (check.expected.cookieConsent) {\n        const cookieBanner = await page.$('[data-testid=\"cookie-consent\"], .cookie-banner, .cookie-notice');\n        if (!cookieBanner) {\n          console.error('Cookie consent banner not found');\n          checksPassed = false;\n        }\n\n        // Check for reject option\n        const rejectButton = await page.$('[data-testid=\"reject-cookies\"], button:contains(\"Reject\"), button:contains(\"Decline\")');\n        if (!rejectButton) {\n          console.error('Cookie rejection option not found');\n          checksPassed = false;\n        }\n      }\n\n      if (check.expected.privacyPolicy) {\n        const privacyContent = await page.$('[data-testid=\"privacy-policy\"], .privacy-policy');\n        if (!privacyContent) {\n          console.error('Privacy policy content not found');\n          checksPassed = false;\n        }\n\n        // Check for required GDPR elements\n        const pageContent = await page.content();\n        const requiredTerms = [\n          'data controller',\n          'legal basis',\n          'data retention',\n          'right to access',\n          'right to rectification',\n          'right to erasure',\n          'right to portability',\n        ];\n\n        for (const term of requiredTerms) {\n          if (!pageContent.toLowerCase().includes(term)) {\n            console.error(`Privacy policy missing required term: ${term}`);\n            checksPassed = false;\n          }\n        }\n      }\n\n      if (check.expected.consentWithdrawal) {\n        const consentSettings = await page.$('[data-testid=\"consent-settings\"], .consent-management');\n        if (!consentSettings) {\n          console.error('Consent management interface not found');\n          checksPassed = false;\n        }\n      }\n\n      return checksPassed;\n      \n    } finally {\n      await browser.close();\n    }\n  }\n\n  private async checkAPICompliance(check: GDPRComplianceCheck): Promise<boolean> {\n    // This would require authentication in real scenarios\n    const authToken = process.env.TEST_AUTH_TOKEN;\n    \n    if (!authToken) {\n      console.warn('No auth token provided for API compliance check');\n      return true; // Skip if no auth available\n    }\n\n    const headers = {\n      Authorization: `Bearer ${authToken}`,\n      'Content-Type': 'application/json',\n    };\n\n    if (check.expected.dataPortability) {\n      try {\n        const response = await axios.get(check.endpoint!, { headers });\n        \n        if (response.status !== 200) {\n          console.error('Data export endpoint not accessible');\n          return false;\n        }\n\n        // Check if response contains user data in structured format\n        const data = response.data;\n        if (!data || typeof data !== 'object') {\n          console.error('Data export does not return structured data');\n          return false;\n        }\n\n        // Check for personal data fields\n        const expectedFields = ['email', 'name', 'created_at'];\n        for (const field of expectedFields) {\n          if (!(field in data)) {\n            console.error(`Data export missing field: ${field}`);\n            return false;\n          }\n        }\n\n      } catch (error) {\n        console.error('Data export endpoint failed:', error);\n        return false;\n      }\n    }\n\n    if (check.expected.rightToErasure) {\n      try {\n        // Check if DELETE method is supported\n        const response = await axios.delete(check.endpoint!, { \n          headers,\n          validateStatus: () => true, // Don't throw on any status\n        });\n        \n        if (response.status !== 200 && response.status !== 204) {\n          console.error('Account deletion endpoint not properly implemented');\n          return false;\n        }\n\n      } catch (error) {\n        console.error('Account deletion endpoint failed:', error);\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"continuous-nfr-monitoring",children:"Continuous NFR Monitoring"}),"\n",(0,s.jsx)(n.h3,{id:"real-time-quality-dashboard",children:"Real-time Quality Dashboard"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// tools/monitoring/nfr-monitor.ts\nexport interface NFRMetrics {\n  performance: {\n    responseTime: number;\n    throughput: number;\n    errorRate: number;\n    availability: number;\n  };\n  security: {\n    vulnerabilityCount: number;\n    lastScanDate: Date;\n    securityScore: number;\n  };\n  scalability: {\n    currentReplicas: number;\n    cpuUtilization: number;\n    memoryUtilization: number;\n    autoScalingEvents: number;\n  };\n  reliability: {\n    uptime: number;\n    mtbf: number; // Mean Time Between Failures\n    mttr: number; // Mean Time To Recovery\n  };\n  usability: {\n    accessibilityScore: number;\n    performanceScore: number;\n    lastAuditDate: Date;\n  };\n}\n\nexport class NFRMonitor {\n  async collectMetrics(): Promise<NFRMetrics> {\n    const [performance, security, scalability, reliability, usability] = await Promise.all([\n      this.collectPerformanceMetrics(),\n      this.collectSecurityMetrics(),\n      this.collectScalabilityMetrics(),\n      this.collectReliabilityMetrics(),\n      this.collectUsabilityMetrics(),\n    ]);\n\n    return {\n      performance,\n      security,\n      scalability,\n      reliability,\n      usability,\n    };\n  }\n\n  private async collectPerformanceMetrics() {\n    // Implementation would integrate with monitoring tools like Prometheus\n    return {\n      responseTime: 150, // ms\n      throughput: 1200, // requests/second\n      errorRate: 0.5, // percentage\n      availability: 99.9, // percentage\n    };\n  }\n\n  private async collectSecurityMetrics() {\n    return {\n      vulnerabilityCount: 2,\n      lastScanDate: new Date(),\n      securityScore: 85,\n    };\n  }\n\n  private async collectScalabilityMetrics() {\n    return {\n      currentReplicas: 3,\n      cpuUtilization: 65,\n      memoryUtilization: 70,\n      autoScalingEvents: 5,\n    };\n  }\n\n  private async collectReliabilityMetrics() {\n    return {\n      uptime: 99.95,\n      mtbf: 720, // hours\n      mttr: 15, // minutes\n    };\n  }\n\n  private async collectUsabilityMetrics() {\n    return {\n      accessibilityScore: 92,\n      performanceScore: 88,\n      lastAuditDate: new Date(),\n    };\n  }\n\n  async validateNFRThresholds(metrics: NFRMetrics): Promise<boolean> {\n    const thresholds = {\n      performance: {\n        responseTime: 500,\n        errorRate: 1.0,\n        availability: 99.5,\n      },\n      security: {\n        maxVulnerabilities: 5,\n        minSecurityScore: 80,\n      },\n      scalability: {\n        maxCpuUtilization: 80,\n        maxMemoryUtilization: 85,\n      },\n      reliability: {\n        minUptime: 99.0,\n        maxMttr: 30,\n      },\n      usability: {\n        minAccessibilityScore: 90,\n        minPerformanceScore: 85,\n      },\n    };\n\n    const violations: string[] = [];\n\n    // Check performance thresholds\n    if (metrics.performance.responseTime > thresholds.performance.responseTime) {\n      violations.push(`Response time: ${metrics.performance.responseTime}ms > ${thresholds.performance.responseTime}ms`);\n    }\n\n    if (metrics.performance.errorRate > thresholds.performance.errorRate) {\n      violations.push(`Error rate: ${metrics.performance.errorRate}% > ${thresholds.performance.errorRate}%`);\n    }\n\n    if (metrics.performance.availability < thresholds.performance.availability) {\n      violations.push(`Availability: ${metrics.performance.availability}% < ${thresholds.performance.availability}%`);\n    }\n\n    // Check security thresholds\n    if (metrics.security.vulnerabilityCount > thresholds.security.maxVulnerabilities) {\n      violations.push(`Vulnerabilities: ${metrics.security.vulnerabilityCount} > ${thresholds.security.maxVulnerabilities}`);\n    }\n\n    if (metrics.security.securityScore < thresholds.security.minSecurityScore) {\n      violations.push(`Security score: ${metrics.security.securityScore} < ${thresholds.security.minSecurityScore}`);\n    }\n\n    // Check scalability thresholds\n    if (metrics.scalability.cpuUtilization > thresholds.scalability.maxCpuUtilization) {\n      violations.push(`CPU utilization: ${metrics.scalability.cpuUtilization}% > ${thresholds.scalability.maxCpuUtilization}%`);\n    }\n\n    if (metrics.scalability.memoryUtilization > thresholds.scalability.maxMemoryUtilization) {\n      violations.push(`Memory utilization: ${metrics.scalability.memoryUtilization}% > ${thresholds.scalability.maxMemoryUtilization}%`);\n    }\n\n    // Check reliability thresholds\n    if (metrics.reliability.uptime < thresholds.reliability.minUptime) {\n      violations.push(`Uptime: ${metrics.reliability.uptime}% < ${thresholds.reliability.minUptime}%`);\n    }\n\n    if (metrics.reliability.mttr > thresholds.reliability.maxMttr) {\n      violations.push(`MTTR: ${metrics.reliability.mttr}min > ${thresholds.reliability.maxMttr}min`);\n    }\n\n    // Check usability thresholds\n    if (metrics.usability.accessibilityScore < thresholds.usability.minAccessibilityScore) {\n      violations.push(`Accessibility score: ${metrics.usability.accessibilityScore} < ${thresholds.usability.minAccessibilityScore}`);\n    }\n\n    if (metrics.usability.performanceScore < thresholds.usability.minPerformanceScore) {\n      violations.push(`Performance score: ${metrics.usability.performanceScore} < ${thresholds.usability.minPerformanceScore}`);\n    }\n\n    if (violations.length > 0) {\n      console.error('NFR threshold violations:', violations);\n      return false;\n    }\n\n    console.log('\u2705 All NFR thresholds met');\n    return true;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-validation/architecture-evaluation",children:"Architecture Evaluation Process"})})," - Comprehensive evaluation framework"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-validation/continuous-testing",children:"Continuous Testing"})})," - Automated testing strategies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/performance-testing",children:"Performance Testing"})})," - Detailed performance validation"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"This non-functional requirements validation guide should be regularly updated to incorporate new testing tools and compliance requirements."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},5741:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(9729);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);