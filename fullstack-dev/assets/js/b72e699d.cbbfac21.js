"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[8245],{7814:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(9729);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}},8618:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"security-practices/security-implementation/authentication-authorization","title":"Authentication and Authorization Implementation","description":"Overview","source":"@site/docs/security-practices/security-implementation/authentication-authorization.md","sourceDirName":"security-practices/security-implementation","slug":"/security-practices/security-implementation/authentication-authorization","permalink":"/fullstack-dev/docs/security-practices/security-implementation/authentication-authorization","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/security-practices/security-implementation/authentication-authorization.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Security Implementation Guides","permalink":"/fullstack-dev/docs/security-practices/security-implementation/"},"next":{"title":"Personal Identifiable Information (PII) Protection Implementation","permalink":"/fullstack-dev/docs/security-practices/security-implementation/pii-protection"}}');var r=s(5813),i=s(7814);const o={},a="Authentication and Authorization Implementation",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"JWT Authentication Implementation",id:"jwt-authentication-implementation",level:2},{value:"1. JWT Service with Refresh Tokens",id:"1-jwt-service-with-refresh-tokens",level:3},{value:"2. JWT Strategy and Guards",id:"2-jwt-strategy-and-guards",level:3},{value:"Role-Based Access Control (RBAC)",id:"role-based-access-control-rbac",level:2},{value:"1. RBAC Entities",id:"1-rbac-entities",level:3},{value:"2. RBAC Guard Implementation",id:"2-rbac-guard-implementation",level:3},{value:"3. Resource-Based Authorization",id:"3-resource-based-authorization",level:3},{value:"Session Management",id:"session-management",level:2},{value:"1. Session Configuration",id:"1-session-configuration",level:3},{value:"2. Session Service",id:"2-session-service",level:3},{value:"Multi-Factor Authentication",id:"multi-factor-authentication",level:2},{value:"1. TOTP (Time-based One-Time Password) Implementation",id:"1-totp-time-based-one-time-password-implementation",level:3},{value:"2. MFA Guard",id:"2-mfa-guard",level:3},{value:"Password Policies",id:"password-policies",level:2},{value:"1. Password Service",id:"1-password-service",level:3},{value:"OAuth Integration",id:"oauth-integration",level:2},{value:"1. Google OAuth Strategy",id:"1-google-oauth-strategy",level:3},{value:"2. OAuth Service",id:"2-oauth-service",level:3},{value:"Security Headers and CORS",id:"security-headers-and-cors",level:2},{value:"1. Security Middleware",id:"1-security-middleware",level:3},{value:"2. CORS Configuration",id:"2-cors-configuration",level:3},{value:"Testing",id:"testing",level:2},{value:"1. Authentication Tests",id:"1-authentication-tests",level:3},{value:"Deployment Checklist",id:"deployment-checklist",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"authentication-and-authorization-implementation",children:"Authentication and Authorization Implementation"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"This document provides comprehensive implementation guidelines for secure authentication and authorization in NestJS/Next.js applications, including JWT tokens, session management, role-based access control, and multi-factor authentication."}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#jwt-authentication-implementation",children:"JWT Authentication Implementation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#role-based-access-control-rbac",children:"Role-Based Access Control (RBAC)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#session-management",children:"Session Management"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#multi-factor-authentication",children:"Multi-Factor Authentication"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#password-policies",children:"Password Policies"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#oauth-integration",children:"OAuth Integration"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#security-headers-and-cors",children:"Security Headers and CORS"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"jwt-authentication-implementation",children:"JWT Authentication Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"1-jwt-service-with-refresh-tokens",children:"1. JWT Service with Refresh Tokens"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/jwt.service.ts\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { JwtService as NestJwtService } from '@nestjs/jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { RefreshToken } from './entities/refresh-token.entity';\nimport { User } from '../users/entities/user.entity';\nimport { randomBytes } from 'crypto';\n\n@Injectable()\nexport class JwtService {\n  constructor(\n    private jwtService: NestJwtService,\n    private configService: ConfigService,\n    @InjectRepository(RefreshToken)\n    private refreshTokenRepository: Repository<RefreshToken>,\n  ) {}\n\n  async generateTokens(user: User): Promise<{ accessToken: string; refreshToken: string }> {\n    const payload = {\n      sub: user.id,\n      email: user.email,\n      roles: user.roles,\n      permissions: user.permissions,\n    };\n\n    const accessToken = this.jwtService.sign(payload, {\n      expiresIn: this.configService.get('JWT_ACCESS_EXPIRES_IN', '15m'),\n    });\n\n    const refreshToken = await this.generateRefreshToken(user.id);\n\n    return { accessToken, refreshToken };\n  }\n\n  async generateRefreshToken(userId: string): Promise<string> {\n    // Invalidate existing refresh tokens\n    await this.refreshTokenRepository.update(\n      { userId, isActive: true },\n      { isActive: false }\n    );\n\n    const token = randomBytes(64).toString('hex');\n    const expiresAt = new Date();\n    expiresAt.setDate(expiresAt.getDate() + 30); // 30 days\n\n    await this.refreshTokenRepository.save({\n      token,\n      userId,\n      expiresAt,\n      isActive: true,\n    });\n\n    return token;\n  }\n\n  async refreshAccessToken(refreshToken: string): Promise<{ accessToken: string; refreshToken: string }> {\n    const storedToken = await this.refreshTokenRepository.findOne({\n      where: { token: refreshToken, isActive: true },\n      relations: ['user'],\n    });\n\n    if (!storedToken || storedToken.expiresAt < new Date()) {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n\n    return this.generateTokens(storedToken.user);\n  }\n\n  async revokeRefreshToken(token: string): Promise<void> {\n    await this.refreshTokenRepository.update(\n      { token },\n      { isActive: false }\n    );\n  }\n\n  async validateAccessToken(token: string): Promise<any> {\n    try {\n      return this.jwtService.verify(token);\n    } catch (error) {\n      throw new UnauthorizedException('Invalid access token');\n    }\n  }\n\n  async revokeAllUserTokens(userId: string): Promise<void> {\n    await this.refreshTokenRepository.update(\n      { userId, isActive: true },\n      { isActive: false }\n    );\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-jwt-strategy-and-guards",children:"2. JWT Strategy and Guards"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/strategies/jwt.strategy.ts\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { UsersService } from '../../users/users.service';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor(\n    private configService: ConfigService,\n    private usersService: UsersService,\n  ) {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: configService.get('JWT_SECRET'),\n    });\n  }\n\n  async validate(payload: any) {\n    const user = await this.usersService.findById(payload.sub);\n    if (!user || !user.isActive) {\n      throw new UnauthorizedException('User not found or inactive');\n    }\n\n    // Check if user's roles/permissions have changed\n    if (this.hasPermissionsChanged(user, payload)) {\n      throw new UnauthorizedException('User permissions have changed');\n    }\n\n    return {\n      id: user.id,\n      email: user.email,\n      roles: user.roles,\n      permissions: user.permissions,\n    };\n  }\n\n  private hasPermissionsChanged(user: any, payload: any): boolean {\n    // Compare current user roles/permissions with token payload\n    return JSON.stringify(user.roles) !== JSON.stringify(payload.roles);\n  }\n}\n\n// src/auth/guards/jwt-auth.guard.ts\nimport { Injectable, ExecutionContext, UnauthorizedException } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\nimport { Reflector } from '@nestjs/core';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  constructor(private reflector: Reflector) {\n    super();\n  }\n\n  canActivate(context: ExecutionContext) {\n    const isPublic = this.reflector.getAllAndOverride<boolean>('isPublic', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (isPublic) {\n      return true;\n    }\n\n    return super.canActivate(context);\n  }\n\n  handleRequest(err: any, user: any, info: any) {\n    if (err || !user) {\n      throw err || new UnauthorizedException('Invalid token');\n    }\n    return user;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"role-based-access-control-rbac",children:"Role-Based Access Control (RBAC)"}),"\n",(0,r.jsx)(n.h3,{id:"1-rbac-entities",children:"1. RBAC Entities"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/entities/role.entity.ts\nimport { Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable } from 'typeorm';\nimport { Permission } from './permission.entity';\nimport { User } from '../../users/entities/user.entity';\n\n@Entity('roles')\nexport class Role {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ unique: true })\n  name: string;\n\n  @Column()\n  description: string;\n\n  @Column({ default: true })\n  isActive: boolean;\n\n  @ManyToMany(() => Permission)\n  @JoinTable({\n    name: 'role_permissions',\n    joinColumn: { name: 'roleId' },\n    inverseJoinColumn: { name: 'permissionId' },\n  })\n  permissions: Permission[];\n\n  @ManyToMany(() => User, user => user.roles)\n  users: User[];\n}\n\n// src/auth/entities/permission.entity.ts\nimport { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';\n\n@Entity('permissions')\nexport class Permission {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ unique: true })\n  name: string;\n\n  @Column()\n  resource: string; // e.g., 'users', 'orders', 'products'\n\n  @Column()\n  action: string; // e.g., 'create', 'read', 'update', 'delete'\n\n  @Column()\n  description: string;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-rbac-guard-implementation",children:"2. RBAC Guard Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/guards/roles.guard.ts\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<string[]>('roles', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    const requiredPermissions = this.reflector.getAllAndOverride<string[]>('permissions', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredRoles && !requiredPermissions) {\n      return true;\n    }\n\n    const { user } = context.switchToHttp().getRequest();\n    \n    if (requiredRoles && !this.hasRequiredRoles(user.roles, requiredRoles)) {\n      return false;\n    }\n\n    if (requiredPermissions && !this.hasRequiredPermissions(user.permissions, requiredPermissions)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private hasRequiredRoles(userRoles: string[], requiredRoles: string[]): boolean {\n    return requiredRoles.some(role => userRoles.includes(role));\n  }\n\n  private hasRequiredPermissions(userPermissions: string[], requiredPermissions: string[]): boolean {\n    return requiredPermissions.every(permission => userPermissions.includes(permission));\n  }\n}\n\n// Decorators\nimport { SetMetadata } from '@nestjs/common';\n\nexport const Roles = (...roles: string[]) => SetMetadata('roles', roles);\nexport const Permissions = (...permissions: string[]) => SetMetadata('permissions', permissions);\nexport const Public = () => SetMetadata('isPublic', true);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-resource-based-authorization",children:"3. Resource-Based Authorization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/guards/resource-owner.guard.ts\nimport { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\n\n@Injectable()\nexport class ResourceOwnerGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const resourceParam = this.reflector.get<string>('resourceParam', context.getHandler());\n    if (!resourceParam) return true;\n\n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n    const resourceId = request.params[resourceParam];\n\n    // Check if user owns the resource or has admin role\n    if (user.roles.includes('admin') || user.roles.includes('super-admin')) {\n      return true;\n    }\n\n    // Custom resource ownership logic\n    const isOwner = await this.checkResourceOwnership(user.id, resourceId, context);\n    \n    if (!isOwner) {\n      throw new ForbiddenException('You do not have access to this resource');\n    }\n\n    return true;\n  }\n\n  private async checkResourceOwnership(userId: string, resourceId: string, context: ExecutionContext): Promise<boolean> {\n    // Implement resource-specific ownership checks\n    const resourceType = this.getResourceType(context);\n    \n    switch (resourceType) {\n      case 'user':\n        return userId === resourceId;\n      case 'order':\n        return await this.checkOrderOwnership(userId, resourceId);\n      default:\n        return false;\n    }\n  }\n\n  private getResourceType(context: ExecutionContext): string {\n    const className = context.getClass().name.toLowerCase();\n    return className.replace('controller', '');\n  }\n\n  private async checkOrderOwnership(userId: string, orderId: string): Promise<boolean> {\n    // Implementation to check if user owns the order\n    return true; // Simplified\n  }\n}\n\nexport const ResourceOwner = (param: string) => SetMetadata('resourceParam', param);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"session-management",children:"Session Management"}),"\n",(0,r.jsx)(n.h3,{id:"1-session-configuration",children:"1. Session Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/config/session.config.ts\nimport { SessionOptions } from 'express-session';\nimport { ConfigService } from '@nestjs/config';\nimport * as RedisStore from 'connect-redis';\nimport { createClient } from 'redis';\n\nexport const createSessionConfig = (configService: ConfigService): SessionOptions => {\n  const redisClient = createClient({\n    host: configService.get('REDIS_HOST'),\n    port: configService.get('REDIS_PORT'),\n    password: configService.get('REDIS_PASSWORD'),\n  });\n\n  return {\n    store: new RedisStore({ client: redisClient }),\n    secret: configService.get('SESSION_SECRET'),\n    resave: false,\n    saveUninitialized: false,\n    name: 'ecom.sid',\n    cookie: {\n      secure: configService.get('NODE_ENV') === 'production',\n      httpOnly: true,\n      maxAge: 1000 * 60 * 60 * 24, // 24 hours\n      sameSite: 'lax',\n    },\n  };\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-session-service",children:"2. Session Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/session.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { UserSession } from './entities/user-session.entity';\n\n@Injectable()\nexport class SessionService {\n  constructor(\n    @InjectRepository(UserSession)\n    private sessionRepository: Repository<UserSession>,\n  ) {}\n\n  async createSession(userId: string, sessionData: any): Promise<UserSession> {\n    const session = this.sessionRepository.create({\n      userId,\n      sessionId: sessionData.id,\n      ipAddress: sessionData.ipAddress,\n      userAgent: sessionData.userAgent,\n      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours\n    });\n\n    return this.sessionRepository.save(session);\n  }\n\n  async validateSession(sessionId: string): Promise<UserSession | null> {\n    return this.sessionRepository.findOne({\n      where: { sessionId, isActive: true },\n      relations: ['user'],\n    });\n  }\n\n  async revokeSession(sessionId: string): Promise<void> {\n    await this.sessionRepository.update(\n      { sessionId },\n      { isActive: false, revokedAt: new Date() }\n    );\n  }\n\n  async revokeAllUserSessions(userId: string, currentSessionId?: string): Promise<void> {\n    const query = this.sessionRepository\n      .createQueryBuilder()\n      .update(UserSession)\n      .set({ isActive: false, revokedAt: new Date() })\n      .where('userId = :userId', { userId });\n\n    if (currentSessionId) {\n      query.andWhere('sessionId != :currentSessionId', { currentSessionId });\n    }\n\n    await query.execute();\n  }\n\n  async cleanupExpiredSessions(): Promise<void> {\n    await this.sessionRepository.delete({\n      expiresAt: LessThan(new Date()),\n    });\n  }\n\n  async getUserActiveSessions(userId: string): Promise<UserSession[]> {\n    return this.sessionRepository.find({\n      where: { userId, isActive: true },\n      order: { createdAt: 'DESC' },\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"multi-factor-authentication",children:"Multi-Factor Authentication"}),"\n",(0,r.jsx)(n.h3,{id:"1-totp-time-based-one-time-password-implementation",children:"1. TOTP (Time-based One-Time Password) Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/mfa.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { MFASecret } from './entities/mfa-secret.entity';\nimport * as speakeasy from 'speakeasy';\nimport * as QRCode from 'qrcode';\n\n@Injectable()\nexport class MFAService {\n  constructor(\n    @InjectRepository(MFASecret)\n    private mfaSecretRepository: Repository<MFASecret>,\n  ) {}\n\n  async generateMFASecret(userId: string, email: string): Promise<{ secret: string; qrCode: string }> {\n    const secret = speakeasy.generateSecret({\n      name: `E-commerce App (${email})`,\n      issuer: 'E-commerce App',\n      length: 32,\n    });\n\n    // Save the secret (encrypted) to database\n    await this.saveMFASecret(userId, secret.base32);\n\n    const qrCode = await QRCode.toDataURL(secret.otpauth_url!);\n\n    return {\n      secret: secret.base32,\n      qrCode,\n    };\n  }\n\n  async verifyMFAToken(userId: string, token: string): Promise<boolean> {\n    const mfaSecret = await this.mfaSecretRepository.findOne({\n      where: { userId, isActive: true },\n    });\n\n    if (!mfaSecret) {\n      return false;\n    }\n\n    return speakeasy.totp.verify({\n      secret: mfaSecret.secret,\n      encoding: 'base32',\n      token,\n      window: 2, // Allow 2 time steps before/after\n    });\n  }\n\n  async enableMFA(userId: string, token: string): Promise<boolean> {\n    const isValid = await this.verifyMFAToken(userId, token);\n    \n    if (isValid) {\n      await this.mfaSecretRepository.update(\n        { userId },\n        { isEnabled: true }\n      );\n      return true;\n    }\n\n    return false;\n  }\n\n  async disableMFA(userId: string): Promise<void> {\n    await this.mfaSecretRepository.update(\n      { userId },\n      { isEnabled: false, isActive: false }\n    );\n  }\n\n  async isMFAEnabled(userId: string): Promise<boolean> {\n    const mfaSecret = await this.mfaSecretRepository.findOne({\n      where: { userId, isActive: true, isEnabled: true },\n    });\n\n    return !!mfaSecret;\n  }\n\n  private async saveMFASecret(userId: string, secret: string): Promise<void> {\n    // Disable any existing secrets\n    await this.mfaSecretRepository.update(\n      { userId },\n      { isActive: false }\n    );\n\n    // Create new secret\n    await this.mfaSecretRepository.save({\n      userId,\n      secret, // Should be encrypted in production\n      isActive: true,\n      isEnabled: false,\n    });\n  }\n\n  async generateBackupCodes(userId: string): Promise<string[]> {\n    const codes = Array.from({ length: 10 }, () => \n      Math.random().toString(36).substring(2, 15)\n    );\n\n    // Save encrypted backup codes to database\n    await this.saveBackupCodes(userId, codes);\n\n    return codes;\n  }\n\n  private async saveBackupCodes(userId: string, codes: string[]): Promise<void> {\n    // Implementation to save encrypted backup codes\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-mfa-guard",children:"2. MFA Guard"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/guards/mfa.guard.ts\nimport { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { MFAService } from '../mfa.service';\n\n@Injectable()\nexport class MFAGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private mfaService: MFAService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const requireMFA = this.reflector.getAllAndOverride<boolean>('requireMFA', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requireMFA) {\n      return true;\n    }\n\n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n\n    if (!user) {\n      throw new UnauthorizedException('User not authenticated');\n    }\n\n    const isMFAEnabled = await this.mfaService.isMFAEnabled(user.id);\n    \n    if (isMFAEnabled && !request.session?.mfaVerified) {\n      throw new UnauthorizedException('MFA verification required');\n    }\n\n    return true;\n  }\n}\n\nexport const RequireMFA = () => SetMetadata('requireMFA', true);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"password-policies",children:"Password Policies"}),"\n",(0,r.jsx)(n.h3,{id:"1-password-service",children:"1. Password Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/password.service.ts\nimport { Injectable } from '@nestjs/common';\nimport * as bcrypt from 'bcrypt';\nimport * as zxcvbn from 'zxcvbn';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { PasswordHistory } from './entities/password-history.entity';\n\nexport interface PasswordPolicy {\n  minLength: number;\n  maxLength: number;\n  requireUppercase: boolean;\n  requireLowercase: boolean;\n  requireNumbers: boolean;\n  requireSpecialChars: boolean;\n  minStrengthScore: number;\n  preventReuse: number; // Number of previous passwords to check\n  maxAge: number; // Days before password expires\n}\n\n@Injectable()\nexport class PasswordService {\n  private readonly policy: PasswordPolicy = {\n    minLength: 8,\n    maxLength: 128,\n    requireUppercase: true,\n    requireLowercase: true,\n    requireNumbers: true,\n    requireSpecialChars: true,\n    minStrengthScore: 3,\n    preventReuse: 12,\n    maxAge: 90,\n  };\n\n  constructor(\n    @InjectRepository(PasswordHistory)\n    private passwordHistoryRepository: Repository<PasswordHistory>,\n  ) {}\n\n  async hashPassword(password: string): Promise<string> {\n    const saltRounds = 12;\n    return bcrypt.hash(password, saltRounds);\n  }\n\n  async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n    return bcrypt.compare(password, hashedPassword);\n  }\n\n  validatePassword(password: string, userInfo?: any): { isValid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    // Length check\n    if (password.length < this.policy.minLength) {\n      errors.push(`Password must be at least ${this.policy.minLength} characters long`);\n    }\n\n    if (password.length > this.policy.maxLength) {\n      errors.push(`Password must not exceed ${this.policy.maxLength} characters`);\n    }\n\n    // Character requirements\n    if (this.policy.requireUppercase && !/[A-Z]/.test(password)) {\n      errors.push('Password must contain at least one uppercase letter');\n    }\n\n    if (this.policy.requireLowercase && !/[a-z]/.test(password)) {\n      errors.push('Password must contain at least one lowercase letter');\n    }\n\n    if (this.policy.requireNumbers && !/\\d/.test(password)) {\n      errors.push('Password must contain at least one number');\n    }\n\n    if (this.policy.requireSpecialChars && !/[!@#$%^&*(),.?\":{}|<>]/.test(password)) {\n      errors.push('Password must contain at least one special character');\n    }\n\n    // Strength check using zxcvbn\n    const strengthResult = zxcvbn(password, userInfo ? [userInfo.email, userInfo.firstName, userInfo.lastName] : []);\n    \n    if (strengthResult.score < this.policy.minStrengthScore) {\n      errors.push(`Password is too weak. ${strengthResult.feedback.warning || 'Please choose a stronger password'}`);\n      \n      if (strengthResult.feedback.suggestions.length > 0) {\n        errors.push(...strengthResult.feedback.suggestions);\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n\n  async checkPasswordReuse(userId: string, newPassword: string): Promise<boolean> {\n    const passwordHistory = await this.passwordHistoryRepository.find({\n      where: { userId },\n      order: { createdAt: 'DESC' },\n      take: this.policy.preventReuse,\n    });\n\n    for (const historicalPassword of passwordHistory) {\n      if (await this.verifyPassword(newPassword, historicalPassword.hashedPassword)) {\n        return false; // Password was previously used\n      }\n    }\n\n    return true; // Password is new\n  }\n\n  async savePasswordToHistory(userId: string, hashedPassword: string): Promise<void> {\n    await this.passwordHistoryRepository.save({\n      userId,\n      hashedPassword,\n      createdAt: new Date(),\n    });\n\n    // Clean up old password history beyond the policy limit\n    const allHistory = await this.passwordHistoryRepository.find({\n      where: { userId },\n      order: { createdAt: 'DESC' },\n    });\n\n    if (allHistory.length > this.policy.preventReuse) {\n      const toDelete = allHistory.slice(this.policy.preventReuse);\n      await this.passwordHistoryRepository.remove(toDelete);\n    }\n  }\n\n  isPasswordExpired(lastPasswordChange: Date): boolean {\n    const now = new Date();\n    const daysSinceChange = Math.floor((now.getTime() - lastPasswordChange.getTime()) / (1000 * 60 * 60 * 24));\n    return daysSinceChange > this.policy.maxAge;\n  }\n\n  generateSecurePassword(length: number = 16): string {\n    const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n    const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    const numbers = '0123456789';\n    const special = '!@#$%^&*(),.?\":{}|<>';\n    \n    const allChars = lowercase + uppercase + numbers + special;\n    \n    let password = '';\n    \n    // Ensure at least one character from each required set\n    password += lowercase[Math.floor(Math.random() * lowercase.length)];\n    password += uppercase[Math.floor(Math.random() * uppercase.length)];\n    password += numbers[Math.floor(Math.random() * numbers.length)];\n    password += special[Math.floor(Math.random() * special.length)];\n    \n    // Fill the rest randomly\n    for (let i = 4; i < length; i++) {\n      password += allChars[Math.floor(Math.random() * allChars.length)];\n    }\n    \n    // Shuffle the password\n    return password.split('').sort(() => Math.random() - 0.5).join('');\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"oauth-integration",children:"OAuth Integration"}),"\n",(0,r.jsx)(n.h3,{id:"1-google-oauth-strategy",children:"1. Google OAuth Strategy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/strategies/google.strategy.ts\nimport { Injectable } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Strategy, VerifyCallback } from 'passport-google-oauth20';\nimport { ConfigService } from '@nestjs/config';\nimport { AuthService } from '../auth.service';\n\n@Injectable()\nexport class GoogleStrategy extends PassportStrategy(Strategy, 'google') {\n  constructor(\n    private configService: ConfigService,\n    private authService: AuthService,\n  ) {\n    super({\n      clientID: configService.get('GOOGLE_CLIENT_ID'),\n      clientSecret: configService.get('GOOGLE_CLIENT_SECRET'),\n      callbackURL: configService.get('GOOGLE_CALLBACK_URL'),\n      scope: ['email', 'profile'],\n    });\n  }\n\n  async validate(\n    accessToken: string,\n    refreshToken: string,\n    profile: any,\n    done: VerifyCallback,\n  ): Promise<any> {\n    const { name, emails, photos } = profile;\n    \n    const user = await this.authService.validateOAuthUser({\n      provider: 'google',\n      providerId: profile.id,\n      email: emails[0].value,\n      firstName: name.givenName,\n      lastName: name.familyName,\n      picture: photos[0].value,\n      accessToken,\n      refreshToken,\n    });\n\n    done(null, user);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-oauth-service",children:"2. OAuth Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/auth/oauth.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { User } from '../users/entities/user.entity';\nimport { OAuthProvider } from './entities/oauth-provider.entity';\n\nexport interface OAuthUserData {\n  provider: string;\n  providerId: string;\n  email: string;\n  firstName: string;\n  lastName: string;\n  picture?: string;\n  accessToken: string;\n  refreshToken?: string;\n}\n\n@Injectable()\nexport class OAuthService {\n  constructor(\n    @InjectRepository(User)\n    private userRepository: Repository<User>,\n    @InjectRepository(OAuthProvider)\n    private oauthProviderRepository: Repository<OAuthProvider>,\n  ) {}\n\n  async validateOAuthUser(userData: OAuthUserData): Promise<User> {\n    // Check if OAuth provider exists\n    let oauthProvider = await this.oauthProviderRepository.findOne({\n      where: {\n        provider: userData.provider,\n        providerId: userData.providerId,\n      },\n      relations: ['user'],\n    });\n\n    if (oauthProvider) {\n      // Update tokens\n      oauthProvider.accessToken = userData.accessToken;\n      oauthProvider.refreshToken = userData.refreshToken;\n      await this.oauthProviderRepository.save(oauthProvider);\n      \n      return oauthProvider.user;\n    }\n\n    // Check if user exists with this email\n    let user = await this.userRepository.findOne({\n      where: { email: userData.email },\n    });\n\n    if (!user) {\n      // Create new user\n      user = this.userRepository.create({\n        email: userData.email,\n        firstName: userData.firstName,\n        lastName: userData.lastName,\n        profilePicture: userData.picture,\n        isEmailVerified: true, // OAuth emails are considered verified\n        authMethod: 'oauth',\n      });\n      \n      user = await this.userRepository.save(user);\n    }\n\n    // Create OAuth provider entry\n    oauthProvider = this.oauthProviderRepository.create({\n      provider: userData.provider,\n      providerId: userData.providerId,\n      accessToken: userData.accessToken,\n      refreshToken: userData.refreshToken,\n      user,\n    });\n\n    await this.oauthProviderRepository.save(oauthProvider);\n\n    return user;\n  }\n\n  async unlinkOAuthProvider(userId: string, provider: string): Promise<void> {\n    await this.oauthProviderRepository.delete({\n      user: { id: userId },\n      provider,\n    });\n  }\n\n  async getUserOAuthProviders(userId: string): Promise<OAuthProvider[]> {\n    return this.oauthProviderRepository.find({\n      where: { user: { id: userId } },\n      select: ['provider', 'createdAt'], // Don't expose tokens\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"security-headers-and-cors",children:"Security Headers and CORS"}),"\n",(0,r.jsx)(n.h3,{id:"1-security-middleware",children:"1. Security Middleware"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/common/middleware/security.middleware.ts\nimport { Injectable, NestMiddleware } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport helmet from 'helmet';\n\n@Injectable()\nexport class SecurityMiddleware implements NestMiddleware {\n  use(req: Request, res: Response, next: NextFunction) {\n    // Apply Helmet security headers\n    helmet({\n      contentSecurityPolicy: {\n        directives: {\n          defaultSrc: [\"'self'\"],\n          styleSrc: [\"'self'\", \"'unsafe-inline'\", 'https://fonts.googleapis.com'],\n          fontSrc: [\"'self'\", 'https://fonts.gstatic.com'],\n          imgSrc: [\"'self'\", 'data:', 'https:'],\n          scriptSrc: [\"'self'\"],\n          connectSrc: [\"'self'\"],\n          frameSrc: [\"'none'\"],\n          objectSrc: [\"'none'\"],\n          baseUri: [\"'self'\"],\n          formAction: [\"'self'\"],\n        },\n      },\n      hsts: {\n        maxAge: 31536000,\n        includeSubDomains: true,\n        preload: true,\n      },\n      noSniff: true,\n      xssFilter: true,\n      referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n    })(req, res, next);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-cors-configuration",children:"2. CORS Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/config/cors.config.ts\nimport { CorsOptions } from '@nestjs/common/interfaces/external/cors-options.interface';\nimport { ConfigService } from '@nestjs/config';\n\nexport const createCorsConfig = (configService: ConfigService): CorsOptions => {\n  const allowedOrigins = configService.get('CORS_ORIGINS')?.split(',') || [\n    'http://localhost:3000',\n    'http://localhost:3001',\n  ];\n\n  return {\n    origin: (origin, callback) => {\n      // Allow requests with no origin (mobile apps, Postman, etc.)\n      if (!origin) return callback(null, true);\n      \n      if (allowedOrigins.includes(origin)) {\n        callback(null, true);\n      } else {\n        callback(new Error('Not allowed by CORS'));\n      }\n    },\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n    allowedHeaders: [\n      'Origin',\n      'X-Requested-With',\n      'Content-Type',\n      'Accept',\n      'Authorization',\n      'X-CSRF-Token',\n    ],\n    credentials: true,\n    optionsSuccessStatus: 200,\n  };\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(n.h3,{id:"1-authentication-tests",children:"1. Authentication Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// test/auth.e2e-spec.ts\nimport { Test } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\nimport { AppModule } from '../src/app.module';\n\ndescribe('Authentication (e2e)', () => {\n  let app: INestApplication;\n\n  beforeAll(async () => {\n    const moduleFixture = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  describe('/auth/login (POST)', () => {\n    it('should authenticate user with valid credentials', () => {\n      return request(app.getHttpServer())\n        .post('/auth/login')\n        .send({\n          email: 'test@example.com',\n          password: 'validPassword123!',\n        })\n        .expect(200)\n        .expect(res => {\n          expect(res.body.accessToken).toBeDefined();\n          expect(res.body.refreshToken).toBeDefined();\n        });\n    });\n\n    it('should reject invalid credentials', () => {\n      return request(app.getHttpServer())\n        .post('/auth/login')\n        .send({\n          email: 'test@example.com',\n          password: 'wrongPassword',\n        })\n        .expect(401);\n    });\n  });\n\n  describe('/auth/refresh (POST)', () => {\n    it('should refresh access token with valid refresh token', async () => {\n      // First login to get refresh token\n      const loginResponse = await request(app.getHttpServer())\n        .post('/auth/login')\n        .send({\n          email: 'test@example.com',\n          password: 'validPassword123!',\n        });\n\n      const { refreshToken } = loginResponse.body;\n\n      return request(app.getHttpServer())\n        .post('/auth/refresh')\n        .send({ refreshToken })\n        .expect(200)\n        .expect(res => {\n          expect(res.body.accessToken).toBeDefined();\n        });\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"deployment-checklist",children:"Deployment Checklist"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","JWT secrets configured in Secret Manager"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Session secrets configured"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Redis instance set up for session storage"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","OAuth credentials configured"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Password policies enforced"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","MFA setup documented for users"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Security headers properly configured"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","CORS origins whitelisted"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Rate limiting implemented"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Authentication audit logging enabled"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Session timeout policies configured"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Password reset functionality tested"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Account lockout policies implemented"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This comprehensive authentication and authorization implementation provides secure user management with modern security practices for production e-commerce applications."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);