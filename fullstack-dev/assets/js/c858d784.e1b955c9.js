"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[726],{958:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"security-practices/security-implementation/session-management","title":"Session Management Implementation Guide","description":"This guide provides comprehensive session management implementation for NestJS/Next.js applications on GCP Kubernetes, covering secure cookie configuration, session storage, and timeout management.","source":"@site/docs/security-practices/security-implementation/session-management.md","sourceDirName":"security-practices/security-implementation","slug":"/security-practices/security-implementation/session-management","permalink":"/fullstack-dev/docs/security-practices/security-implementation/session-management","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/security-practices/security-implementation/session-management.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Network Security Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/network-security"},"next":{"title":"Incident Management Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/incident-management"}}');var t=s(5813),o=s(5741);const r={},a="Session Management Implementation Guide",c={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Session Storage Configuration",id:"session-storage-configuration",level:2},{value:"NestJS Session Configuration",id:"nestjs-session-configuration",level:3},{value:"Session Module Setup",id:"session-module-setup",level:3},{value:"Secure Cookie Management",id:"secure-cookie-management",level:2},{value:"Cookie Security Service",id:"cookie-security-service",level:3},{value:"Cookie Validation Middleware",id:"cookie-validation-middleware",level:3},{value:"Session Timeout &amp; Auto-logout",id:"session-timeout--auto-logout",level:2},{value:"Session Timeout Middleware",id:"session-timeout-middleware",level:3},{value:"Next.js Client-Side Session Management",id:"nextjs-client-side-session-management",level:3},{value:"Session Timeout Warning Component",id:"session-timeout-warning-component",level:3},{value:"JWT Session Management",id:"jwt-session-management",level:2},{value:"JWT Session Service",id:"jwt-session-service",level:3},{value:"Redis Session Store",id:"redis-session-store",level:2},{value:"Redis Session Configuration",id:"redis-session-configuration",level:3},{value:"Session Security Monitoring",id:"session-security-monitoring",level:2},{value:"Session Security Monitoring Service",id:"session-security-monitoring-service",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"session-management-implementation-guide",children:"Session Management Implementation Guide"})}),"\n",(0,t.jsx)(n.p,{children:"This guide provides comprehensive session management implementation for NestJS/Next.js applications on GCP Kubernetes, covering secure cookie configuration, session storage, and timeout management."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#session-storage-configuration",children:"Session Storage Configuration"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#secure-cookie-management",children:"Secure Cookie Management"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#session-timeout--auto-logout",children:"Session Timeout & Auto-logout"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#jwt-session-management",children:"JWT Session Management"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#redis-session-store",children:"Redis Session Store"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#session-security-monitoring",children:"Session Security Monitoring"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"session-storage-configuration",children:"Session Storage Configuration"}),"\n",(0,t.jsx)(n.h3,{id:"nestjs-session-configuration",children:"NestJS Session Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/config/session.config.ts\nimport { ConfigService } from '@nestjs/config';\nimport { SessionOptions } from 'express-session';\nimport * as connectRedis from 'connect-redis';\nimport { Redis } from 'ioredis';\n\nexport interface SessionConfig {\n  secret: string;\n  name: string;\n  maxAge: number;\n  secure: boolean;\n  httpOnly: boolean;\n  sameSite: 'strict' | 'lax' | 'none';\n  domain?: string;\n  rolling: boolean;\n  saveUninitialized: boolean;\n  resave: boolean;\n}\n\nexport class SessionConfigService {\n  constructor(private configService: ConfigService) {}\n\n  getSessionConfig(): SessionOptions {\n    const RedisStore = connectRedis.default;\n    const redisClient = new Redis({\n      host: this.configService.get('REDIS_HOST'),\n      port: this.configService.get('REDIS_PORT'),\n      password: this.configService.get('REDIS_PASSWORD'),\n      retryDelayOnFailover: 100,\n      maxRetriesPerRequest: 3,\n      db: this.configService.get('REDIS_SESSION_DB', 1),\n    });\n\n    return {\n      store: new RedisStore({ client: redisClient }),\n      secret: this.configService.get('SESSION_SECRET'),\n      name: 'ecom.session.id',\n      cookie: {\n        maxAge: this.getSessionMaxAge(),\n        secure: this.configService.get('NODE_ENV') === 'production',\n        httpOnly: true,\n        sameSite: 'strict',\n        domain: this.configService.get('COOKIE_DOMAIN'),\n      },\n      rolling: true, // Reset expiration on activity\n      saveUninitialized: false,\n      resave: false,\n      genid: () => this.generateSecureSessionId(),\n    };\n  }\n\n  private getSessionMaxAge(): number {\n    const environment = this.configService.get('NODE_ENV');\n    const businessRequirement = this.configService.get('SESSION_TIMEOUT_MINUTES', 30);\n    \n    // Different timeouts based on environment and business rules\n    switch (environment) {\n      case 'production':\n        return businessRequirement * 60 * 1000; // Convert to milliseconds\n      case 'staging':\n        return 60 * 60 * 1000; // 1 hour for testing\n      default:\n        return 24 * 60 * 60 * 1000; // 24 hours for development\n    }\n  }\n\n  private generateSecureSessionId(): string {\n    const crypto = require('crypto');\n    return crypto.randomBytes(32).toString('hex');\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"session-module-setup",children:"Session Module Setup"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/session/session.module.ts\nimport { Module, MiddlewareConsumer, NestModule } from '@nestjs/common';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport * as session from 'express-session';\nimport { SessionConfigService } from '../config/session.config';\nimport { SessionService } from './session.service';\nimport { SessionController } from './session.controller';\nimport { SessionTimeoutMiddleware } from './middleware/session-timeout.middleware';\n\n@Module({\n  imports: [ConfigModule],\n  providers: [SessionConfigService, SessionService],\n  controllers: [SessionController],\n  exports: [SessionService],\n})\nexport class SessionModule implements NestModule {\n  constructor(\n    private sessionConfigService: SessionConfigService,\n    private configService: ConfigService\n  ) {}\n\n  configure(consumer: MiddlewareConsumer): void {\n    consumer\n      .apply(\n        session(this.sessionConfigService.getSessionConfig()),\n        SessionTimeoutMiddleware\n      )\n      .forRoutes('*');\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"secure-cookie-management",children:"Secure Cookie Management"}),"\n",(0,t.jsx)(n.h3,{id:"cookie-security-service",children:"Cookie Security Service"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/session/cookie-security.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Request, Response } from 'express';\nimport * as crypto from 'crypto';\n\ninterface SecureCookieOptions {\n  name: string;\n  value: string;\n  maxAge?: number;\n  secure?: boolean;\n  httpOnly?: boolean;\n  sameSite?: 'strict' | 'lax' | 'none';\n  domain?: string;\n  path?: string;\n  signed?: boolean;\n}\n\n@Injectable()\nexport class CookieSecurityService {\n  private readonly logger = new Logger(CookieSecurityService.name);\n  private readonly cookieSecret: string;\n\n  constructor(private configService: ConfigService) {\n    this.cookieSecret = this.configService.get('COOKIE_SECRET');\n  }\n\n  setSecureCookie(res: Response, options: SecureCookieOptions): void {\n    const cookieOptions = {\n      maxAge: options.maxAge || 30 * 60 * 1000, // 30 minutes default\n      secure: this.configService.get('NODE_ENV') === 'production',\n      httpOnly: options.httpOnly !== false, // Default to true\n      sameSite: options.sameSite || 'strict' as const,\n      domain: options.domain || this.configService.get('COOKIE_DOMAIN'),\n      path: options.path || '/',\n      signed: options.signed !== false, // Default to true\n    };\n\n    if (cookieOptions.signed) {\n      res.cookie(options.name, options.value, cookieOptions);\n    } else {\n      res.cookie(options.name, options.value, { ...cookieOptions, signed: false });\n    }\n\n    this.logger.debug(`Set secure cookie: ${options.name}`);\n  }\n\n  clearSecureCookie(res: Response, cookieName: string): void {\n    res.clearCookie(cookieName, {\n      secure: this.configService.get('NODE_ENV') === 'production',\n      httpOnly: true,\n      sameSite: 'strict',\n      domain: this.configService.get('COOKIE_DOMAIN'),\n      path: '/',\n    });\n\n    this.logger.debug(`Cleared cookie: ${cookieName}`);\n  }\n\n  validateCookieIntegrity(req: Request, cookieName: string): boolean {\n    const cookieValue = req.signedCookies[cookieName] || req.cookies[cookieName];\n    \n    if (!cookieValue) {\n      return false;\n    }\n\n    // Additional integrity checks can be added here\n    return true;\n  }\n\n  createAntiCSRFToken(): string {\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  setCSRFToken(res: Response, token: string): void {\n    this.setSecureCookie(res, {\n      name: 'csrf-token',\n      value: token,\n      httpOnly: false, // Needs to be accessible by JavaScript\n      sameSite: 'strict',\n      maxAge: 60 * 60 * 1000, // 1 hour\n    });\n  }\n\n  validateCSRFToken(req: Request, providedToken: string): boolean {\n    const cookieToken = req.cookies['csrf-token'];\n    return cookieToken && cookieToken === providedToken;\n  }\n\n  // Implement cookie encryption for sensitive data\n  encryptCookieValue(value: string): string {\n    const algorithm = 'aes-256-gcm';\n    const key = crypto.scryptSync(this.cookieSecret, 'salt', 32);\n    const iv = crypto.randomBytes(16);\n    \n    const cipher = crypto.createCipher(algorithm, key);\n    cipher.setAAD(Buffer.from('cookie-encryption'));\n    \n    let encrypted = cipher.update(value, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;\n  }\n\n  decryptCookieValue(encryptedValue: string): string | null {\n    try {\n      const [ivHex, authTagHex, encrypted] = encryptedValue.split(':');\n      const algorithm = 'aes-256-gcm';\n      const key = crypto.scryptSync(this.cookieSecret, 'salt', 32);\n      const iv = Buffer.from(ivHex, 'hex');\n      const authTag = Buffer.from(authTagHex, 'hex');\n      \n      const decipher = crypto.createDecipher(algorithm, key);\n      decipher.setAuthTag(authTag);\n      decipher.setAAD(Buffer.from('cookie-encryption'));\n      \n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      \n      return decrypted;\n    } catch (error) {\n      this.logger.error('Cookie decryption failed:', error);\n      return null;\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cookie-validation-middleware",children:"Cookie Validation Middleware"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/session/middleware/cookie-validation.middleware.ts\nimport { Injectable, NestMiddleware, UnauthorizedException } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport { CookieSecurityService } from '../cookie-security.service';\n\n@Injectable()\nexport class CookieValidationMiddleware implements NestMiddleware {\n  constructor(private cookieSecurityService: CookieSecurityService) {}\n\n  use(req: Request, res: Response, next: NextFunction): void {\n    // Validate session cookie integrity\n    const sessionCookieValid = this.cookieSecurityService.validateCookieIntegrity(\n      req,\n      'ecom.session.id'\n    );\n\n    if (!sessionCookieValid && req.path !== '/auth/login') {\n      throw new UnauthorizedException('Invalid session cookie');\n    }\n\n    // Validate CSRF token for state-changing operations\n    if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(req.method)) {\n      const csrfToken = req.headers['x-csrf-token'] as string;\n      const csrfValid = this.cookieSecurityService.validateCSRFToken(req, csrfToken);\n      \n      if (!csrfValid) {\n        throw new UnauthorizedException('Invalid CSRF token');\n      }\n    }\n\n    next();\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"session-timeout--auto-logout",children:"Session Timeout & Auto-logout"}),"\n",(0,t.jsx)(n.h3,{id:"session-timeout-middleware",children:"Session Timeout Middleware"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/session/middleware/session-timeout.middleware.ts\nimport { Injectable, NestMiddleware, Logger } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport { ConfigService } from '@nestjs/config';\n\ninterface SessionData {\n  userId?: string;\n  lastActivity?: number;\n  loginTime?: number;\n  userAgent?: string;\n  ipAddress?: string;\n}\n\n@Injectable()\nexport class SessionTimeoutMiddleware implements NestMiddleware {\n  private readonly logger = new Logger(SessionTimeoutMiddleware.name);\n\n  constructor(private configService: ConfigService) {}\n\n  use(req: Request & { session: SessionData }, res: Response, next: NextFunction): void {\n    if (!req.session) {\n      return next();\n    }\n\n    const now = Date.now();\n    const sessionTimeout = this.configService.get('SESSION_TIMEOUT_MINUTES', 30) * 60 * 1000;\n    const absoluteTimeout = this.configService.get('ABSOLUTE_SESSION_TIMEOUT_HOURS', 8) * 60 * 60 * 1000;\n\n    // Check for session timeout due to inactivity\n    if (req.session.lastActivity) {\n      const timeSinceLastActivity = now - req.session.lastActivity;\n      \n      if (timeSinceLastActivity > sessionTimeout) {\n        this.logger.warn(`Session timeout for user ${req.session.userId} due to inactivity`);\n        return this.destroySession(req, res, 'Session expired due to inactivity');\n      }\n    }\n\n    // Check for absolute session timeout\n    if (req.session.loginTime) {\n      const sessionAge = now - req.session.loginTime;\n      \n      if (sessionAge > absoluteTimeout) {\n        this.logger.warn(`Absolute session timeout for user ${req.session.userId}`);\n        return this.destroySession(req, res, 'Session expired due to maximum duration');\n      }\n    }\n\n    // Check for session hijacking (different user agent or IP)\n    if (this.detectSessionHijacking(req)) {\n      this.logger.error(`Potential session hijacking detected for user ${req.session.userId}`);\n      return this.destroySession(req, res, 'Session terminated for security reasons');\n    }\n\n    // Update last activity\n    req.session.lastActivity = now;\n\n    // Set session timeout warning header (5 minutes before expiry)\n    const timeUntilTimeout = sessionTimeout - (now - req.session.lastActivity);\n    if (timeUntilTimeout <= 5 * 60 * 1000) {\n      res.set('X-Session-Warning', 'Session will expire soon');\n    }\n\n    next();\n  }\n\n  private detectSessionHijacking(req: Request & { session: SessionData }): boolean {\n    const currentUserAgent = req.headers['user-agent'];\n    const currentIP = req.ip || req.connection.remoteAddress;\n\n    // Compare with stored session data\n    if (req.session.userAgent && req.session.userAgent !== currentUserAgent) {\n      return true;\n    }\n\n    if (req.session.ipAddress && req.session.ipAddress !== currentIP) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private destroySession(\n    req: Request & { session: SessionData },\n    res: Response,\n    reason: string\n  ): void {\n    req.session.destroy((err) => {\n      if (err) {\n        this.logger.error('Failed to destroy session:', err);\n      }\n    });\n\n    res.status(401).json({\n      error: 'Session expired',\n      reason,\n      redirectTo: '/auth/login',\n    });\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"nextjs-client-side-session-management",children:"Next.js Client-Side Session Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/hooks/useSessionTimeout.ts\nimport { useEffect, useCallback, useRef } from 'react';\nimport { useRouter } from 'next/router';\nimport { useAuth } from '../contexts/AuthContext';\n\ninterface UseSessionTimeoutOptions {\n  timeoutMinutes?: number;\n  warningMinutes?: number;\n  onWarning?: () => void;\n  onTimeout?: () => void;\n}\n\nexport const useSessionTimeout = (options: UseSessionTimeoutOptions = {}) => {\n  const {\n    timeoutMinutes = 30,\n    warningMinutes = 5,\n    onWarning,\n    onTimeout,\n  } = options;\n\n  const router = useRouter();\n  const { logout } = useAuth();\n  const timeoutRef = useRef<NodeJS.Timeout>();\n  const warningRef = useRef<NodeJS.Timeout>();\n  const lastActivityRef = useRef<number>(Date.now());\n\n  const handleTimeout = useCallback(() => {\n    logout();\n    onTimeout?.();\n    router.push('/auth/login?reason=timeout');\n  }, [logout, onTimeout, router]);\n\n  const handleWarning = useCallback(() => {\n    onWarning?.();\n  }, [onWarning]);\n\n  const resetTimeout = useCallback(() => {\n    lastActivityRef.current = Date.now();\n\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    if (warningRef.current) {\n      clearTimeout(warningRef.current);\n    }\n\n    // Set warning timeout\n    warningRef.current = setTimeout(\n      handleWarning,\n      (timeoutMinutes - warningMinutes) * 60 * 1000\n    );\n\n    // Set session timeout\n    timeoutRef.current = setTimeout(\n      handleTimeout,\n      timeoutMinutes * 60 * 1000\n    );\n  }, [timeoutMinutes, warningMinutes, handleTimeout, handleWarning]);\n\n  const extendSession = useCallback(async () => {\n    try {\n      const response = await fetch('/api/auth/extend-session', {\n        method: 'POST',\n        credentials: 'include',\n      });\n\n      if (response.ok) {\n        resetTimeout();\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Failed to extend session:', error);\n      return false;\n    }\n  }, [resetTimeout]);\n\n  useEffect(() => {\n    const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];\n    \n    const updateActivity = () => {\n      const now = Date.now();\n      // Only reset if more than 30 seconds since last activity\n      if (now - lastActivityRef.current > 30000) {\n        resetTimeout();\n      }\n    };\n\n    events.forEach(event => {\n      document.addEventListener(event, updateActivity, true);\n    });\n\n    // Check for session warning from server\n    const checkSessionWarning = () => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('HEAD', '/api/auth/session-status');\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === 4) {\n          const warning = xhr.getResponseHeader('X-Session-Warning');\n          if (warning) {\n            handleWarning();\n          }\n        }\n      };\n      xhr.send();\n    };\n\n    const warningCheckInterval = setInterval(checkSessionWarning, 60000); // Check every minute\n\n    resetTimeout();\n\n    return () => {\n      events.forEach(event => {\n        document.removeEventListener(event, updateActivity, true);\n      });\n      \n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      if (warningRef.current) {\n        clearTimeout(warningRef.current);\n      }\n      clearInterval(warningCheckInterval);\n    };\n  }, [resetTimeout, handleWarning]);\n\n  return {\n    extendSession,\n    resetTimeout,\n  };\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"session-timeout-warning-component",children:"Session Timeout Warning Component"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'// src/components/SessionTimeoutWarning.tsx\nimport React, { useState, useEffect } from \'react\';\nimport { Dialog } from \'@headlessui/react\';\nimport { useSessionTimeout } from \'../hooks/useSessionTimeout\';\n\ninterface SessionTimeoutWarningProps {\n  show: boolean;\n  onExtend: () => Promise<boolean>;\n  onLogout: () => void;\n}\n\nexport const SessionTimeoutWarning: React.FC<SessionTimeoutWarningProps> = ({\n  show,\n  onExtend,\n  onLogout,\n}) => {\n  const [countdown, setCountdown] = useState(300); // 5 minutes\n  const [extending, setExtending] = useState(false);\n\n  useEffect(() => {\n    if (!show) {\n      setCountdown(300);\n      return;\n    }\n\n    const interval = setInterval(() => {\n      setCountdown(prev => {\n        if (prev <= 1) {\n          onLogout();\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, [show, onLogout]);\n\n  const handleExtend = async () => {\n    setExtending(true);\n    const success = await onExtend();\n    setExtending(false);\n    \n    if (!success) {\n      onLogout();\n    }\n  };\n\n  const formatTime = (seconds: number) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins}:${secs.toString().padStart(2, \'0\')}`;\n  };\n\n  return (\n    <Dialog open={show} onClose={() => {}} className="relative z-50">\n      <div className="fixed inset-0 bg-black/30" aria-hidden="true" />\n      \n      <div className="fixed inset-0 flex items-center justify-center p-4">\n        <Dialog.Panel className="mx-auto max-w-sm rounded bg-white p-6 shadow-lg">\n          <Dialog.Title className="text-lg font-medium text-gray-900 mb-4">\n            Session Expiring Soon\n          </Dialog.Title>\n          \n          <p className="text-sm text-gray-500 mb-4">\n            Your session will expire in{\' \'}\n            <span className="font-mono font-semibold text-red-600">\n              {formatTime(countdown)}\n            </span>\n          </p>\n          \n          <div className="flex gap-3">\n            <button\n              onClick={handleExtend}\n              disabled={extending}\n              className="flex-1 bg-blue-600 text-white px-4 py-2 rounded text-sm font-medium hover:bg-blue-700 disabled:opacity-50"\n            >\n              {extending ? \'Extending...\' : \'Stay Signed In\'}\n            </button>\n            \n            <button\n              onClick={onLogout}\n              className="flex-1 bg-gray-600 text-white px-4 py-2 rounded text-sm font-medium hover:bg-gray-700"\n            >\n              Sign Out\n            </button>\n          </div>\n        </Dialog.Panel>\n      </div>\n    </Dialog>\n  );\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"jwt-session-management",children:"JWT Session Management"}),"\n",(0,t.jsx)(n.h3,{id:"jwt-session-service",children:"JWT Session Service"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/auth/jwt-session.service.ts\nimport { Injectable, UnauthorizedException, Logger } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { Redis } from 'ioredis';\n\ninterface JWTPayload {\n  sub: string;\n  email: string;\n  role: string;\n  sessionId: string;\n  iat: number;\n  exp: number;\n}\n\ninterface RefreshTokenPayload {\n  sub: string;\n  sessionId: string;\n  tokenVersion: number;\n}\n\n@Injectable()\nexport class JWTSessionService {\n  private readonly logger = new Logger(JWTSessionService.name);\n  private redis: Redis;\n\n  constructor(\n    private jwtService: JwtService,\n    private configService: ConfigService\n  ) {\n    this.redis = new Redis({\n      host: this.configService.get('REDIS_HOST'),\n      port: this.configService.get('REDIS_PORT'),\n      password: this.configService.get('REDIS_PASSWORD'),\n      db: this.configService.get('REDIS_JWT_DB', 2),\n    });\n  }\n\n  async createSession(userId: string, email: string, role: string): Promise<{\n    accessToken: string;\n    refreshToken: string;\n    sessionId: string;\n  }> {\n    const sessionId = this.generateSessionId();\n    const tokenVersion = await this.getTokenVersion(userId);\n\n    // Store session metadata in Redis\n    await this.redis.hset(`session:${sessionId}`, {\n      userId,\n      email,\n      role,\n      createdAt: Date.now(),\n      lastActivity: Date.now(),\n      active: 'true',\n    });\n\n    // Set session expiration\n    await this.redis.expire(`session:${sessionId}`, 24 * 60 * 60); // 24 hours\n\n    const accessToken = this.jwtService.sign(\n      { sub: userId, email, role, sessionId },\n      { expiresIn: '15m' }\n    );\n\n    const refreshToken = this.jwtService.sign(\n      { sub: userId, sessionId, tokenVersion },\n      { \n        secret: this.configService.get('JWT_REFRESH_SECRET'),\n        expiresIn: '7d'\n      }\n    );\n\n    return { accessToken, refreshToken, sessionId };\n  }\n\n  async refreshSession(refreshToken: string): Promise<{\n    accessToken: string;\n    refreshToken?: string;\n  }> {\n    try {\n      const payload = this.jwtService.verify(refreshToken, {\n        secret: this.configService.get('JWT_REFRESH_SECRET'),\n      }) as RefreshTokenPayload;\n\n      // Verify session exists and is active\n      const sessionData = await this.redis.hgetall(`session:${payload.sessionId}`);\n      if (!sessionData.userId || sessionData.active !== 'true') {\n        throw new UnauthorizedException('Session not found or inactive');\n      }\n\n      // Verify token version\n      const currentTokenVersion = await this.getTokenVersion(payload.sub);\n      if (payload.tokenVersion !== currentTokenVersion) {\n        throw new UnauthorizedException('Token version mismatch');\n      }\n\n      // Update last activity\n      await this.redis.hset(`session:${payload.sessionId}`, 'lastActivity', Date.now());\n\n      // Generate new access token\n      const accessToken = this.jwtService.sign({\n        sub: payload.sub,\n        email: sessionData.email,\n        role: sessionData.role,\n        sessionId: payload.sessionId,\n      }, { expiresIn: '15m' });\n\n      // Optionally rotate refresh token\n      let newRefreshToken: string | undefined;\n      if (this.shouldRotateRefreshToken(refreshToken)) {\n        newRefreshToken = this.jwtService.sign(\n          { sub: payload.sub, sessionId: payload.sessionId, tokenVersion: currentTokenVersion },\n          {\n            secret: this.configService.get('JWT_REFRESH_SECRET'),\n            expiresIn: '7d'\n          }\n        );\n      }\n\n      return { accessToken, refreshToken: newRefreshToken };\n    } catch (error) {\n      this.logger.error('Token refresh failed:', error);\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n  }\n\n  async validateSession(sessionId: string): Promise<boolean> {\n    const sessionData = await this.redis.hgetall(`session:${sessionId}`);\n    return sessionData.userId && sessionData.active === 'true';\n  }\n\n  async destroySession(sessionId: string): Promise<void> {\n    await this.redis.del(`session:${sessionId}`);\n    this.logger.log(`Session destroyed: ${sessionId}`);\n  }\n\n  async destroyAllUserSessions(userId: string): Promise<void> {\n    const sessionKeys = await this.redis.keys(`session:*`);\n    \n    for (const key of sessionKeys) {\n      const sessionData = await this.redis.hgetall(key);\n      if (sessionData.userId === userId) {\n        await this.redis.del(key);\n      }\n    }\n\n    // Increment token version to invalidate all tokens\n    await this.incrementTokenVersion(userId);\n    \n    this.logger.log(`All sessions destroyed for user: ${userId}`);\n  }\n\n  async getActiveSessions(userId: string): Promise<any[]> {\n    const sessionKeys = await this.redis.keys(`session:*`);\n    const activeSessions = [];\n\n    for (const key of sessionKeys) {\n      const sessionData = await this.redis.hgetall(key);\n      if (sessionData.userId === userId && sessionData.active === 'true') {\n        activeSessions.push({\n          sessionId: key.split(':')[1],\n          createdAt: new Date(parseInt(sessionData.createdAt)),\n          lastActivity: new Date(parseInt(sessionData.lastActivity)),\n        });\n      }\n    }\n\n    return activeSessions;\n  }\n\n  private generateSessionId(): string {\n    const crypto = require('crypto');\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  private async getTokenVersion(userId: string): Promise<number> {\n    const version = await this.redis.get(`token_version:${userId}`);\n    return version ? parseInt(version) : 0;\n  }\n\n  private async incrementTokenVersion(userId: string): Promise<number> {\n    return await this.redis.incr(`token_version:${userId}`);\n  }\n\n  private shouldRotateRefreshToken(refreshToken: string): boolean {\n    try {\n      const decoded = this.jwtService.decode(refreshToken) as any;\n      const now = Date.now() / 1000;\n      const tokenAge = now - decoded.iat;\n      \n      // Rotate if token is older than 1 day\n      return tokenAge > 24 * 60 * 60;\n    } catch {\n      return true;\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"redis-session-store",children:"Redis Session Store"}),"\n",(0,t.jsx)(n.h3,{id:"redis-session-configuration",children:"Redis Session Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/session/redis-session.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Redis, Cluster } from 'ioredis';\n\ninterface SessionMetadata {\n  userId: string;\n  email: string;\n  role: string;\n  createdAt: number;\n  lastActivity: number;\n  ipAddress: string;\n  userAgent: string;\n  loginMethod: string;\n  metadata?: Record<string, any>;\n}\n\n@Injectable()\nexport class RedisSessionService {\n  private readonly logger = new Logger(RedisSessionService.name);\n  private redis: Redis | Cluster;\n\n  constructor(private configService: ConfigService) {\n    this.redis = this.createRedisConnection();\n  }\n\n  private createRedisConnection(): Redis | Cluster {\n    const isCluster = this.configService.get('REDIS_CLUSTER_MODE', false);\n    \n    if (isCluster) {\n      const clusterNodes = this.configService\n        .get('REDIS_CLUSTER_NODES', 'localhost:7000')\n        .split(',')\n        .map((node: string) => {\n          const [host, port] = node.split(':');\n          return { host, port: parseInt(port) };\n        });\n\n      return new Cluster(clusterNodes, {\n        redisOptions: {\n          password: this.configService.get('REDIS_PASSWORD'),\n        },\n        clusterRetryDelayOnFailover: 100,\n        maxRetriesPerRequest: 3,\n      });\n    }\n\n    return new Redis({\n      host: this.configService.get('REDIS_HOST'),\n      port: this.configService.get('REDIS_PORT'),\n      password: this.configService.get('REDIS_PASSWORD'),\n      retryDelayOnFailover: 100,\n      maxRetriesPerRequest: 3,\n      db: this.configService.get('REDIS_SESSION_DB', 1),\n    });\n  }\n\n  async createSession(sessionId: string, metadata: SessionMetadata): Promise<void> {\n    const sessionKey = `session:${sessionId}`;\n    const sessionData = {\n      ...metadata,\n      active: 'true',\n    };\n\n    try {\n      await this.redis.hmset(sessionKey, sessionData);\n      await this.redis.expire(sessionKey, this.getSessionTTL());\n      \n      // Add to user's active sessions list\n      await this.redis.sadd(`user_sessions:${metadata.userId}`, sessionId);\n      \n      this.logger.log(`Session created: ${sessionId} for user: ${metadata.userId}`);\n    } catch (error) {\n      this.logger.error('Failed to create session:', error);\n      throw error;\n    }\n  }\n\n  async getSession(sessionId: string): Promise<SessionMetadata | null> {\n    try {\n      const sessionData = await this.redis.hgetall(`session:${sessionId}`);\n      \n      if (!sessionData.userId || sessionData.active !== 'true') {\n        return null;\n      }\n\n      return {\n        userId: sessionData.userId,\n        email: sessionData.email,\n        role: sessionData.role,\n        createdAt: parseInt(sessionData.createdAt),\n        lastActivity: parseInt(sessionData.lastActivity),\n        ipAddress: sessionData.ipAddress,\n        userAgent: sessionData.userAgent,\n        loginMethod: sessionData.loginMethod,\n        metadata: sessionData.metadata ? JSON.parse(sessionData.metadata) : {},\n      };\n    } catch (error) {\n      this.logger.error(`Failed to get session ${sessionId}:`, error);\n      return null;\n    }\n  }\n\n  async updateSessionActivity(sessionId: string): Promise<void> {\n    try {\n      const sessionKey = `session:${sessionId}`;\n      await this.redis.hset(sessionKey, 'lastActivity', Date.now());\n      await this.redis.expire(sessionKey, this.getSessionTTL());\n    } catch (error) {\n      this.logger.error(`Failed to update session activity ${sessionId}:`, error);\n    }\n  }\n\n  async destroySession(sessionId: string): Promise<void> {\n    try {\n      const sessionData = await this.getSession(sessionId);\n      if (sessionData) {\n        await this.redis.srem(`user_sessions:${sessionData.userId}`, sessionId);\n      }\n      \n      await this.redis.del(`session:${sessionId}`);\n      this.logger.log(`Session destroyed: ${sessionId}`);\n    } catch (error) {\n      this.logger.error(`Failed to destroy session ${sessionId}:`, error);\n    }\n  }\n\n  async destroyAllUserSessions(userId: string): Promise<void> {\n    try {\n      const sessionIds = await this.redis.smembers(`user_sessions:${userId}`);\n      \n      if (sessionIds.length > 0) {\n        const sessionKeys = sessionIds.map(id => `session:${id}`);\n        await this.redis.del(...sessionKeys);\n        await this.redis.del(`user_sessions:${userId}`);\n      }\n      \n      this.logger.log(`All sessions destroyed for user: ${userId}`);\n    } catch (error) {\n      this.logger.error(`Failed to destroy all sessions for user ${userId}:`, error);\n    }\n  }\n\n  async getActiveSessionsForUser(userId: string): Promise<SessionMetadata[]> {\n    try {\n      const sessionIds = await this.redis.smembers(`user_sessions:${userId}`);\n      const sessions: SessionMetadata[] = [];\n\n      for (const sessionId of sessionIds) {\n        const session = await this.getSession(sessionId);\n        if (session) {\n          sessions.push(session);\n        }\n      }\n\n      return sessions;\n    } catch (error) {\n      this.logger.error(`Failed to get active sessions for user ${userId}:`, error);\n      return [];\n    }\n  }\n\n  async cleanupExpiredSessions(): Promise<void> {\n    try {\n      const cursor = '0';\n      const sessionKeys = await this.redis.keys('session:*');\n      let cleanedCount = 0;\n\n      for (const key of sessionKeys) {\n        const ttl = await this.redis.ttl(key);\n        if (ttl === -1 || ttl === -2) { // No expiry or expired\n          const sessionId = key.split(':')[1];\n          await this.destroySession(sessionId);\n          cleanedCount++;\n        }\n      }\n\n      this.logger.log(`Cleaned up ${cleanedCount} expired sessions`);\n    } catch (error) {\n      this.logger.error('Failed to cleanup expired sessions:', error);\n    }\n  }\n\n  private getSessionTTL(): number {\n    return this.configService.get('SESSION_TIMEOUT_MINUTES', 30) * 60; // Convert to seconds\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"session-security-monitoring",children:"Session Security Monitoring"}),"\n",(0,t.jsx)(n.h3,{id:"session-security-monitoring-service",children:"Session Security Monitoring Service"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/session/session-monitoring.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { RedisSessionService } from './redis-session.service';\nimport { ConfigService } from '@nestjs/config';\n\ninterface SecurityEvent {\n  type: 'SUSPICIOUS_LOGIN' | 'SESSION_HIJACKING' | 'CONCURRENT_SESSIONS' | 'UNUSUAL_ACTIVITY';\n  userId: string;\n  sessionId: string;\n  details: Record<string, any>;\n  timestamp: number;\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n}\n\n@Injectable()\nexport class SessionMonitoringService {\n  private readonly logger = new Logger(SessionMonitoringService.name);\n\n  constructor(\n    private redisSessionService: RedisSessionService,\n    private configService: ConfigService\n  ) {}\n\n  @Cron(CronExpression.EVERY_5_MINUTES)\n  async monitorSessions(): Promise<void> {\n    await this.detectConcurrentSessions();\n    await this.detectSuspiciousActivity();\n    await this.cleanupInactiveSessions();\n  }\n\n  async recordSecurityEvent(event: SecurityEvent): Promise<void> {\n    this.logger.warn(`Security event: ${event.type}`, event);\n    \n    // Store security event for analysis\n    // This could be sent to a SIEM system, logged to a security database, etc.\n    \n    if (event.severity === 'CRITICAL' || event.severity === 'HIGH') {\n      await this.handleHighSeverityEvent(event);\n    }\n  }\n\n  async detectSessionHijacking(\n    sessionId: string,\n    currentIP: string,\n    currentUserAgent: string\n  ): Promise<boolean> {\n    const session = await this.redisSessionService.getSession(sessionId);\n    \n    if (!session) {\n      return false;\n    }\n\n    let suspicious = false;\n\n    // Check for IP address change\n    if (session.ipAddress !== currentIP) {\n      await this.recordSecurityEvent({\n        type: 'SESSION_HIJACKING',\n        userId: session.userId,\n        sessionId,\n        details: {\n          originalIP: session.ipAddress,\n          currentIP,\n          reason: 'IP address change',\n        },\n        timestamp: Date.now(),\n        severity: 'HIGH',\n      });\n      suspicious = true;\n    }\n\n    // Check for user agent change\n    if (session.userAgent !== currentUserAgent) {\n      await this.recordSecurityEvent({\n        type: 'SESSION_HIJACKING',\n        userId: session.userId,\n        sessionId,\n        details: {\n          originalUserAgent: session.userAgent,\n          currentUserAgent,\n          reason: 'User agent change',\n        },\n        timestamp: Date.now(),\n        severity: 'MEDIUM',\n      });\n      suspicious = true;\n    }\n\n    return suspicious;\n  }\n\n  private async detectConcurrentSessions(): Promise<void> {\n    // Implementation to detect unusual concurrent session patterns\n    const maxConcurrentSessions = this.configService.get('MAX_CONCURRENT_SESSIONS', 3);\n    \n    // This would need to be implemented based on your session storage\n    // For now, it's a placeholder\n  }\n\n  private async detectSuspiciousActivity(): Promise<void> {\n    // Implementation to detect suspicious session activity patterns\n    // Such as rapid session creation, unusual login times, etc.\n  }\n\n  private async cleanupInactiveSessions(): Promise<void> {\n    await this.redisSessionService.cleanupExpiredSessions();\n  }\n\n  private async handleHighSeverityEvent(event: SecurityEvent): Promise<void> {\n    // Force logout the user\n    await this.redisSessionService.destroyAllUserSessions(event.userId);\n    \n    // Send immediate alert\n    await this.sendSecurityAlert(event);\n    \n    // Potentially block the IP address\n    if (event.type === 'SESSION_HIJACKING') {\n      await this.blockSuspiciousIP(event.details.currentIP);\n    }\n  }\n\n  private async sendSecurityAlert(event: SecurityEvent): Promise<void> {\n    // Implementation for sending security alerts\n    // This could integrate with Slack, email, PagerDuty, etc.\n    this.logger.error(`HIGH SEVERITY SECURITY EVENT: ${event.type}`, event);\n  }\n\n  private async blockSuspiciousIP(ip: string): Promise<void> {\n    // Implementation for blocking suspicious IP addresses\n    // This could integrate with Cloud Armor, fail2ban, etc.\n    this.logger.warn(`Blocking suspicious IP: ${ip}`);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This comprehensive session management implementation provides:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Secure session storage"})," with Redis and proper configuration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Secure cookie management"})," with encryption, integrity validation, and CSRF protection"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Session timeout and auto-logout"})," with client and server-side enforcement"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JWT session management"})," with refresh tokens and session validation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Redis session store"})," with clustering support and session metadata"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Session security monitoring"})," with hijacking detection and security event logging"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The implementation ensures that session management is secure, scalable, and monitored for security threats."})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},5741:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var i=s(9729);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);