"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[2028],{5741:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>s});var i=t(9729);const o={},r=i.createContext(o);function a(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),i.createElement(r.Provider,{value:e},n.children)}},9447:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>f,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"architecture-practices/architecture-execution/configuration-management","title":"Configuration Management Guide","description":"This guide provides comprehensive configuration management strategies for NestJS microservices and Next.js microfrontend applications, covering environment-specific configurations, secrets management, feature flags, and dynamic configuration updates.","source":"@site/docs/architecture-practices/architecture-execution/configuration-management.md","sourceDirName":"architecture-practices/architecture-execution","slug":"/architecture-practices/architecture-execution/configuration-management","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/configuration-management","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-execution/configuration-management.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Application Performance Monitoring Guide","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/application-monitoring"},"next":{"title":"Automated Deployment Guide","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/automated-deployment"}}');var o=t(5813),r=t(5741);const a={},s="Configuration Management Guide",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Configuration Architecture",id:"configuration-architecture",level:2},{value:"Centralized Configuration System",id:"centralized-configuration-system",level:3},{value:"NestJS Configuration Management",id:"nestjs-configuration-management",level:2},{value:"Configuration Module Setup",id:"configuration-module-setup",level:3},{value:"Typed Configuration Classes",id:"typed-configuration-classes",level:3},{value:"Database Configuration with Connection Pool",id:"database-configuration-with-connection-pool",level:3},{value:"Feature Flag Configuration",id:"feature-flag-configuration",level:3},{value:"Configuration Service with Hot Reload",id:"configuration-service-with-hot-reload",level:3},{value:"Next.js Configuration Management",id:"nextjs-configuration-management",level:2},{value:"Environment Configuration",id:"environment-configuration",level:3},{value:"Runtime Configuration Provider",id:"runtime-configuration-provider",level:3},{value:"Feature Flag Hook",id:"feature-flag-hook",level:3},{value:"Secrets Management",id:"secrets-management",level:2},{value:"HashiCorp Vault Integration",id:"hashicorp-vault-integration",level:3},{value:"Environment-Specific Configuration Files",id:"environment-specific-configuration-files",level:3},{value:"Configuration Validation &amp; Testing",id:"configuration-validation--testing",level:2},{value:"Configuration Testing",id:"configuration-testing",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function g(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"configuration-management-guide",children:"Configuration Management Guide"})}),"\n",(0,o.jsx)(e.p,{children:"This guide provides comprehensive configuration management strategies for NestJS microservices and Next.js microfrontend applications, covering environment-specific configurations, secrets management, feature flags, and dynamic configuration updates."}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"Configuration management ensures consistent, secure, and maintainable application settings across different environments. This guide covers centralized configuration, environment isolation, secrets handling, and configuration validation for microservices and microfrontend architectures."}),"\n",(0,o.jsx)(e.h2,{id:"configuration-architecture",children:"Configuration Architecture"}),"\n",(0,o.jsx)(e.h3,{id:"centralized-configuration-system",children:"Centralized Configuration System"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-mermaid",children:"graph TD\n    A[Configuration Store] --\x3e B[Environment Variables]\n    A --\x3e C[Configuration Files]\n    A --\x3e D[Remote Config Service]\n    A --\x3e E[Secret Manager]\n    \n    F[NestJS Services] --\x3e G[Config Module]\n    G --\x3e H[Environment Config]\n    G --\x3e I[Feature Flags]\n    G --\x3e J[Database Config]\n    \n    K[Next.js Frontend] --\x3e L[Public Config]\n    L --\x3e M[Build-time Config]\n    L --\x3e N[Runtime Config]\n    \n    O[Configuration Management] --\x3e P[Validation]\n    O --\x3e Q[Hot Reload]\n    O --\x3e R[Versioning]\n    O --\x3e S[Audit Trail]\n    \n    B --\x3e G\n    C --\x3e G\n    D --\x3e G\n    E --\x3e G\n    \n    B --\x3e L\n    M --\x3e L\n    N --\x3e L\n"})}),"\n",(0,o.jsx)(e.h2,{id:"nestjs-configuration-management",children:"NestJS Configuration Management"}),"\n",(0,o.jsx)(e.h3,{id:"configuration-module-setup",children:"Configuration Module Setup"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// src/config/config.module.ts\nimport { Module, Global } from '@nestjs/common';\nimport { ConfigModule as NestConfigModule, ConfigService } from '@nestjs/config';\nimport * as Joi from 'joi';\nimport { AppConfig } from './app.config';\nimport { DatabaseConfig } from './database.config';\nimport { RedisConfig } from './redis.config';\nimport { AuthConfig } from './auth.config';\nimport { FeatureFlagConfig } from './feature-flag.config';\n\nconst configValidationSchema = Joi.object({\n  NODE_ENV: Joi.string().valid('development', 'test', 'staging', 'production').required(),\n  PORT: Joi.number().default(3000),\n  \n  // Database\n  DATABASE_HOST: Joi.string().required(),\n  DATABASE_PORT: Joi.number().default(5432),\n  DATABASE_NAME: Joi.string().required(),\n  DATABASE_USERNAME: Joi.string().required(),\n  DATABASE_PASSWORD: Joi.string().required(),\n  DATABASE_SSL: Joi.boolean().default(false),\n  \n  // Redis\n  REDIS_HOST: Joi.string().required(),\n  REDIS_PORT: Joi.number().default(6379),\n  REDIS_PASSWORD: Joi.string().optional(),\n  \n  // JWT\n  JWT_SECRET: Joi.string().required(),\n  JWT_EXPIRES_IN: Joi.string().default('24h'),\n  \n  // External Services\n  EXTERNAL_API_URL: Joi.string().uri().required(),\n  EXTERNAL_API_KEY: Joi.string().required(),\n  \n  // Feature Flags\n  FEATURE_FLAG_SERVICE_URL: Joi.string().uri().optional(),\n  ENABLE_EXPERIMENTAL_FEATURES: Joi.boolean().default(false),\n  \n  // Monitoring\n  METRICS_ENABLED: Joi.boolean().default(true),\n  LOG_LEVEL: Joi.string().valid('error', 'warn', 'info', 'debug').default('info'),\n});\n\n@Global()\n@Module({\n  imports: [\n    NestConfigModule.forRoot({\n      isGlobal: true,\n      cache: true,\n      expandVariables: true,\n      validationSchema: configValidationSchema,\n      validationOptions: {\n        allowUnknown: true,\n        abortEarly: false,\n      },\n      load: [\n        AppConfig,\n        DatabaseConfig,\n        RedisConfig,\n        AuthConfig,\n        FeatureFlagConfig,\n      ],\n    }),\n  ],\n  providers: [ConfigService],\n  exports: [ConfigService],\n})\nexport class ConfigModule {}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"typed-configuration-classes",children:"Typed Configuration Classes"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// src/config/app.config.ts\nimport { registerAs } from '@nestjs/config';\nimport { Transform } from 'class-transformer';\nimport { IsString, IsNumber, IsBoolean, IsEnum, ValidateNested } from 'class-validator';\n\nexport enum Environment {\n  Development = 'development',\n  Test = 'test',\n  Staging = 'staging',\n  Production = 'production',\n}\n\nexport class CorsConfig {\n  @IsString({ each: true })\n  origins: string[];\n\n  @IsBoolean()\n  credentials: boolean;\n\n  @IsString({ each: true })\n  methods: string[];\n}\n\nexport class AppConfiguration {\n  @IsEnum(Environment)\n  nodeEnv: Environment;\n\n  @IsNumber()\n  @Transform(({ value }) => parseInt(value, 10))\n  port: number;\n\n  @IsString()\n  appName: string;\n\n  @IsString()\n  appVersion: string;\n\n  @ValidateNested()\n  cors: CorsConfig;\n\n  @IsBoolean()\n  @Transform(({ value }) => value === 'true')\n  metricsEnabled: boolean;\n\n  @IsString()\n  logLevel: string;\n\n  @IsString()\n  timeZone: string;\n}\n\nexport const AppConfig = registerAs('app', (): AppConfiguration => ({\n  nodeEnv: process.env.NODE_ENV as Environment,\n  port: parseInt(process.env.PORT || '3000', 10),\n  appName: process.env.APP_NAME || 'microservice',\n  appVersion: process.env.APP_VERSION || '1.0.0',\n  cors: {\n    origins: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],\n    credentials: process.env.CORS_CREDENTIALS === 'true',\n    methods: process.env.CORS_METHODS?.split(',') || ['GET', 'POST', 'PUT', 'DELETE'],\n  },\n  metricsEnabled: process.env.METRICS_ENABLED !== 'false',\n  logLevel: process.env.LOG_LEVEL || 'info',\n  timeZone: process.env.TZ || 'UTC',\n}));\n"})}),"\n",(0,o.jsx)(e.h3,{id:"database-configuration-with-connection-pool",children:"Database Configuration with Connection Pool"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// src/config/database.config.ts\nimport { registerAs } from '@nestjs/config';\nimport { TypeOrmModuleOptions } from '@nestjs/typeorm';\n\nexport interface DatabaseConfiguration extends TypeOrmModuleOptions {\n  host: string;\n  port: number;\n  database: string;\n  username: string;\n  password: string;\n  ssl: boolean;\n  pool: {\n    min: number;\n    max: number;\n    idle: number;\n  };\n  logging: boolean;\n  synchronize: boolean;\n  migrationsRun: boolean;\n}\n\nexport const DatabaseConfig = registerAs('database', (): DatabaseConfiguration => {\n  const isProduction = process.env.NODE_ENV === 'production';\n  \n  return {\n    type: 'postgres',\n    host: process.env.DATABASE_HOST!,\n    port: parseInt(process.env.DATABASE_PORT || '5432', 10),\n    database: process.env.DATABASE_NAME!,\n    username: process.env.DATABASE_USERNAME!,\n    password: process.env.DATABASE_PASSWORD!,\n    ssl: process.env.DATABASE_SSL === 'true' ? {\n      rejectUnauthorized: false,\n    } : false,\n    entities: [`${__dirname}/../**/*.entity{.ts,.js}`],\n    migrations: [`${__dirname}/../migrations/*{.ts,.js}`],\n    subscribers: [`${__dirname}/../**/*.subscriber{.ts,.js}`],\n    pool: {\n      min: parseInt(process.env.DATABASE_POOL_MIN || '2', 10),\n      max: parseInt(process.env.DATABASE_POOL_MAX || '10', 10),\n      idle: parseInt(process.env.DATABASE_POOL_IDLE || '10000', 10),\n    },\n    logging: process.env.DATABASE_LOGGING === 'true',\n    synchronize: process.env.DATABASE_SYNC === 'true' && !isProduction,\n    migrationsRun: isProduction,\n    retryAttempts: 3,\n    retryDelay: 3000,\n    autoLoadEntities: true,\n    keepConnectionAlive: true,\n  };\n});\n"})}),"\n",(0,o.jsx)(e.h3,{id:"feature-flag-configuration",children:"Feature Flag Configuration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// src/config/feature-flag.config.ts\nimport { registerAs } from '@nestjs/config';\n\nexport interface FeatureFlag {\n  name: string;\n  enabled: boolean;\n  rolloutPercentage?: number;\n  conditions?: Record<string, any>;\n  description?: string;\n}\n\nexport interface FeatureFlagConfiguration {\n  serviceUrl?: string;\n  refreshInterval: number;\n  flags: Record<string, FeatureFlag>;\n}\n\nexport const FeatureFlagConfig = registerAs('featureFlags', (): FeatureFlagConfiguration => ({\n  serviceUrl: process.env.FEATURE_FLAG_SERVICE_URL,\n  refreshInterval: parseInt(process.env.FEATURE_FLAG_REFRESH_INTERVAL || '60000', 10),\n  flags: {\n    enableNewUserOnboarding: {\n      name: 'enableNewUserOnboarding',\n      enabled: process.env.FEATURE_NEW_USER_ONBOARDING === 'true',\n      rolloutPercentage: parseInt(process.env.FEATURE_NEW_USER_ONBOARDING_ROLLOUT || '100', 10),\n      description: 'Enable new user onboarding flow',\n    },\n    enableAdvancedAnalytics: {\n      name: 'enableAdvancedAnalytics',\n      enabled: process.env.FEATURE_ADVANCED_ANALYTICS === 'true',\n      rolloutPercentage: parseInt(process.env.FEATURE_ADVANCED_ANALYTICS_ROLLOUT || '0', 10),\n      description: 'Enable advanced analytics features',\n    },\n    enableExperimentalAPI: {\n      name: 'enableExperimentalAPI',\n      enabled: process.env.FEATURE_EXPERIMENTAL_API === 'true',\n      conditions: {\n        environment: ['development', 'staging'],\n        userRole: ['admin', 'beta-tester'],\n      },\n      description: 'Enable experimental API endpoints',\n    },\n  },\n}));\n"})}),"\n",(0,o.jsx)(e.h3,{id:"configuration-service-with-hot-reload",children:"Configuration Service with Hot Reload"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// src/config/dynamic-config.service.ts\nimport { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { EventEmitter2 } from '@nestjs/event-emitter';\nimport { Interval } from '@nestjs/schedule';\nimport axios from 'axios';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport interface ConfigChangeEvent {\n  key: string;\n  oldValue: any;\n  newValue: any;\n  timestamp: Date;\n}\n\n@Injectable()\nexport class DynamicConfigService implements OnModuleInit {\n  private readonly logger = new Logger(DynamicConfigService.name);\n  private configCache = new Map<string, any>();\n  private lastUpdateTime = new Date();\n\n  constructor(\n    private readonly configService: ConfigService,\n    private readonly eventEmitter: EventEmitter2,\n  ) {}\n\n  async onModuleInit(): Promise<void> {\n    await this.loadInitialConfig();\n    this.startConfigRefresh();\n  }\n\n  private async loadInitialConfig(): Promise<void> {\n    try {\n      // Load from environment variables\n      this.loadEnvironmentConfig();\n\n      // Load from remote config service if available\n      const remoteConfigUrl = this.configService.get('REMOTE_CONFIG_URL');\n      if (remoteConfigUrl) {\n        await this.loadRemoteConfig(remoteConfigUrl);\n      }\n\n      // Load from local config files\n      await this.loadFileConfig();\n\n      this.logger.log('Initial configuration loaded successfully');\n    } catch (error) {\n      this.logger.error('Failed to load initial configuration', error);\n    }\n  }\n\n  private loadEnvironmentConfig(): void {\n    const envVars = process.env;\n    for (const [key, value] of Object.entries(envVars)) {\n      if (key.startsWith('APP_CONFIG_')) {\n        const configKey = key.replace('APP_CONFIG_', '').toLowerCase();\n        this.setConfig(configKey, this.parseConfigValue(value));\n      }\n    }\n  }\n\n  private async loadRemoteConfig(url: string): Promise<void> {\n    try {\n      const response = await axios.get(url, {\n        timeout: 5000,\n        headers: {\n          'Authorization': `Bearer ${this.configService.get('REMOTE_CONFIG_TOKEN')}`,\n        },\n      });\n\n      if (response.data && typeof response.data === 'object') {\n        for (const [key, value] of Object.entries(response.data)) {\n          this.setConfig(key, value);\n        }\n        this.logger.log('Remote configuration loaded successfully');\n      }\n    } catch (error) {\n      this.logger.warn('Failed to load remote configuration', error.message);\n    }\n  }\n\n  private async loadFileConfig(): Promise<void> {\n    try {\n      const configDir = path.join(process.cwd(), 'config');\n      const environment = this.configService.get('NODE_ENV', 'development');\n      const configFile = path.join(configDir, `${environment}.json`);\n\n      try {\n        const configContent = await fs.readFile(configFile, 'utf-8');\n        const config = JSON.parse(configContent);\n        \n        for (const [key, value] of Object.entries(config)) {\n          this.setConfig(key, value);\n        }\n        \n        this.logger.log(`File configuration loaded from ${configFile}`);\n      } catch (fileError) {\n        this.logger.debug(`No configuration file found at ${configFile}`);\n      }\n    } catch (error) {\n      this.logger.warn('Failed to load file configuration', error);\n    }\n  }\n\n  @Interval(60000) // Refresh every minute\n  private async startConfigRefresh(): Promise<void> {\n    try {\n      const remoteConfigUrl = this.configService.get('REMOTE_CONFIG_URL');\n      if (remoteConfigUrl) {\n        await this.refreshRemoteConfig(remoteConfigUrl);\n      }\n    } catch (error) {\n      this.logger.error('Failed to refresh configuration', error);\n    }\n  }\n\n  private async refreshRemoteConfig(url: string): Promise<void> {\n    try {\n      const response = await axios.get(url, {\n        timeout: 5000,\n        headers: {\n          'Authorization': `Bearer ${this.configService.get('REMOTE_CONFIG_TOKEN')}`,\n          'If-Modified-Since': this.lastUpdateTime.toISOString(),\n        },\n      });\n\n      if (response.status === 200 && response.data) {\n        const changes: ConfigChangeEvent[] = [];\n        \n        for (const [key, newValue] of Object.entries(response.data)) {\n          const oldValue = this.configCache.get(key);\n          if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {\n            changes.push({\n              key,\n              oldValue,\n              newValue,\n              timestamp: new Date(),\n            });\n            this.setConfig(key, newValue);\n          }\n        }\n\n        if (changes.length > 0) {\n          this.logger.log(`Configuration updated: ${changes.length} changes`);\n          for (const change of changes) {\n            this.eventEmitter.emit('config.changed', change);\n          }\n        }\n\n        this.lastUpdateTime = new Date();\n      }\n    } catch (error) {\n      if (error.response?.status !== 304) { // 304 = Not Modified\n        this.logger.warn('Failed to refresh remote configuration', error.message);\n      }\n    }\n  }\n\n  private setConfig(key: string, value: any): void {\n    this.configCache.set(key, value);\n  }\n\n  get<T = any>(key: string, defaultValue?: T): T {\n    return this.configCache.get(key) ?? defaultValue;\n  }\n\n  has(key: string): boolean {\n    return this.configCache.has(key);\n  }\n\n  getAll(): Record<string, any> {\n    return Object.fromEntries(this.configCache.entries());\n  }\n\n  private parseConfigValue(value: string | undefined): any {\n    if (!value) return undefined;\n\n    // Try to parse as JSON\n    try {\n      return JSON.parse(value);\n    } catch {\n      // Return as string if not valid JSON\n      return value;\n    }\n  }\n\n  async reloadConfig(): Promise<void> {\n    this.logger.log('Manually reloading configuration...');\n    await this.loadInitialConfig();\n  }\n\n  // Configuration validation\n  validateConfig<T>(schema: any, config: T): { isValid: boolean; errors: string[] } {\n    const { error } = schema.validate(config, { abortEarly: false });\n    \n    if (error) {\n      return {\n        isValid: false,\n        errors: error.details.map((detail: any) => detail.message),\n      };\n    }\n\n    return { isValid: true, errors: [] };\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"nextjs-configuration-management",children:"Next.js Configuration Management"}),"\n",(0,o.jsx)(e.h3,{id:"environment-configuration",children:"Environment Configuration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// lib/config/environment.ts\nimport { z } from 'zod';\n\n// Client-side configuration schema (publicly available)\nconst clientConfigSchema = z.object({\n  APP_NAME: z.string().default('Microservice App'),\n  APP_VERSION: z.string().default('1.0.0'),\n  API_BASE_URL: z.string().url(),\n  ENVIRONMENT: z.enum(['development', 'staging', 'production']).default('development'),\n  FEATURE_FLAGS: z.object({\n    enableNewUI: z.boolean().default(false),\n    enableAnalytics: z.boolean().default(true),\n    enableExperimentalFeatures: z.boolean().default(false),\n  }),\n  SENTRY_DSN: z.string().optional(),\n  GOOGLE_ANALYTICS_ID: z.string().optional(),\n});\n\n// Server-side configuration schema (includes secrets)\nconst serverConfigSchema = clientConfigSchema.extend({\n  DATABASE_URL: z.string(),\n  REDIS_URL: z.string(),\n  JWT_SECRET: z.string(),\n  API_SECRET_KEY: z.string(),\n  NEXTAUTH_SECRET: z.string(),\n  NEXTAUTH_URL: z.string().url(),\n});\n\nexport type ClientConfig = z.infer<typeof clientConfigSchema>;\nexport type ServerConfig = z.infer<typeof serverConfigSchema>;\n\nclass ConfigManager {\n  private clientConfig: ClientConfig | null = null;\n  private serverConfig: ServerConfig | null = null;\n\n  getClientConfig(): ClientConfig {\n    if (!this.clientConfig) {\n      this.clientConfig = this.loadClientConfig();\n    }\n    return this.clientConfig;\n  }\n\n  getServerConfig(): ServerConfig {\n    if (typeof window !== 'undefined') {\n      throw new Error('Server configuration cannot be accessed on the client side');\n    }\n\n    if (!this.serverConfig) {\n      this.serverConfig = this.loadServerConfig();\n    }\n    return this.serverConfig;\n  }\n\n  private loadClientConfig(): ClientConfig {\n    const config = {\n      APP_NAME: process.env.NEXT_PUBLIC_APP_NAME,\n      APP_VERSION: process.env.NEXT_PUBLIC_APP_VERSION,\n      API_BASE_URL: process.env.NEXT_PUBLIC_API_BASE_URL!,\n      ENVIRONMENT: process.env.NEXT_PUBLIC_ENVIRONMENT,\n      FEATURE_FLAGS: {\n        enableNewUI: process.env.NEXT_PUBLIC_FEATURE_NEW_UI === 'true',\n        enableAnalytics: process.env.NEXT_PUBLIC_FEATURE_ANALYTICS !== 'false',\n        enableExperimentalFeatures: process.env.NEXT_PUBLIC_FEATURE_EXPERIMENTAL === 'true',\n      },\n      SENTRY_DSN: process.env.NEXT_PUBLIC_SENTRY_DSN,\n      GOOGLE_ANALYTICS_ID: process.env.NEXT_PUBLIC_GA_ID,\n    };\n\n    const result = clientConfigSchema.safeParse(config);\n    \n    if (!result.success) {\n      console.error('Client configuration validation failed:', result.error.format());\n      throw new Error('Invalid client configuration');\n    }\n\n    return result.data;\n  }\n\n  private loadServerConfig(): ServerConfig {\n    const config = {\n      ...this.getClientConfig(),\n      DATABASE_URL: process.env.DATABASE_URL!,\n      REDIS_URL: process.env.REDIS_URL!,\n      JWT_SECRET: process.env.JWT_SECRET!,\n      API_SECRET_KEY: process.env.API_SECRET_KEY!,\n      NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET!,\n      NEXTAUTH_URL: process.env.NEXTAUTH_URL!,\n    };\n\n    const result = serverConfigSchema.safeParse(config);\n    \n    if (!result.success) {\n      console.error('Server configuration validation failed:', result.error.format());\n      throw new Error('Invalid server configuration');\n    }\n\n    return result.data;\n  }\n\n  // Reload configuration (useful for hot reloading in development)\n  reload(): void {\n    this.clientConfig = null;\n    this.serverConfig = null;\n  }\n\n  // Get specific configuration value with type safety\n  get<K extends keyof ClientConfig>(key: K): ClientConfig[K];\n  get<K extends keyof ServerConfig>(key: K, serverOnly: true): ServerConfig[K];\n  get<K extends keyof ClientConfig | keyof ServerConfig>(\n    key: K,\n    serverOnly = false\n  ): any {\n    if (serverOnly) {\n      return this.getServerConfig()[key as keyof ServerConfig];\n    }\n    return this.getClientConfig()[key as keyof ClientConfig];\n  }\n}\n\nexport const configManager = new ConfigManager();\n\n// Convenience functions\nexport const getClientConfig = () => configManager.getClientConfig();\nexport const getServerConfig = () => configManager.getServerConfig();\n\n// Type-safe configuration getters\nexport const getConfig = <K extends keyof ClientConfig>(key: K) => \n  configManager.get(key);\n\nexport const getServerOnlyConfig = <K extends keyof ServerConfig>(key: K) =>\n  configManager.get(key, true);\n"})}),"\n",(0,o.jsx)(e.h3,{id:"runtime-configuration-provider",children:"Runtime Configuration Provider"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// components/providers/config-provider.tsx\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport { ClientConfig, getClientConfig } from '../../lib/config/environment';\n\ninterface ConfigContextType {\n  config: ClientConfig;\n  isLoading: boolean;\n  error: Error | null;\n  refresh: () => Promise<void>;\n}\n\nconst ConfigContext = createContext<ConfigContextType | undefined>(undefined);\n\nexport const useConfig = () => {\n  const context = useContext(ConfigContext);\n  if (!context) {\n    throw new Error('useConfig must be used within ConfigProvider');\n  }\n  return context;\n};\n\ninterface ConfigProviderProps {\n  children: React.ReactNode;\n  initialConfig?: ClientConfig;\n}\n\nexport const ConfigProvider: React.FC<ConfigProviderProps> = ({ \n  children, \n  initialConfig \n}) => {\n  const [config, setConfig] = useState<ClientConfig>(() => \n    initialConfig || getClientConfig()\n  );\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const refresh = async () => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      // Fetch runtime configuration from API\n      const response = await fetch('/api/config');\n      if (!response.ok) {\n        throw new Error(`Failed to fetch config: ${response.statusText}`);\n      }\n\n      const runtimeConfig = await response.json();\n      \n      // Merge with build-time configuration\n      const mergedConfig = {\n        ...config,\n        ...runtimeConfig,\n        FEATURE_FLAGS: {\n          ...config.FEATURE_FLAGS,\n          ...runtimeConfig.FEATURE_FLAGS,\n        },\n      };\n\n      setConfig(mergedConfig);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Unknown error'));\n      console.error('Failed to refresh configuration:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    // Refresh configuration periodically\n    const interval = setInterval(() => {\n      refresh();\n    }, 5 * 60 * 1000); // Every 5 minutes\n\n    return () => clearInterval(interval);\n  }, []);\n\n  const value: ConfigContextType = {\n    config,\n    isLoading,\n    error,\n    refresh,\n  };\n\n  return (\n    <ConfigContext.Provider value={value}>\n      {children}\n    </ConfigContext.Provider>\n  );\n};\n"})}),"\n",(0,o.jsx)(e.h3,{id:"feature-flag-hook",children:"Feature Flag Hook"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// hooks/use-feature-flag.ts\nimport { useConfig } from '../components/providers/config-provider';\nimport { useState, useEffect } from 'react';\n\nexport interface FeatureFlagOptions {\n  userId?: string;\n  userRole?: string;\n  metadata?: Record<string, any>;\n}\n\nexport const useFeatureFlag = (\n  flagName: keyof ClientConfig['FEATURE_FLAGS'],\n  options: FeatureFlagOptions = {}\n) => {\n  const { config } = useConfig();\n  const [isEnabled, setIsEnabled] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    const evaluateFlag = async () => {\n      setIsLoading(true);\n\n      try {\n        // Get base flag value from configuration\n        const baseValue = config.FEATURE_FLAGS[flagName];\n\n        // For simple flags, just return the configured value\n        if (typeof baseValue === 'boolean') {\n          setIsEnabled(baseValue);\n          return;\n        }\n\n        // For advanced feature flags, call evaluation service\n        const response = await fetch('/api/feature-flags/evaluate', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            flagName,\n            context: {\n              userId: options.userId,\n              userRole: options.userRole,\n              ...options.metadata,\n            },\n          }),\n        });\n\n        if (response.ok) {\n          const result = await response.json();\n          setIsEnabled(result.enabled);\n        } else {\n          // Fallback to configured value if service is unavailable\n          setIsEnabled(Boolean(baseValue));\n        }\n      } catch (error) {\n        console.error(`Failed to evaluate feature flag ${flagName}:`, error);\n        // Fallback to configured value\n        setIsEnabled(Boolean(config.FEATURE_FLAGS[flagName]));\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    evaluateFlag();\n  }, [flagName, config.FEATURE_FLAGS, options.userId, options.userRole]);\n\n  return { isEnabled, isLoading };\n};\n\n// HOC for feature flag-based rendering\nexport const withFeatureFlag = <P extends object>(\n  Component: React.ComponentType<P>,\n  flagName: keyof ClientConfig['FEATURE_FLAGS'],\n  fallback?: React.ComponentType<P>\n) => {\n  const WrappedComponent: React.FC<P & FeatureFlagOptions> = (props) => {\n    const { isEnabled, isLoading } = useFeatureFlag(flagName, props);\n\n    if (isLoading) {\n      return <div>Loading...</div>;\n    }\n\n    if (!isEnabled) {\n      return fallback ? <fallback {...props} /> : null;\n    }\n\n    return <Component {...props} />;\n  };\n\n  WrappedComponent.displayName = `withFeatureFlag(${Component.displayName || Component.name})`;\n\n  return WrappedComponent;\n};\n"})}),"\n",(0,o.jsx)(e.h2,{id:"secrets-management",children:"Secrets Management"}),"\n",(0,o.jsx)(e.h3,{id:"hashicorp-vault-integration",children:"HashiCorp Vault Integration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// src/config/vault.service.ts\nimport { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport axios, { AxiosInstance } from 'axios';\n\nexport interface VaultSecret {\n  data: Record<string, any>;\n  metadata: {\n    created_time: string;\n    version: number;\n  };\n}\n\n@Injectable()\nexport class VaultService implements OnModuleInit {\n  private readonly logger = new Logger(VaultService.name);\n  private client: AxiosInstance;\n  private token: string | null = null;\n  private secrets = new Map<string, any>();\n\n  constructor(private readonly configService: ConfigService) {\n    const vaultUrl = this.configService.get('VAULT_URL');\n    \n    this.client = axios.create({\n      baseURL: vaultUrl,\n      timeout: 10000,\n    });\n  }\n\n  async onModuleInit(): Promise<void> {\n    try {\n      await this.authenticate();\n      await this.loadSecrets();\n    } catch (error) {\n      this.logger.error('Failed to initialize Vault service', error);\n    }\n  }\n\n  private async authenticate(): Promise<void> {\n    const authMethod = this.configService.get('VAULT_AUTH_METHOD', 'token');\n\n    switch (authMethod) {\n      case 'token':\n        await this.authenticateWithToken();\n        break;\n      case 'kubernetes':\n        await this.authenticateWithKubernetes();\n        break;\n      case 'app-role':\n        await this.authenticateWithAppRole();\n        break;\n      default:\n        throw new Error(`Unsupported Vault auth method: ${authMethod}`);\n    }\n  }\n\n  private async authenticateWithToken(): Promise<void> {\n    this.token = this.configService.get('VAULT_TOKEN');\n    if (!this.token) {\n      throw new Error('Vault token not provided');\n    }\n\n    this.client.defaults.headers.common['X-Vault-Token'] = this.token;\n    \n    // Verify token\n    const response = await this.client.get('/v1/auth/token/lookup-self');\n    this.logger.log('Successfully authenticated with Vault using token');\n  }\n\n  private async authenticateWithKubernetes(): Promise<void> {\n    const jwt = await this.getServiceAccountToken();\n    const role = this.configService.get('VAULT_K8S_ROLE');\n\n    const response = await this.client.post('/v1/auth/kubernetes/login', {\n      role,\n      jwt,\n    });\n\n    this.token = response.data.auth.client_token;\n    this.client.defaults.headers.common['X-Vault-Token'] = this.token;\n    \n    this.logger.log('Successfully authenticated with Vault using Kubernetes auth');\n  }\n\n  private async authenticateWithAppRole(): Promise<void> {\n    const roleId = this.configService.get('VAULT_ROLE_ID');\n    const secretId = this.configService.get('VAULT_SECRET_ID');\n\n    const response = await this.client.post('/v1/auth/approle/login', {\n      role_id: roleId,\n      secret_id: secretId,\n    });\n\n    this.token = response.data.auth.client_token;\n    this.client.defaults.headers.common['X-Vault-Token'] = this.token;\n    \n    this.logger.log('Successfully authenticated with Vault using AppRole');\n  }\n\n  private async getServiceAccountToken(): Promise<string> {\n    const fs = await import('fs/promises');\n    const tokenPath = '/var/run/secrets/kubernetes.io/serviceaccount/token';\n    return fs.readFile(tokenPath, 'utf8');\n  }\n\n  private async loadSecrets(): Promise<void> {\n    const secretPaths = this.configService.get<string[]>('VAULT_SECRET_PATHS', []);\n    \n    for (const path of secretPaths) {\n      try {\n        const secret = await this.getSecret(path);\n        this.secrets.set(path, secret);\n        this.logger.log(`Loaded secret from ${path}`);\n      } catch (error) {\n        this.logger.error(`Failed to load secret from ${path}`, error);\n      }\n    }\n  }\n\n  async getSecret(path: string): Promise<VaultSecret> {\n    try {\n      const response = await this.client.get(`/v1/secret/data/${path}`);\n      return response.data.data;\n    } catch (error) {\n      this.logger.error(`Failed to get secret from ${path}`, error);\n      throw error;\n    }\n  }\n\n  async setSecret(path: string, data: Record<string, any>): Promise<void> {\n    try {\n      await this.client.post(`/v1/secret/data/${path}`, { data });\n      this.secrets.set(path, { data });\n      this.logger.log(`Set secret at ${path}`);\n    } catch (error) {\n      this.logger.error(`Failed to set secret at ${path}`, error);\n      throw error;\n    }\n  }\n\n  getCachedSecret(path: string): any {\n    return this.secrets.get(path)?.data;\n  }\n\n  async refreshSecrets(): Promise<void> {\n    this.logger.log('Refreshing all secrets...');\n    await this.loadSecrets();\n  }\n\n  // Periodic secret refresh\n  async startSecretRefresh(intervalMs = 300000): Promise<void> { // 5 minutes\n    setInterval(async () => {\n      try {\n        await this.refreshSecrets();\n      } catch (error) {\n        this.logger.error('Failed to refresh secrets', error);\n      }\n    }, intervalMs);\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"environment-specific-configuration-files",children:"Environment-Specific Configuration Files"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# config/development.yml\napp:\n  name: "Microservice Development"\n  debug: true\n  logLevel: debug\n\ndatabase:\n  host: localhost\n  port: 5432\n  database: myapp_dev\n  pool:\n    min: 1\n    max: 5\n\nredis:\n  host: localhost\n  port: 6379\n  db: 0\n\nfeatureFlags:\n  enableExperimentalFeatures: true\n  enableDebugMode: true\n\nmonitoring:\n  enabled: false\n  sampleRate: 1.0\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# config/production.yml\napp:\n  name: "Microservice Production"\n  debug: false\n  logLevel: warn\n\ndatabase:\n  pool:\n    min: 5\n    max: 20\n  ssl: true\n\nfeatureFlags:\n  enableExperimentalFeatures: false\n  enableDebugMode: false\n\nmonitoring:\n  enabled: true\n  sampleRate: 0.1\n\nsecurity:\n  enforceHttps: true\n  rateLimiting:\n    enabled: true\n    windowMs: 900000\n    max: 100\n'})}),"\n",(0,o.jsx)(e.h2,{id:"configuration-validation--testing",children:"Configuration Validation & Testing"}),"\n",(0,o.jsx)(e.h3,{id:"configuration-testing",children:"Configuration Testing"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// src/config/config.spec.ts\nimport { Test } from '@nestjs/testing';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { AppConfig } from './app.config';\nimport { DatabaseConfig } from './database.config';\n\ndescribe('Configuration', () => {\n  let configService: ConfigService;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({\n          load: [AppConfig, DatabaseConfig],\n          envFilePath: '.env.test',\n        }),\n      ],\n    }).compile();\n\n    configService = module.get<ConfigService>(ConfigService);\n  });\n\n  describe('App Configuration', () => {\n    it('should load app configuration', () => {\n      const appConfig = configService.get('app');\n      expect(appConfig).toBeDefined();\n      expect(appConfig.nodeEnv).toBe('test');\n    });\n\n    it('should have required configuration values', () => {\n      expect(configService.get('app.port')).toBeDefined();\n      expect(configService.get('app.appName')).toBeDefined();\n    });\n\n    it('should validate CORS configuration', () => {\n      const corsConfig = configService.get('app.cors');\n      expect(corsConfig.origins).toBeInstanceOf(Array);\n      expect(corsConfig.credentials).toBeDefined();\n    });\n  });\n\n  describe('Database Configuration', () => {\n    it('should load database configuration', () => {\n      const dbConfig = configService.get('database');\n      expect(dbConfig).toBeDefined();\n      expect(dbConfig.host).toBeDefined();\n      expect(dbConfig.port).toBeGreaterThan(0);\n    });\n\n    it('should have proper pool configuration', () => {\n      const poolConfig = configService.get('database.pool');\n      expect(poolConfig.min).toBeGreaterThanOrEqual(1);\n      expect(poolConfig.max).toBeGreaterThan(poolConfig.min);\n    });\n  });\n\n  describe('Environment-specific settings', () => {\n    it('should disable synchronize in production', () => {\n      process.env.NODE_ENV = 'production';\n      const dbConfig = configService.get('database');\n      expect(dbConfig.synchronize).toBe(false);\n    });\n\n    it('should enable debug mode in development', () => {\n      process.env.NODE_ENV = 'development';\n      const appConfig = configService.get('app');\n      expect(appConfig.debug).toBe(true);\n    });\n  });\n});\n"})}),"\n",(0,o.jsx)(e.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/infrastructure-monitoring",children:"Infrastructure Monitoring"})})," - Configuration monitoring and alerting"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/deployment-automation",children:"Deployment Automation"})})," - Environment-specific deployments"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-definition/third-party-integration",children:"Third-party Integration"})})," - External service configuration"]}),"\n"]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.p,{children:"This configuration management guide should be regularly updated to incorporate new configuration patterns and security best practices."})]})}function f(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(g,{...n})}):g(n)}}}]);