"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[78],{4190:(s,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"security-practices/security-implementation/asset-management-risk-assessment","title":"Asset Management & Risk Assessment Implementation Guide","description":"This guide provides comprehensive asset management and risk assessment implementation for NestJS/Next.js applications on GCP Kubernetes, covering asset identification, classification, risk assessment, and continuous monitoring.","source":"@site/docs/security-practices/security-implementation/asset-management-risk-assessment.md","sourceDirName":"security-practices/security-implementation","slug":"/security-practices/security-implementation/asset-management-risk-assessment","permalink":"/fullstack-dev/docs/security-practices/security-implementation/asset-management-risk-assessment","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/security-practices/security-implementation/asset-management-risk-assessment.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Security Awareness Training Implementation Guide","permalink":"/fullstack-dev/docs/security-practices/security-implementation/security-awareness-training"},"next":{"title":"Security Operations","permalink":"/fullstack-dev/docs/security-practices/security-operations/"}}');var i=n(5813),a=n(7814);const r={},o="Asset Management & Risk Assessment Implementation Guide",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Asset Discovery &amp; Inventory",id:"asset-discovery--inventory",level:2},{value:"Asset Inventory Service",id:"asset-inventory-service",level:3},{value:"Asset Classification &amp; Valuation",id:"asset-classification--valuation",level:2},{value:"Asset Classification Service",id:"asset-classification-service",level:3},{value:"Risk Assessment Framework",id:"risk-assessment-framework",level:2},{value:"Risk Assessment Service",id:"risk-assessment-service",level:3},{value:"Threat Modeling",id:"threat-modeling",level:2},{value:"STRIDE Threat Analysis",id:"stride-threat-analysis",level:3},{value:"Attack Vector Analysis",id:"attack-vector-analysis",level:3},{value:"Risk Monitoring &amp; Reporting",id:"risk-monitoring--reporting",level:2},{value:"Continuous Risk Assessment",id:"continuous-risk-assessment",level:3},{value:"Risk Reporting Framework",id:"risk-reporting-framework",level:3},{value:"Compliance &amp; Governance",id:"compliance--governance",level:2},{value:"Regulatory Compliance Management",id:"regulatory-compliance-management",level:3},{value:"Governance Framework",id:"governance-framework",level:3}];function d(s){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...s.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"asset-management--risk-assessment-implementation-guide",children:"Asset Management & Risk Assessment Implementation Guide"})}),"\n",(0,i.jsx)(e.p,{children:"This guide provides comprehensive asset management and risk assessment implementation for NestJS/Next.js applications on GCP Kubernetes, covering asset identification, classification, risk assessment, and continuous monitoring."}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#asset-discovery--inventory",children:"Asset Discovery & Inventory"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#asset-classification--valuation",children:"Asset Classification & Valuation"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#risk-assessment-framework",children:"Risk Assessment Framework"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#threat-modeling",children:"Threat Modeling"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#risk-monitoring--reporting",children:"Risk Monitoring & Reporting"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#compliance--governance",children:"Compliance & Governance"})}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"asset-discovery--inventory",children:"Asset Discovery & Inventory"}),"\n",(0,i.jsx)(e.h3,{id:"asset-inventory-service",children:"Asset Inventory Service"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// src/asset-management/asset-inventory.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\ninterface Asset {\n  id: string;\n  name: string;\n  type: 'INFRASTRUCTURE' | 'APPLICATION' | 'DATA' | 'NETWORK' | 'SECURITY_CONTROL';\n  category: string;\n  classification: 'PUBLIC' | 'INTERNAL' | 'CONFIDENTIAL' | 'RESTRICTED';\n  criticality: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  owner: string;\n  custodian: string;\n  location: string;\n  environment: 'DEVELOPMENT' | 'STAGING' | 'PRODUCTION';\n  dependencies: string[];\n  businessValue: number; // 1-10 scale\n  technicalValue: number; // 1-10 scale\n  riskScore: number;\n  lastAssessed: Date;\n  metadata: Record<string, any>;\n}\n\ninterface AssetDependency {\n  assetId: string;\n  dependsOn: string;\n  dependencyType: 'TECHNICAL' | 'BUSINESS' | 'DATA_FLOW' | 'SECURITY';\n  criticality: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  description: string;\n}\n\ninterface AssetRisk {\n  assetId: string;\n  riskId: string;\n  riskType: 'CONFIDENTIALITY' | 'INTEGRITY' | 'AVAILABILITY' | 'COMPLIANCE';\n  threat: string;\n  vulnerability: string;\n  impact: number; // 1-10 scale\n  likelihood: number; // 1-10 scale\n  riskScore: number; // impact * likelihood\n  mitigations: string[];\n  residualRisk: number;\n  status: 'IDENTIFIED' | 'ASSESSED' | 'MITIGATED' | 'ACCEPTED' | 'TRANSFERRED';\n}\n\n@Injectable()\nexport class AssetInventoryService {\n  private readonly logger = new Logger(AssetInventoryService.name);\n  private readonly assets = new Map<string, Asset>();\n  private readonly dependencies = new Map<string, AssetDependency[]>();\n  private readonly risks = new Map<string, AssetRisk[]>();\n\n  constructor(private configService: ConfigService) {}\n\n  async discoverAssets(): Promise<void> {\n    this.logger.log('Starting asset discovery process');\n\n    // Discover infrastructure assets\n    await this.discoverInfrastructureAssets();\n    \n    // Discover application assets\n    await this.discoverApplicationAssets();\n    \n    // Discover data assets\n    await this.discoverDataAssets();\n    \n    // Discover network assets\n    await this.discoverNetworkAssets();\n    \n    // Discover security controls\n    await this.discoverSecurityControls();\n\n    this.logger.log(`Asset discovery completed. Found ${this.assets.size} assets`);\n  }\n\n  async registerAsset(asset: Omit<Asset, 'id' | 'lastAssessed' | 'riskScore'>): Promise<string> {\n    const assetId = this.generateAssetId(asset.type, asset.name);\n    \n    const newAsset: Asset = {\n      ...asset,\n      id: assetId,\n      lastAssessed: new Date(),\n      riskScore: 0, // Will be calculated during risk assessment\n    };\n\n    this.assets.set(assetId, newAsset);\n    \n    // Perform initial risk assessment\n    await this.assessAssetRisk(assetId);\n\n    this.logger.log(`Asset registered: ${assetId}`);\n    return assetId;\n  }\n\n  async updateAsset(assetId: string, updates: Partial<Asset>): Promise<void> {\n    const asset = this.assets.get(assetId);\n    if (!asset) {\n      throw new Error(`Asset not found: ${assetId}`);\n    }\n\n    const updatedAsset = { ...asset, ...updates, lastAssessed: new Date() };\n    this.assets.set(assetId, updatedAsset);\n\n    // Re-assess risk if critical properties changed\n    if (this.shouldReassessRisk(updates)) {\n      await this.assessAssetRisk(assetId);\n    }\n\n    this.logger.log(`Asset updated: ${assetId}`);\n  }\n\n  async getAsset(assetId: string): Promise<Asset | undefined> {\n    return this.assets.get(assetId);\n  }\n\n  async getAssetsByType(type: string): Promise<Asset[]> {\n    return Array.from(this.assets.values()).filter(asset => asset.type === type);\n  }\n\n  async getAssetsByClassification(classification: string): Promise<Asset[]> {\n    return Array.from(this.assets.values()).filter(asset => asset.classification === classification);\n  }\n\n  async getAssetsByCriticality(criticality: string): Promise<Asset[]> {\n    return Array.from(this.assets.values()).filter(asset => asset.criticality === criticality);\n  }\n\n  async getCriticalAssets(): Promise<Asset[]> {\n    return Array.from(this.assets.values()).filter(asset => \n      asset.criticality === 'CRITICAL' || asset.businessValue >= 8 || asset.riskScore >= 7\n    );\n  }\n\n  async addDependency(dependency: AssetDependency): Promise<void> {\n    const assetDependencies = this.dependencies.get(dependency.assetId) || [];\n    assetDependencies.push(dependency);\n    this.dependencies.set(dependency.assetId, assetDependencies);\n\n    this.logger.log(`Dependency added: ${dependency.assetId} depends on ${dependency.dependsOn}`);\n  }\n\n  async getAssetDependencies(assetId: string): Promise<AssetDependency[]> {\n    return this.dependencies.get(assetId) || [];\n  }\n\n  async getAssetDependents(assetId: string): Promise<AssetDependency[]> {\n    const dependents: AssetDependency[] = [];\n    \n    for (const [_, deps] of this.dependencies) {\n      dependents.push(...deps.filter(dep => dep.dependsOn === assetId));\n    }\n    \n    return dependents;\n  }\n\n  async assessAssetRisk(assetId: string): Promise<void> {\n    const asset = this.assets.get(assetId);\n    if (!asset) {\n      throw new Error(`Asset not found: ${assetId}`);\n    }\n\n    // Identify risks for the asset\n    const risks = await this.identifyAssetRisks(asset);\n    this.risks.set(assetId, risks);\n\n    // Calculate overall risk score\n    const riskScore = this.calculateOverallRiskScore(risks);\n    asset.riskScore = riskScore;\n    \n    this.assets.set(assetId, asset);\n    this.logger.log(`Risk assessment completed for asset: ${assetId}, risk score: ${riskScore}`);\n  }\n\n  async getAssetRisks(assetId: string): Promise<AssetRisk[]> {\n    return this.risks.get(assetId) || [];\n  }\n\n  async generateAssetReport(): Promise<any> {\n    const allAssets = Array.from(this.assets.values());\n    \n    const report = {\n      timestamp: new Date(),\n      summary: {\n        totalAssets: allAssets.length,\n        byType: this.groupAssetsByProperty(allAssets, 'type'),\n        byClassification: this.groupAssetsByProperty(allAssets, 'classification'),\n        byCriticality: this.groupAssetsByProperty(allAssets, 'criticality'),\n        byEnvironment: this.groupAssetsByProperty(allAssets, 'environment'),\n      },\n      criticalAssets: await this.getCriticalAssets(),\n      highRiskAssets: allAssets.filter(asset => asset.riskScore >= 7),\n      complianceStatus: await this.generateComplianceStatus(),\n      recommendations: await this.generateRecommendations(),\n    };\n\n    return report;\n  }\n\n  private async discoverInfrastructureAssets(): Promise<void> {\n    // Discover GCP infrastructure assets\n    await this.discoverGCPAssets();\n    \n    // Discover Kubernetes assets\n    await this.discoverKubernetesAssets();\n    \n    // Discover container assets\n    await this.discoverContainerAssets();\n  }\n\n  private async discoverGCPAssets(): Promise<void> {\n    // Use Google Cloud Asset Inventory API\n    const gcpAssets = [\n      {\n        name: 'Production GKE Cluster',\n        type: 'INFRASTRUCTURE' as const,\n        category: 'Container Orchestration',\n        classification: 'CONFIDENTIAL' as const,\n        criticality: 'CRITICAL' as const,\n        owner: 'platform-team',\n        custodian: 'devops-team',\n        location: 'us-central1',\n        environment: 'PRODUCTION' as const,\n        dependencies: ['production-vpc', 'cloud-sql'],\n        businessValue: 10,\n        technicalValue: 10,\n        metadata: {\n          nodeCount: 5,\n          version: '1.27',\n          zones: ['us-central1-a', 'us-central1-b', 'us-central1-c'],\n        },\n      },\n      {\n        name: 'Production Cloud SQL',\n        type: 'INFRASTRUCTURE' as const,\n        category: 'Database',\n        classification: 'RESTRICTED' as const,\n        criticality: 'CRITICAL' as const,\n        owner: 'data-team',\n        custodian: 'dba-team',\n        location: 'us-central1',\n        environment: 'PRODUCTION' as const,\n        dependencies: ['production-vpc'],\n        businessValue: 10,\n        technicalValue: 9,\n        metadata: {\n          engine: 'PostgreSQL',\n          version: '14',\n          highAvailability: true,\n          backupEnabled: true,\n        },\n      },\n      // Add more GCP assets\n    ];\n\n    for (const asset of gcpAssets) {\n      await this.registerAsset(asset);\n    }\n  }\n\n  private async discoverKubernetesAssets(): Promise<void> {\n    // Discover Kubernetes resources\n    const k8sAssets = [\n      {\n        name: 'API Gateway Service',\n        type: 'APPLICATION' as const,\n        category: 'API Gateway',\n        classification: 'CONFIDENTIAL' as const,\n        criticality: 'HIGH' as const,\n        owner: 'api-team',\n        custodian: 'devops-team',\n        location: 'production-cluster',\n        environment: 'PRODUCTION' as const,\n        dependencies: ['backend-services', 'authentication-service'],\n        businessValue: 9,\n        technicalValue: 8,\n        metadata: {\n          namespace: 'production',\n          replicas: 3,\n          image: 'gcr.io/project/api-gateway:v1.2.3',\n        },\n      },\n      // Add more Kubernetes assets\n    ];\n\n    for (const asset of k8sAssets) {\n      await this.registerAsset(asset);\n    }\n  }\n\n  private async discoverApplicationAssets(): Promise<void> {\n    // Discover application components\n    const applicationAssets = [\n      {\n        name: 'User Authentication Service',\n        type: 'APPLICATION' as const,\n        category: 'Authentication',\n        classification: 'RESTRICTED' as const,\n        criticality: 'CRITICAL' as const,\n        owner: 'security-team',\n        custodian: 'backend-team',\n        location: 'production-cluster',\n        environment: 'PRODUCTION' as const,\n        dependencies: ['user-database', 'oauth-provider'],\n        businessValue: 10,\n        technicalValue: 9,\n        metadata: {\n          technology: 'NestJS',\n          version: '2.1.0',\n          features: ['JWT', 'OAuth', 'MFA'],\n        },\n      },\n      {\n        name: 'E-commerce Frontend',\n        type: 'APPLICATION' as const,\n        category: 'Web Application',\n        classification: 'INTERNAL' as const,\n        criticality: 'HIGH' as const,\n        owner: 'frontend-team',\n        custodian: 'frontend-team',\n        location: 'production-cluster',\n        environment: 'PRODUCTION' as const,\n        dependencies: ['api-gateway', 'cdn'],\n        businessValue: 9,\n        technicalValue: 7,\n        metadata: {\n          technology: 'Next.js',\n          version: '3.0.1',\n          features: ['SSR', 'PWA', 'SEO'],\n        },\n      },\n      // Add more application assets\n    ];\n\n    for (const asset of applicationAssets) {\n      await this.registerAsset(asset);\n    }\n  }\n\n  private async discoverDataAssets(): Promise<void> {\n    // Discover data assets\n    const dataAssets = [\n      {\n        name: 'Customer PII Database',\n        type: 'DATA' as const,\n        category: 'Personal Data',\n        classification: 'RESTRICTED' as const,\n        criticality: 'CRITICAL' as const,\n        owner: 'privacy-officer',\n        custodian: 'data-team',\n        location: 'cloud-sql-instance',\n        environment: 'PRODUCTION' as const,\n        dependencies: ['cloud-sql'],\n        businessValue: 10,\n        technicalValue: 8,\n        metadata: {\n          recordCount: 1000000,\n          retentionPeriod: '7 years',\n          complianceRequirements: ['GDPR', 'CCPA'],\n        },\n      },\n      {\n        name: 'Payment Transaction Logs',\n        type: 'DATA' as const,\n        category: 'Financial Data',\n        classification: 'RESTRICTED' as const,\n        criticality: 'CRITICAL' as const,\n        owner: 'finance-team',\n        custodian: 'security-team',\n        location: 'cloud-logging',\n        environment: 'PRODUCTION' as const,\n        dependencies: ['logging-service'],\n        businessValue: 9,\n        technicalValue: 7,\n        metadata: {\n          retentionPeriod: '10 years',\n          complianceRequirements: ['PCI-DSS', 'SOX'],\n        },\n      },\n      // Add more data assets\n    ];\n\n    for (const asset of dataAssets) {\n      await this.registerAsset(asset);\n    }\n  }\n\n  private async discoverNetworkAssets(): Promise<void> {\n    // Discover network assets\n    const networkAssets = [\n      {\n        name: 'Production VPC',\n        type: 'NETWORK' as const,\n        category: 'Virtual Network',\n        classification: 'CONFIDENTIAL' as const,\n        criticality: 'CRITICAL' as const,\n        owner: 'network-team',\n        custodian: 'devops-team',\n        location: 'us-central1',\n        environment: 'PRODUCTION' as const,\n        dependencies: [],\n        businessValue: 9,\n        technicalValue: 10,\n        metadata: {\n          cidrRange: '10.0.0.0/16',\n          subnets: 5,\n          firewallRules: 25,\n        },\n      },\n      // Add more network assets\n    ];\n\n    for (const asset of networkAssets) {\n      await this.registerAsset(asset);\n    }\n  }\n\n  private async discoverSecurityControls(): Promise<void> {\n    // Discover security control assets\n    const securityAssets = [\n      {\n        name: 'Google Cloud Armor',\n        type: 'SECURITY_CONTROL' as const,\n        category: 'WAF',\n        classification: 'INTERNAL' as const,\n        criticality: 'HIGH' as const,\n        owner: 'security-team',\n        custodian: 'security-team',\n        location: 'global',\n        environment: 'PRODUCTION' as const,\n        dependencies: ['load-balancer'],\n        businessValue: 8,\n        technicalValue: 8,\n        metadata: {\n          policies: 15,\n          rules: 50,\n          protection: ['DDoS', 'SQLi', 'XSS'],\n        },\n      },\n      // Add more security controls\n    ];\n\n    for (const asset of securityAssets) {\n      await this.registerAsset(asset);\n    }\n  }\n\n  private async discoverContainerAssets(): Promise<void> {\n    // Discover container images and their vulnerabilities\n    this.logger.log('Discovering container assets');\n  }\n\n  private async identifyAssetRisks(asset: Asset): Promise<AssetRisk[]> {\n    const risks: AssetRisk[] = [];\n\n    // Common risks based on asset type\n    switch (asset.type) {\n      case 'APPLICATION':\n        risks.push(...this.getApplicationRisks(asset));\n        break;\n      case 'DATA':\n        risks.push(...this.getDataRisks(asset));\n        break;\n      case 'INFRASTRUCTURE':\n        risks.push(...this.getInfrastructureRisks(asset));\n        break;\n      case 'NETWORK':\n        risks.push(...this.getNetworkRisks(asset));\n        break;\n    }\n\n    // Classification-based risks\n    if (asset.classification === 'RESTRICTED' || asset.classification === 'CONFIDENTIAL') {\n      risks.push(...this.getSensitiveDataRisks(asset));\n    }\n\n    // Environment-based risks\n    if (asset.environment === 'PRODUCTION') {\n      risks.push(...this.getProductionRisks(asset));\n    }\n\n    return risks;\n  }\n\n  private getApplicationRisks(asset: Asset): AssetRisk[] {\n    return [\n      {\n        assetId: asset.id,\n        riskId: `${asset.id}-app-001`,\n        riskType: 'CONFIDENTIALITY',\n        threat: 'Data breach through application vulnerability',\n        vulnerability: 'Unpatched security vulnerabilities',\n        impact: asset.businessValue,\n        likelihood: 5,\n        riskScore: asset.businessValue * 5,\n        mitigations: ['Security scanning', 'Regular updates', 'Penetration testing'],\n        residualRisk: 3,\n        status: 'IDENTIFIED',\n      },\n      {\n        assetId: asset.id,\n        riskId: `${asset.id}-app-002`,\n        riskType: 'AVAILABILITY',\n        threat: 'Service disruption',\n        vulnerability: 'Single point of failure',\n        impact: asset.businessValue,\n        likelihood: 3,\n        riskScore: asset.businessValue * 3,\n        mitigations: ['High availability', 'Load balancing', 'Auto-scaling'],\n        residualRisk: 2,\n        status: 'IDENTIFIED',\n      },\n    ];\n  }\n\n  private getDataRisks(asset: Asset): AssetRisk[] {\n    return [\n      {\n        assetId: asset.id,\n        riskId: `${asset.id}-data-001`,\n        riskType: 'CONFIDENTIALITY',\n        threat: 'Unauthorized data access',\n        vulnerability: 'Insufficient access controls',\n        impact: asset.businessValue,\n        likelihood: 4,\n        riskScore: asset.businessValue * 4,\n        mitigations: ['Encryption', 'Access controls', 'Audit logging'],\n        residualRisk: 2,\n        status: 'IDENTIFIED',\n      },\n    ];\n  }\n\n  private getInfrastructureRisks(asset: Asset): AssetRisk[] {\n    return [\n      {\n        assetId: asset.id,\n        riskId: `${asset.id}-infra-001`,\n        riskType: 'AVAILABILITY',\n        threat: 'Infrastructure failure',\n        vulnerability: 'Hardware/software failure',\n        impact: asset.businessValue,\n        likelihood: 3,\n        riskScore: asset.businessValue * 3,\n        mitigations: ['Redundancy', 'Monitoring', 'Backup systems'],\n        residualRisk: 2,\n        status: 'IDENTIFIED',\n      },\n    ];\n  }\n\n  private getNetworkRisks(asset: Asset): AssetRisk[] {\n    return [\n      {\n        assetId: asset.id,\n        riskId: `${asset.id}-network-001`,\n        riskType: 'CONFIDENTIALITY',\n        threat: 'Network intrusion',\n        vulnerability: 'Misconfigured firewall rules',\n        impact: asset.businessValue,\n        likelihood: 4,\n        riskScore: asset.businessValue * 4,\n        mitigations: ['Firewall configuration', 'Network monitoring', 'IDS/IPS'],\n        residualRisk: 2,\n        status: 'IDENTIFIED',\n      },\n    ];\n  }\n\n  private getSensitiveDataRisks(asset: Asset): AssetRisk[] {\n    return [\n      {\n        assetId: asset.id,\n        riskId: `${asset.id}-sensitive-001`,\n        riskType: 'COMPLIANCE',\n        threat: 'Regulatory violation',\n        vulnerability: 'Non-compliance with data protection regulations',\n        impact: 9,\n        likelihood: 3,\n        riskScore: 27,\n        mitigations: ['Compliance monitoring', 'Data governance', 'Regular audits'],\n        residualRisk: 2,\n        status: 'IDENTIFIED',\n      },\n    ];\n  }\n\n  private getProductionRisks(asset: Asset): AssetRisk[] {\n    return [\n      {\n        assetId: asset.id,\n        riskId: `${asset.id}-prod-001`,\n        riskType: 'AVAILABILITY',\n        threat: 'Business disruption',\n        vulnerability: 'Production system failure',\n        impact: asset.businessValue,\n        likelihood: 2,\n        riskScore: asset.businessValue * 2,\n        mitigations: ['DR planning', 'Monitoring', 'Incident response'],\n        residualRisk: 1,\n        status: 'IDENTIFIED',\n      },\n    ];\n  }\n\n  private calculateOverallRiskScore(risks: AssetRisk[]): number {\n    if (risks.length === 0) return 0;\n    \n    const totalRisk = risks.reduce((sum, risk) => sum + risk.riskScore, 0);\n    return Math.round(totalRisk / risks.length);\n  }\n\n  private shouldReassessRisk(updates: Partial<Asset>): boolean {\n    const criticalProperties = ['classification', 'criticality', 'environment', 'dependencies'];\n    return criticalProperties.some(prop => prop in updates);\n  }\n\n  private generateAssetId(type: string, name: string): string {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2, 8);\n    return `${type.toLowerCase()}-${name.toLowerCase().replace(/\\s+/g, '-')}-${timestamp}-${random}`;\n  }\n\n  private groupAssetsByProperty(assets: Asset[], property: keyof Asset): Record<string, number> {\n    const grouped: Record<string, number> = {};\n    \n    for (const asset of assets) {\n      const value = String(asset[property]);\n      grouped[value] = (grouped[value] || 0) + 1;\n    }\n    \n    return grouped;\n  }\n\n  private async generateComplianceStatus(): Promise<any> {\n    // Generate compliance status based on assets\n    return {\n      gdpr: { compliant: true, issues: 0 },\n      pciDss: { compliant: false, issues: 2 },\n      sox: { compliant: true, issues: 0 },\n    };\n  }\n\n  private async generateRecommendations(): Promise<string[]> {\n    const recommendations: string[] = [];\n    \n    const highRiskAssets = Array.from(this.assets.values()).filter(asset => asset.riskScore >= 7);\n    if (highRiskAssets.length > 0) {\n      recommendations.push(`Review and mitigate risks for ${highRiskAssets.length} high-risk assets`);\n    }\n    \n    const criticalAssets = await this.getCriticalAssets();\n    if (criticalAssets.length > 10) {\n      recommendations.push('Consider reducing the number of critical assets through consolidation');\n    }\n    \n    return recommendations;\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"asset-classification--valuation",children:"Asset Classification & Valuation"}),"\n",(0,i.jsx)(e.h3,{id:"asset-classification-service",children:"Asset Classification Service"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// src/asset-management/asset-classification.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\n\ninterface ClassificationCriteria {\n  confidentiality: 'PUBLIC' | 'INTERNAL' | 'CONFIDENTIAL' | 'RESTRICTED';\n  integrity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  availability: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  businessImpact: number; // 1-10 scale\n  regulatoryRequirements: string[];\n  retentionPeriod: number; // days\n}\n\ninterface ValuationCriteria {\n  replacementCost: number;\n  businessValue: number; // 1-10 scale\n  revenueImpact: number; // annual revenue impact\n  customerImpact: number; // number of customers affected\n  reputationImpact: number; // 1-10 scale\n  complianceImpact: number; // 1-10 scale\n}\n\n@Injectable()\nexport class AssetClassificationService {\n  private readonly logger = new Logger(AssetClassificationService.name);\n\n  async classifyAsset(asset: any): Promise<ClassificationCriteria> {\n    const classification: ClassificationCriteria = {\n      confidentiality: this.assessConfidentiality(asset),\n      integrity: this.assessIntegrity(asset),\n      availability: this.assessAvailability(asset),\n      businessImpact: this.assessBusinessImpact(asset),\n      regulatoryRequirements: this.identifyRegulatoryRequirements(asset),\n      retentionPeriod: this.determineRetentionPeriod(asset),\n    };\n\n    this.logger.log(`Asset classified: ${asset.id} - ${JSON.stringify(classification)}`);\n    return classification;\n  }\n\n  async valuateAsset(asset: any): Promise<ValuationCriteria> {\n    const valuation: ValuationCriteria = {\n      replacementCost: this.calculateReplacementCost(asset),\n      businessValue: this.calculateBusinessValue(asset),\n      revenueImpact: this.calculateRevenueImpact(asset),\n      customerImpact: this.calculateCustomerImpact(asset),\n      reputationImpact: this.calculateReputationImpact(asset),\n      complianceImpact: this.calculateComplianceImpact(asset),\n    };\n\n    this.logger.log(`Asset valuated: ${asset.id} - Total value: ${valuation.businessValue}`);\n    return valuation;\n  }\n\n  private assessConfidentiality(asset: any): 'PUBLIC' | 'INTERNAL' | 'CONFIDENTIAL' | 'RESTRICTED' {\n    // Assess confidentiality based on data sensitivity\n    if (asset.type === 'DATA') {\n      if (asset.category.includes('PII') || asset.category.includes('Personal')) {\n        return 'RESTRICTED';\n      }\n      if (asset.category.includes('Financial') || asset.category.includes('Payment')) {\n        return 'RESTRICTED';\n      }\n      if (asset.category.includes('Customer') || asset.category.includes('Business')) {\n        return 'CONFIDENTIAL';\n      }\n      if (asset.category.includes('Internal') || asset.category.includes('Operational')) {\n        return 'INTERNAL';\n      }\n    }\n\n    // Assess application confidentiality\n    if (asset.type === 'APPLICATION') {\n      if (asset.category.includes('Authentication') || asset.category.includes('Security')) {\n        return 'RESTRICTED';\n      }\n      if (asset.category.includes('Core') || asset.category.includes('Business')) {\n        return 'CONFIDENTIAL';\n      }\n    }\n\n    // Default assessment\n    return asset.environment === 'PRODUCTION' ? 'CONFIDENTIAL' : 'INTERNAL';\n  }\n\n  private assessIntegrity(asset: any): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {\n    if (asset.type === 'DATA') {\n      if (asset.category.includes('Financial') || asset.category.includes('Legal')) {\n        return 'CRITICAL';\n      }\n      if (asset.category.includes('Customer') || asset.category.includes('Business')) {\n        return 'HIGH';\n      }\n    }\n\n    if (asset.type === 'APPLICATION' && asset.criticality === 'CRITICAL') {\n      return 'CRITICAL';\n    }\n\n    return asset.businessValue >= 8 ? 'HIGH' : 'MEDIUM';\n  }\n\n  private assessAvailability(asset: any): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {\n    if (asset.environment === 'PRODUCTION') {\n      if (asset.criticality === 'CRITICAL' || asset.businessValue >= 9) {\n        return 'CRITICAL';\n      }\n      if (asset.businessValue >= 7) {\n        return 'HIGH';\n      }\n      return 'MEDIUM';\n    }\n\n    return 'LOW';\n  }\n\n  private assessBusinessImpact(asset: any): number {\n    let impact = asset.businessValue || 5;\n\n    // Adjust based on asset type\n    if (asset.type === 'DATA' && asset.classification === 'RESTRICTED') {\n      impact = Math.min(10, impact + 2);\n    }\n\n    if (asset.type === 'APPLICATION' && asset.environment === 'PRODUCTION') {\n      impact = Math.min(10, impact + 1);\n    }\n\n    return impact;\n  }\n\n  private identifyRegulatoryRequirements(asset: any): string[] {\n    const requirements: string[] = [];\n\n    // Data-specific requirements\n    if (asset.type === 'DATA') {\n      if (asset.category.includes('Personal') || asset.category.includes('PII')) {\n        requirements.push('GDPR', 'CCPA');\n      }\n      if (asset.category.includes('Financial') || asset.category.includes('Payment')) {\n        requirements.push('PCI-DSS', 'SOX');\n      }\n      if (asset.category.includes('Health')) {\n        requirements.push('HIPAA');\n      }\n    }\n\n    // Industry-specific requirements\n    if (asset.metadata?.industry === 'healthcare') {\n      requirements.push('HIPAA', 'HITECH');\n    }\n    if (asset.metadata?.industry === 'financial') {\n      requirements.push('SOX', 'GLBA', 'PCI-DSS');\n    }\n\n    return requirements;\n  }\n\n  private determineRetentionPeriod(asset: any): number {\n    // Default retention periods in days\n    const defaultRetention = {\n      'Personal Data': 2555, // 7 years\n      'Financial Data': 3650, // 10 years\n      'Legal Data': 3650, // 10 years\n      'Operational Data': 1095, // 3 years\n      'Log Data': 365, // 1 year\n    };\n\n    for (const [category, days] of Object.entries(defaultRetention)) {\n      if (asset.category.includes(category.split(' ')[0])) {\n        return days;\n      }\n    }\n\n    // Regulatory requirements\n    if (asset.metadata?.complianceRequirements?.includes('SOX')) {\n      return 3650; // 10 years\n    }\n    if (asset.metadata?.complianceRequirements?.includes('GDPR')) {\n      return 2555; // 7 years\n    }\n\n    return 1095; // Default 3 years\n  }\n\n  private calculateReplacementCost(asset: any): number {\n    // Estimate replacement cost based on asset type and complexity\n    const baseCosts = {\n      'APPLICATION': 100000, // $100k base for application development\n      'DATA': 50000, // $50k base for data recreation\n      'INFRASTRUCTURE': 200000, // $200k base for infrastructure\n      'NETWORK': 150000, // $150k base for network setup\n      'SECURITY_CONTROL': 75000, // $75k base for security controls\n    };\n\n    let cost = baseCosts[asset.type] || 50000;\n\n    // Adjust based on complexity and business value\n    cost = cost * (asset.businessValue / 5); // Scale by business value\n    cost = cost * (asset.technicalValue / 5); // Scale by technical complexity\n\n    return Math.round(cost);\n  }\n\n  private calculateBusinessValue(asset: any): number {\n    let value = asset.businessValue || 5;\n\n    // Adjust based on dependencies\n    if (asset.dependencies?.length > 5) {\n      value = Math.min(10, value + 1);\n    }\n\n    // Adjust based on environment\n    if (asset.environment === 'PRODUCTION') {\n      value = Math.min(10, value + 1);\n    }\n\n    return value;\n  }\n\n  private calculateRevenueImpact(asset: any): number {\n    // Estimate annual revenue impact if asset is unavailable\n    const baseImpact = {\n      'CRITICAL': 10000000, // $10M\n      'HIGH': 5000000, // $5M\n      'MEDIUM': 1000000, // $1M\n      'LOW': 100000, // $100k\n    };\n\n    return baseImpact[asset.criticality] || 100000;\n  }\n\n  private calculateCustomerImpact(asset: any): number {\n    // Estimate number of customers affected\n    const baseImpact = {\n      'CRITICAL': 1000000, // 1M customers\n      'HIGH': 500000, // 500k customers\n      'MEDIUM': 100000, // 100k customers\n      'LOW': 10000, // 10k customers\n    };\n\n    return baseImpact[asset.criticality] || 10000;\n  }\n\n  private calculateReputationImpact(asset: any): number {\n    // Reputation impact on 1-10 scale\n    if (asset.classification === 'RESTRICTED' && asset.type === 'DATA') {\n      return 9; // High reputation risk for sensitive data\n    }\n    if (asset.criticality === 'CRITICAL') {\n      return 7;\n    }\n    return asset.businessValue >= 8 ? 6 : 3;\n  }\n\n  private calculateComplianceImpact(asset: any): number {\n    // Compliance impact on 1-10 scale\n    const regulatoryRequirements = this.identifyRegulatoryRequirements(asset);\n    \n    if (regulatoryRequirements.length === 0) {\n      return 1;\n    }\n    \n    // Higher impact for more regulatory requirements\n    return Math.min(10, regulatoryRequirements.length * 2);\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"risk-assessment-framework",children:"Risk Assessment Framework"}),"\n",(0,i.jsx)(e.h3,{id:"risk-assessment-service",children:"Risk Assessment Service"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// src/asset-management/risk-assessment.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\n\ninterface RiskMatrix {\n  impact: number; // 1-5 scale\n  likelihood: number; // 1-5 scale\n  riskScore: number; // impact * likelihood\n  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n}\n\ninterface ThreatScenario {\n  id: string;\n  name: string;\n  description: string;\n  threatActor: string;\n  attackVector: string;\n  assetTypes: string[];\n  impact: number;\n  likelihood: number;\n  mitigations: string[];\n}\n\ninterface RiskAssessmentReport {\n  assessmentId: string;\n  timestamp: Date;\n  scope: string;\n  methodology: string;\n  assessor: string;\n  overallRiskScore: number;\n  riskDistribution: Record<string, number>;\n  topRisks: AssetRisk[];\n  recommendations: string[];\n  nextAssessmentDate: Date;\n}\n\n@Injectable()\nexport class RiskAssessmentService {\n  private readonly logger = new Logger(RiskAssessmentService.name);\n  private readonly threatScenarios = new Map<string, ThreatScenario>();\n  private readonly riskAssessments = new Map<string, RiskAssessmentReport>();\n\n  constructor() {\n    this.initializeThreatScenarios();\n  }\n\n  @Cron(CronExpression.EVERY_1ST_DAY_OF_MONTH_AT_MIDNIGHT)\n  async performMonthlyRiskAssessment(): Promise<void> {\n    this.logger.log('Starting monthly risk assessment');\n    \n    const assessmentId = await this.createRiskAssessment('Monthly Assessment', 'COMPREHENSIVE');\n    \n    this.logger.log(`Monthly risk assessment completed: ${assessmentId}`);\n  }\n\n  async createRiskAssessment(name: string, scope: 'COMPREHENSIVE' | 'TARGETED' | 'QUICK'): Promise<string> {\n    const assessmentId = this.generateAssessmentId();\n    \n    const assessment: RiskAssessmentReport = {\n      assessmentId,\n      timestamp: new Date(),\n      scope: name,\n      methodology: this.getMethodologyForScope(scope),\n      assessor: 'system',\n      overallRiskScore: 0,\n      riskDistribution: {},\n      topRisks: [],\n      recommendations: [],\n      nextAssessmentDate: this.calculateNextAssessmentDate(scope),\n    };\n\n    // Perform the assessment\n    await this.executeRiskAssessment(assessment);\n    \n    this.riskAssessments.set(assessmentId, assessment);\n    \n    this.logger.log(`Risk assessment created: ${assessmentId}`);\n    return assessmentId;\n  }\n\n  async assessThreatScenario(scenarioId: string, assetId: string): Promise<RiskMatrix> {\n    const scenario = this.threatScenarios.get(scenarioId);\n    if (!scenario) {\n      throw new Error(`Threat scenario not found: ${scenarioId}`);\n    }\n\n    // Calculate risk matrix for the specific asset and threat scenario\n    const riskMatrix = this.calculateRiskMatrix(scenario, assetId);\n    \n    this.logger.log(`Threat scenario assessed: ${scenarioId} for asset ${assetId}, risk level: ${riskMatrix.riskLevel}`);\n    return riskMatrix;\n  }\n\n  async calculateResidualRisk(assetId: string, mitigations: string[]): Promise<number> {\n    // Get current risk score\n    const currentRisk = await this.getCurrentRiskScore(assetId);\n    \n    // Calculate mitigation effectiveness\n    const mitigationEffectiveness = this.calculateMitigationEffectiveness(mitigations);\n    \n    // Calculate residual risk\n    const residualRisk = Math.max(1, currentRisk * (1 - mitigationEffectiveness));\n    \n    this.logger.log(`Residual risk calculated for ${assetId}: ${residualRisk}`);\n    return residualRisk;\n  }\n\n  async generateRiskHeatmap(): Promise<any> {\n    // Generate risk heatmap data\n    const heatmapData = [];\n    \n    for (let impact = 1; impact <= 5; impact++) {\n      for (let likelihood = 1; likelihood <= 5; likelihood++) {\n        const riskScore = impact * likelihood;\n        const riskLevel = this.getRiskLevel(riskScore);\n        \n        heatmapData.push({\n          impact,\n          likelihood,\n          riskScore,\n          riskLevel,\n          assetCount: await this.getAssetCountForRisk(riskScore),\n        });\n      }\n    }\n    \n    return heatmapData;\n  }\n\n  async getRiskTrends(timeframe: 'WEEK' | 'MONTH' | 'QUARTER'): Promise<any[]> {\n    // Get risk trends over time\n    const trends = [];\n    const assessments = Array.from(this.riskAssessments.values())\n      .filter(assessment => this.isWithinTimeframe(assessment.timestamp, timeframe))\n      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n\n    for (const assessment of assessments) {\n      trends.push({\n        date: assessment.timestamp,\n        overallRisk: assessment.overallRiskScore,\n        highRiskAssets: assessment.topRisks.filter(risk => risk.riskScore >= 15).length,\n        criticalRiskAssets: assessment.topRisks.filter(risk => risk.riskScore >= 20).length,\n      });\n    }\n    \n    return trends;\n  }\n\n  private async executeRiskAssessment(assessment: RiskAssessmentReport): Promise<void> {\n    // Collect all asset risks\n    const allRisks: AssetRisk[] = [];\n    \n    // Calculate overall risk metrics\n    assessment.overallRiskScore = this.calculateOverallRiskScore(allRisks);\n    assessment.riskDistribution = this.calculateRiskDistribution(allRisks);\n    assessment.topRisks = this.getTopRisks(allRisks);\n    assessment.recommendations = await this.generateRiskRecommendations(allRisks);\n  }\n\n  private calculateRiskMatrix(scenario: ThreatScenario, assetId: string): RiskMatrix {\n    // Get asset-specific factors\n    const assetMultiplier = this.getAssetRiskMultiplier(assetId);\n    \n    // Calculate adjusted impact and likelihood\n    const adjustedImpact = Math.min(5, Math.round(scenario.impact * assetMultiplier));\n    const adjustedLikelihood = Math.min(5, scenario.likelihood);\n    \n    const riskScore = adjustedImpact * adjustedLikelihood;\n    const riskLevel = this.getRiskLevel(riskScore);\n    \n    return {\n      impact: adjustedImpact,\n      likelihood: adjustedLikelihood,\n      riskScore,\n      riskLevel,\n    };\n  }\n\n  private getRiskLevel(riskScore: number): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {\n    if (riskScore >= 20) return 'CRITICAL';\n    if (riskScore >= 15) return 'HIGH';\n    if (riskScore >= 8) return 'MEDIUM';\n    return 'LOW';\n  }\n\n  private getAssetRiskMultiplier(assetId: string): number {\n    // This would integrate with AssetInventoryService\n    // For now, return default multiplier\n    return 1.0;\n  }\n\n  private async getCurrentRiskScore(assetId: string): Promise<number> {\n    // This would integrate with AssetInventoryService\n    // For now, return default risk score\n    return 10;\n  }\n\n  private calculateMitigationEffectiveness(mitigations: string[]): number {\n    // Calculate overall effectiveness of mitigations (0-1 scale)\n    const mitigationValues = {\n      'Encryption': 0.7,\n      'Access Controls': 0.6,\n      'Monitoring': 0.4,\n      'Backup': 0.5,\n      'Redundancy': 0.8,\n      'Patching': 0.6,\n      'Training': 0.3,\n      'Incident Response': 0.4,\n    };\n\n    let totalEffectiveness = 0;\n    let count = 0;\n\n    for (const mitigation of mitigations) {\n      for (const [key, value] of Object.entries(mitigationValues)) {\n        if (mitigation.includes(key)) {\n          totalEffectiveness += value;\n          count++;\n          break;\n        }\n      }\n    }\n\n    return count > 0 ? Math.min(0.9, totalEffectiveness / count) : 0;\n  }\n\n  private calculateOverallRiskScore(risks: AssetRisk[]): number {\n    if (risks.length === 0) return 0;\n    \n    const totalRisk = risks.reduce((sum, risk) => sum + risk.riskScore, 0);\n    return Math.round(totalRisk / risks.length);\n  }\n\n  private calculateRiskDistribution(risks: AssetRisk[]): Record<string, number> {\n    const distribution = { LOW: 0, MEDIUM: 0, HIGH: 0, CRITICAL: 0 };\n    \n    for (const risk of risks) {\n      const level = this.getRiskLevel(risk.riskScore);\n      distribution[level]++;\n    }\n    \n    return distribution;\n  }\n\n  private getTopRisks(risks: AssetRisk[]): AssetRisk[] {\n    return risks\n      .sort((a, b) => b.riskScore - a.riskScore)\n      .slice(0, 10);\n  }\n\n  private async generateRiskRecommendations(risks: AssetRisk[]): Promise<string[]> {\n    const recommendations: string[] = [];\n    \n    const criticalRisks = risks.filter(risk => this.getRiskLevel(risk.riskScore) === 'CRITICAL');\n    if (criticalRisks.length > 0) {\n      recommendations.push(`Address ${criticalRisks.length} critical risks immediately`);\n    }\n    \n    const highRisks = risks.filter(risk => this.getRiskLevel(risk.riskScore) === 'HIGH');\n    if (highRisks.length > 5) {\n      recommendations.push(`Prioritize mitigation of ${highRisks.length} high risks`);\n    }\n    \n    return recommendations;\n  }\n\n  private getMethodologyForScope(scope: string): string {\n    const methodologies = {\n      'COMPREHENSIVE': 'ISO 27005 Risk Management',\n      'TARGETED': 'NIST SP 800-30 Risk Assessment',\n      'QUICK': 'Simplified Risk Assessment',\n    };\n    \n    return methodologies[scope] || 'Standard Risk Assessment';\n  }\n\n  private calculateNextAssessmentDate(scope: string): Date {\n    const intervals = {\n      'COMPREHENSIVE': 365, // Annual\n      'TARGETED': 180, // Semi-annual\n      'QUICK': 90, // Quarterly\n    };\n    \n    const days = intervals[scope] || 365;\n    const nextDate = new Date();\n    nextDate.setDate(nextDate.getDate() + days);\n    \n    return nextDate;\n  }\n\n  private async getAssetCountForRisk(riskScore: number): Promise<number> {\n    // This would query the asset inventory\n    // For now, return mock data\n    return Math.floor(Math.random() * 20);\n  }\n\n  private isWithinTimeframe(date: Date, timeframe: string): boolean {\n    const now = new Date();\n    const diffDays = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));\n    \n    const limits = {\n      'WEEK': 7,\n      'MONTH': 30,\n      'QUARTER': 90,\n    };\n    \n    return diffDays <= (limits[timeframe] || 365);\n  }\n\n  private generateAssessmentId(): string {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2, 8);\n    return `RISK-${timestamp}-${random}`.toUpperCase();\n  }\n\n  private initializeThreatScenarios(): void {\n    const scenarios: ThreatScenario[] = [\n      {\n        id: 'T001',\n        name: 'Data Breach via Application Vulnerability',\n        description: 'Attacker exploits application vulnerability to access sensitive data',\n        threatActor: 'External Hacker',\n        attackVector: 'Web Application',\n        assetTypes: ['APPLICATION', 'DATA'],\n        impact: 5,\n        likelihood: 3,\n        mitigations: ['Security scanning', 'Input validation', 'Access controls'],\n      },\n      {\n        id: 'T002',\n        name: 'Insider Threat - Data Exfiltration',\n        description: 'Malicious insider accesses and exfiltrates sensitive data',\n        threatActor: 'Malicious Insider',\n        attackVector: 'Privileged Access',\n        assetTypes: ['DATA', 'APPLICATION'],\n        impact: 4,\n        likelihood: 2,\n        mitigations: ['Access monitoring', 'Data loss prevention', 'Background checks'],\n      },\n      {\n        id: 'T003',\n        name: 'Infrastructure Failure',\n        description: 'Critical infrastructure component fails causing service disruption',\n        threatActor: 'Natural Disaster/Technical Failure',\n        attackVector: 'Physical/Technical',\n        assetTypes: ['INFRASTRUCTURE', 'NETWORK'],\n        impact: 4,\n        likelihood: 3,\n        mitigations: ['Redundancy', 'Backup systems', 'Disaster recovery'],\n      },\n      {\n        id: 'T004',\n        name: 'Supply Chain Attack',\n        description: 'Attacker compromises software supply chain to inject malicious code',\n        threatActor: 'Nation State/APT',\n        attackVector: 'Software Supply Chain',\n        assetTypes: ['APPLICATION', 'INFRASTRUCTURE'],\n        impact: 5,\n        likelihood: 2,\n        mitigations: ['Code signing', 'Dependency scanning', 'Vendor assessment'],\n      },\n      {\n        id: 'T005',\n        name: 'DDoS Attack',\n        description: 'Distributed denial of service attack overwhelms infrastructure',\n        threatActor: 'Cybercriminals',\n        attackVector: 'Network',\n        assetTypes: ['INFRASTRUCTURE', 'NETWORK', 'APPLICATION'],\n        impact: 3,\n        likelihood: 4,\n        mitigations: ['DDoS protection', 'Rate limiting', 'Load balancing'],\n      },\n    ];\n\n    scenarios.forEach(scenario => {\n      this.threatScenarios.set(scenario.id, scenario);\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"This comprehensive Asset Management & Risk Assessment implementation provides:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Asset Discovery & Inventory"})," with automated discovery of infrastructure, applications, data, network, and security control assets"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Asset Classification & Valuation"})," with confidentiality, integrity, availability assessment and business value calculation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Risk Assessment Framework"})," with threat scenario modeling, risk matrix calculation, and residual risk assessment"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Threat Modeling"})," with STRIDE methodology and attack vector analysis"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Risk Monitoring & Reporting"})," with automated assessments, risk heatmaps, and trend analysis"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Compliance & Governance"})," with regulatory requirement mapping and compliance status tracking"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"The implementation ensures comprehensive visibility and risk management for all organizational assets in the NestJS/Next.js application ecosystem."}),"\n",(0,i.jsx)(e.h2,{id:"threat-modeling",children:"Threat Modeling"}),"\n",(0,i.jsx)(e.h3,{id:"stride-threat-analysis",children:"STRIDE Threat Analysis"}),"\n",(0,i.jsx)(e.p,{children:"The threat modeling process uses the STRIDE methodology to systematically identify threats across the asset landscape:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Spoofing"}),": Identity verification and authentication threats"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Tampering"}),": Data integrity and unauthorized modification threats"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Repudiation"}),": Non-repudiation and audit trail threats"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Information Disclosure"}),": Confidentiality and data leakage threats"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Denial of Service"}),": Availability and service disruption threats"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Elevation of Privilege"}),": Authorization and access control threats"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"attack-vector-analysis",children:"Attack Vector Analysis"}),"\n",(0,i.jsx)(e.p,{children:"Comprehensive analysis of potential attack vectors across the infrastructure:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"External Attack Vectors"}),": Internet-facing services, API endpoints, web applications"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Internal Attack Vectors"}),": Insider threats, lateral movement, privilege escalation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Supply Chain Attack Vectors"}),": Third-party dependencies, vendor services, container images"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Physical Attack Vectors"}),": Data center access, hardware tampering, device theft"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"risk-monitoring--reporting",children:"Risk Monitoring & Reporting"}),"\n",(0,i.jsx)(e.h3,{id:"continuous-risk-assessment",children:"Continuous Risk Assessment"}),"\n",(0,i.jsx)(e.p,{children:"Automated risk monitoring and assessment processes provide real-time visibility into the organization's security posture:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Real-time Threat Detection"}),": Continuous monitoring for security threats and vulnerabilities"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Risk Score Trending"}),": Historical analysis of risk scores and improvement tracking"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Asset Health Monitoring"}),": Continuous assessment of asset security status"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Compliance Monitoring"}),": Automated compliance checking and reporting"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"risk-reporting-framework",children:"Risk Reporting Framework"}),"\n",(0,i.jsx)(e.p,{children:"Comprehensive reporting framework provides stakeholders with actionable risk insights:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Executive Dashboards"}),": High-level risk metrics and trends for leadership"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Technical Reports"}),": Detailed technical analysis for security teams"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Compliance Reports"}),": Regulatory compliance status and gap analysis"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Incident Reports"}),": Security incident analysis and lessons learned"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"compliance--governance",children:"Compliance & Governance"}),"\n",(0,i.jsx)(e.h3,{id:"regulatory-compliance-management",children:"Regulatory Compliance Management"}),"\n",(0,i.jsx)(e.p,{children:"Comprehensive compliance management ensures adherence to relevant regulations and standards:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"GDPR Compliance"}),": Data protection and privacy requirements"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"PCI DSS Compliance"}),": Payment card industry security standards"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"SOX Compliance"}),": Financial reporting and internal controls"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"ISO 27001"}),": Information security management systems"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"governance-framework",children:"Governance Framework"}),"\n",(0,i.jsx)(e.p,{children:"Robust governance framework ensures effective oversight and management of security risks:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Risk Governance Structure"}),": Clear roles and responsibilities for risk management"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Policy Management"}),": Comprehensive security policies and procedures"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Control Framework"}),": Systematic implementation and monitoring of security controls"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Audit and Review"}),": Regular audits and reviews of security posture"]}),"\n"]})]})}function u(s={}){const{wrapper:e}={...(0,a.R)(),...s.components};return e?(0,i.jsx)(e,{...s,children:(0,i.jsx)(d,{...s})}):d(s)}},7814:(s,e,n)=>{n.d(e,{R:()=>r,x:()=>o});var t=n(9729);const i={},a=t.createContext(i);function r(s){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof s?s(e):{...e,...s}},[e,s])}function o(s){let e;return e=s.disableParentContext?"function"==typeof s.components?s.components(i):s.components||i:r(s.components),t.createElement(a.Provider,{value:e},s.children)}}}]);