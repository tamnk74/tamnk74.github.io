"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[799],{7814:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(9729);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}},9452:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"architecture-practices/architecture-definition/architecture-foundation","title":"Architecture Foundation","description":"This guide establishes the foundational architecture patterns and mechanisms for NestJS microservices and Next.js microfrontend applications.","source":"@site/docs/architecture-practices/architecture-definition/architecture-foundation.md","sourceDirName":"architecture-practices/architecture-definition","slug":"/architecture-practices/architecture-definition/architecture-foundation","permalink":"/fullstack-dev/docs/architecture-practices/architecture-definition/architecture-foundation","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-definition/architecture-foundation.md","tags":[],"version":"current","frontMatter":{}}');var i=r(5813),s=r(7814);const a={},o="Architecture Foundation",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Core Architecture Patterns",id:"core-architecture-patterns",level:2},{value:"Microservices Architecture (NestJS)",id:"microservices-architecture-nestjs",level:3},{value:"Service Architecture Layers",id:"service-architecture-layers",level:4},{value:"Service Communication Patterns",id:"service-communication-patterns",level:4},{value:"Microfrontend Architecture (Next.js)",id:"microfrontend-architecture-nextjs",level:3},{value:"Application Architecture",id:"application-architecture",level:4},{value:"Component Architecture",id:"component-architecture",level:4},{value:"Key Mechanisms",id:"key-mechanisms",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Global Exception Handling (NestJS)",id:"global-exception-handling-nestjs",level:4},{value:"Error Boundary (Next.js)",id:"error-boundary-nextjs",level:4},{value:"Logging Architecture",id:"logging-architecture",level:3},{value:"Structured Logging (NestJS)",id:"structured-logging-nestjs",level:4},{value:"Client-side Logging (Next.js)",id:"client-side-logging-nextjs",level:4},{value:"Transaction Control",id:"transaction-control",level:3},{value:"Database Transactions (NestJS)",id:"database-transactions-nestjs",level:4},{value:"Distributed Transactions (Saga Pattern)",id:"distributed-transactions-saga-pattern",level:4},{value:"Security Architecture",id:"security-architecture",level:2},{value:"Authentication &amp; Authorization",id:"authentication--authorization",level:3},{value:"Data Protection",id:"data-protection",level:3},{value:"Performance Architecture",id:"performance-architecture",level:2},{value:"Caching Strategy",id:"caching-strategy",level:3},{value:"Database Optimization",id:"database-optimization",level:3},{value:"Monitoring &amp; Observability",id:"monitoring--observability",level:2},{value:"Health Checks",id:"health-checks",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Architecture Guidelines",id:"architecture-guidelines",level:3},{value:"Implementation Standards",id:"implementation-standards",level:3},{value:"Documentation Requirements",id:"documentation-requirements",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"architecture-foundation",children:"Architecture Foundation"})}),"\n",(0,i.jsx)(n.p,{children:"This guide establishes the foundational architecture patterns and mechanisms for NestJS microservices and Next.js microfrontend applications."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Architecture foundation defines the core layers, frameworks, patterns, and key mechanisms that form the backbone of a distributed system. This documentation ensures consistent architectural patterns across all services and applications."}),"\n",(0,i.jsx)(n.h2,{id:"core-architecture-patterns",children:"Core Architecture Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"microservices-architecture-nestjs",children:"Microservices Architecture (NestJS)"}),"\n",(0,i.jsx)(n.h4,{id:"service-architecture-layers",children:"Service Architecture Layers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/architecture/layers.ts\nexport enum ArchitectureLayer {\n  PRESENTATION = 'presentation',    // Controllers, DTOs, Validation\n  APPLICATION = 'application',      // Use Cases, Business Logic\n  DOMAIN = 'domain',               // Entities, Domain Services\n  INFRASTRUCTURE = 'infrastructure' // Repositories, External Services\n}\n\n// Layered Architecture Implementation\n@Injectable()\nexport class LayeredArchitectureService {\n  // Presentation Layer - Controllers\n  async handleRequest(dto: CreateUserDto): Promise<UserResponseDto> {\n    // Input validation and transformation\n    const command = this.mapToCommand(dto);\n    \n    // Delegate to application layer\n    const result = await this.userApplicationService.createUser(command);\n    \n    // Transform to response DTO\n    return this.mapToResponse(result);\n  }\n  \n  // Application Layer - Use Cases\n  async createUser(command: CreateUserCommand): Promise<User> {\n    // Business logic orchestration\n    const user = await this.userDomainService.createUser(command);\n    await this.notificationService.sendWelcomeEmail(user);\n    \n    return user;\n  }\n  \n  // Domain Layer - Business Logic\n  createUser(userData: UserData): User {\n    // Domain validation and business rules\n    if (!this.isValidEmail(userData.email)) {\n      throw new DomainException('Invalid email format');\n    }\n    \n    return new User(userData);\n  }\n  \n  // Infrastructure Layer - Data Access\n  async saveUser(user: User): Promise<void> {\n    const entity = this.userMapper.toEntity(user);\n    await this.userRepository.save(entity);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"service-communication-patterns",children:"Service Communication Patterns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Synchronous Communication:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/communication/http-client.service.ts\n@Injectable()\nexport class HttpClientService {\n  private readonly httpService: HttpService;\n  \n  constructor(httpService: HttpService) {\n    this.httpService = httpService;\n  }\n  \n  async callUserService(userId: string): Promise<UserData> {\n    try {\n      const response = await this.httpService.axiosRef.get(\n        `${process.env.USER_SERVICE_URL}/users/${userId}`,\n        {\n          timeout: 5000,\n          headers: {\n            'Authorization': `Bearer ${this.getServiceToken()}`,\n            'X-Request-ID': this.generateRequestId(),\n          },\n        }\n      );\n      \n      return response.data;\n    } catch (error) {\n      throw new ServiceCommunicationException(\n        `Failed to call user service: ${error.message}`\n      );\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Asynchronous Communication:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/communication/message-broker.service.ts\n@Injectable()\nexport class MessageBrokerService {\n  constructor(\n    @Inject('RABBITMQ_SERVICE') private readonly client: ClientProxy\n  ) {}\n  \n  async publishEvent(event: DomainEvent): Promise<void> {\n    try {\n      await this.client.emit(event.eventType, {\n        eventId: event.id,\n        aggregateId: event.aggregateId,\n        data: event.data,\n        timestamp: new Date(),\n        version: event.version,\n      });\n    } catch (error) {\n      throw new EventPublishingException(\n        `Failed to publish event: ${error.message}`\n      );\n    }\n  }\n  \n  @EventPattern('user.created')\n  async handleUserCreated(data: UserCreatedEvent): Promise<void> {\n    // Handle the event asynchronously\n    await this.userProfileService.createProfile(data.userId);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"microfrontend-architecture-nextjs",children:"Microfrontend Architecture (Next.js)"}),"\n",(0,i.jsx)(n.h4,{id:"application-architecture",children:"Application Architecture"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// lib/architecture/micro-frontend-shell.ts\nexport class MicrofrontendShell {\n  private remotes: Map<string, RemoteModule> = new Map();\n  private eventBus: EventBus = new EventBus();\n  \n  async loadRemote(name: string, url: string): Promise<RemoteModule> {\n    try {\n      const module = await import(/* webpackIgnore: true */ url);\n      this.remotes.set(name, module);\n      \n      // Initialize remote with shared services\n      if (module.initialize) {\n        await module.initialize({\n          eventBus: this.eventBus,\n          authService: this.authService,\n          themeProvider: this.themeProvider,\n        });\n      }\n      \n      return module;\n    } catch (error) {\n      throw new MicrofrontendLoadException(\n        `Failed to load microfrontend ${name}: ${error.message}`\n      );\n    }\n  }\n  \n  render(remoteName: string, props: any): React.ReactElement {\n    const remote = this.remotes.get(remoteName);\n    if (!remote) {\n      return <MicrofrontendErrorBoundary remoteName={remoteName} />;\n    }\n    \n    return (\n      <ErrorBoundary>\n        <remote.Component {...props} />\n      </ErrorBoundary>\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"component-architecture",children:"Component Architecture"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// components/architecture/base-component.tsx\nexport interface BaseComponentProps {\n  className?: string;\n  testId?: string;\n  children?: React.ReactNode;\n}\n\nexport abstract class BaseComponent<T extends BaseComponentProps> extends React.Component<T> {\n  protected logger: Logger;\n  \n  constructor(props: T) {\n    super(props);\n    this.logger = new Logger(this.constructor.name);\n  }\n  \n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n    this.logger.error('Component error:', error, errorInfo);\n    // Send to error tracking service\n    ErrorTrackingService.captureException(error, {\n      component: this.constructor.name,\n      props: this.props,\n      errorInfo,\n    });\n  }\n  \n  protected renderErrorState(error: Error): React.ReactElement {\n    return (\n      <div className=\"error-state\" data-testid={`${this.props.testId}-error`}>\n        <h3>Something went wrong</h3>\n        {process.env.NODE_ENV === 'development' && (\n          <pre>{error.message}</pre>\n        )}\n      </div>\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"key-mechanisms",children:"Key Mechanisms"}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.h4,{id:"global-exception-handling-nestjs",children:"Global Exception Handling (NestJS)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/common/filters/global-exception.filter.ts\n@Catch()\nexport class GlobalExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(GlobalExceptionFilter.name);\n  \n  catch(exception: unknown, host: ArgumentsHost): void {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n    \n    let status: number;\n    let message: string;\n    let code: string;\n    \n    if (exception instanceof HttpException) {\n      status = exception.getStatus();\n      const exceptionResponse = exception.getResponse();\n      message = typeof exceptionResponse === 'string' \n        ? exceptionResponse \n        : (exceptionResponse as any).message;\n      code = exception.constructor.name;\n    } else if (exception instanceof DomainException) {\n      status = 400;\n      message = exception.message;\n      code = exception.code;\n    } else {\n      status = 500;\n      message = 'Internal server error';\n      code = 'INTERNAL_ERROR';\n    }\n    \n    const errorResponse = {\n      statusCode: status,\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      method: request.method,\n      message,\n      code,\n      requestId: request.headers['x-request-id'],\n    };\n    \n    this.logger.error(\n      `${request.method} ${request.url}`,\n      exception instanceof Error ? exception.stack : exception,\n      {\n        ...errorResponse,\n        userId: request.user?.id,\n      }\n    );\n    \n    response.status(status).json(errorResponse);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"error-boundary-nextjs",children:"Error Boundary (Next.js)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// components/common/error-boundary.tsx\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error?: Error;\n  errorInfo?: React.ErrorInfo;\n}\n\nexport class ErrorBoundary extends React.Component<\n  React.PropsWithChildren<{ fallback?: React.ComponentType<any> }>,\n  ErrorBoundaryState\n> {\n  constructor(props: React.PropsWithChildren<{}>) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  \n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n  \n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    this.setState({ error, errorInfo });\n    \n    // Log to monitoring service\n    ErrorTrackingService.captureException(error, {\n      tags: { boundary: 'global' },\n      extra: { errorInfo },\n    });\n    \n    // Report to analytics\n    Analytics.track('error_boundary_triggered', {\n      error: error.message,\n      stack: error.stack,\n      componentStack: errorInfo.componentStack,\n    });\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      const FallbackComponent = this.props.fallback || DefaultErrorFallback;\n      \n      return (\n        <FallbackComponent\n          error={this.state.error}\n          resetError={() => this.setState({ hasError: false })}\n        />\n      );\n    }\n    \n    return this.props.children;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"logging-architecture",children:"Logging Architecture"}),"\n",(0,i.jsx)(n.h4,{id:"structured-logging-nestjs",children:"Structured Logging (NestJS)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/common/logging/logger.service.ts\n@Injectable()\nexport class LoggerService {\n  private readonly winston: winston.Logger;\n  \n  constructor() {\n    this.winston = winston.createLogger({\n      level: process.env.LOG_LEVEL || 'info',\n      format: winston.format.combine(\n        winston.format.timestamp(),\n        winston.format.errors({ stack: true }),\n        winston.format.json(),\n        winston.format.printf(({ timestamp, level, message, service, requestId, userId, ...meta }) => {\n          return JSON.stringify({\n            timestamp,\n            level,\n            message,\n            service: process.env.SERVICE_NAME || 'unknown',\n            requestId,\n            userId,\n            ...meta,\n          });\n        })\n      ),\n      transports: [\n        new winston.transports.Console(),\n        new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),\n        new winston.transports.File({ filename: 'logs/combined.log' }),\n      ],\n    });\n  }\n  \n  log(message: string, context?: string, meta?: object): void {\n    this.winston.info(message, { context, ...meta });\n  }\n  \n  error(message: string, trace?: string, context?: string, meta?: object): void {\n    this.winston.error(message, { trace, context, ...meta });\n  }\n  \n  warn(message: string, context?: string, meta?: object): void {\n    this.winston.warn(message, { context, ...meta });\n  }\n  \n  debug(message: string, context?: string, meta?: object): void {\n    this.winston.debug(message, { context, ...meta });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"client-side-logging-nextjs",children:"Client-side Logging (Next.js)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// lib/logging/client-logger.ts\nexport class ClientLogger {\n  private static instance: ClientLogger;\n  private buffer: LogEntry[] = [];\n  private flushInterval: NodeJS.Timeout;\n  \n  private constructor() {\n    this.flushInterval = setInterval(() => this.flush(), 5000);\n  }\n  \n  static getInstance(): ClientLogger {\n    if (!ClientLogger.instance) {\n      ClientLogger.instance = new ClientLogger();\n    }\n    return ClientLogger.instance;\n  }\n  \n  log(level: LogLevel, message: string, meta?: object): void {\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      url: window.location.href,\n      userAgent: navigator.userAgent,\n      sessionId: this.getSessionId(),\n      userId: this.getUserId(),\n      ...meta,\n    };\n    \n    this.buffer.push(entry);\n    \n    // Immediate flush for errors\n    if (level === 'error') {\n      this.flush();\n    }\n  }\n  \n  private async flush(): Promise<void> {\n    if (this.buffer.length === 0) return;\n    \n    const logs = [...this.buffer];\n    this.buffer = [];\n    \n    try {\n      await fetch('/api/logs', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ logs }),\n      });\n    } catch (error) {\n      // Re-add logs to buffer on failure\n      this.buffer.unshift(...logs);\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"transaction-control",children:"Transaction Control"}),"\n",(0,i.jsx)(n.h4,{id:"database-transactions-nestjs",children:"Database Transactions (NestJS)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/common/decorators/transactional.decorator.ts\nexport function Transactional(): MethodDecorator {\n  return function (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = async function (...args: any[]) {\n      const dataSource = getDataSource();\n      const queryRunner = dataSource.createQueryRunner();\n      \n      await queryRunner.connect();\n      await queryRunner.startTransaction();\n      \n      try {\n        // Set the query runner in the context\n        setQueryRunner(queryRunner);\n        \n        const result = await originalMethod.apply(this, args);\n        \n        await queryRunner.commitTransaction();\n        return result;\n      } catch (error) {\n        await queryRunner.rollbackTransaction();\n        throw error;\n      } finally {\n        await queryRunner.release();\n        clearQueryRunner();\n      }\n    };\n  };\n}\n\n// Usage example\n@Injectable()\nexport class UserService {\n  @Transactional()\n  async createUserWithProfile(userData: CreateUserData): Promise<User> {\n    const user = await this.userRepository.save(userData);\n    await this.profileRepository.save({ userId: user.id, ...userData.profile });\n    await this.auditRepository.save({ action: 'USER_CREATED', userId: user.id });\n    \n    return user;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"distributed-transactions-saga-pattern",children:"Distributed Transactions (Saga Pattern)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/sagas/user-registration.saga.ts\n@Injectable()\nexport class UserRegistrationSaga {\n  constructor(\n    private readonly userService: UserService,\n    private readonly emailService: EmailService,\n    private readonly paymentService: PaymentService,\n    private readonly eventBus: EventBus,\n  ) {}\n  \n  @SagaStart()\n  async handle(command: RegisterUserCommand): Promise<void> {\n    const sagaId = uuid();\n    \n    try {\n      // Step 1: Create user account\n      const user = await this.userService.createUser(command.userData);\n      \n      // Step 2: Send welcome email\n      await this.emailService.sendWelcomeEmail(user.email);\n      \n      // Step 3: Set up billing (if premium user)\n      if (command.planType === 'premium') {\n        await this.paymentService.setupBilling(user.id, command.paymentInfo);\n      }\n      \n      // Saga completed successfully\n      await this.eventBus.publish(new UserRegistrationCompletedEvent(user.id, sagaId));\n      \n    } catch (error) {\n      // Compensate for any completed steps\n      await this.compensate(sagaId, error);\n      throw error;\n    }\n  }\n  \n  private async compensate(sagaId: string, error: Error): Promise<void> {\n    // Implement compensation logic\n    // This would reverse any successful operations\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-architecture",children:"Security Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"authentication--authorization",children:"Authentication & Authorization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/auth/jwt-auth.service.ts\n@Injectable()\nexport class JwtAuthService {\n  constructor(\n    private readonly jwtService: JwtService,\n    private readonly userService: UserService,\n  ) {}\n  \n  async validateToken(token: string): Promise<User | null> {\n    try {\n      const payload = this.jwtService.verify(token);\n      const user = await this.userService.findById(payload.sub);\n      \n      if (!user || !user.isActive) {\n        return null;\n      }\n      \n      return user;\n    } catch (error) {\n      return null;\n    }\n  }\n  \n  async generateTokens(user: User): Promise<TokenPair> {\n    const payload = {\n      sub: user.id,\n      email: user.email,\n      roles: user.roles,\n    };\n    \n    const accessToken = this.jwtService.sign(payload, { expiresIn: '15m' });\n    const refreshToken = this.jwtService.sign(\n      { sub: user.id, type: 'refresh' },\n      { expiresIn: '7d' }\n    );\n    \n    return { accessToken, refreshToken };\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"data-protection",children:"Data Protection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/common/encryption/encryption.service.ts\n@Injectable()\nexport class EncryptionService {\n  private readonly algorithm = 'aes-256-gcm';\n  private readonly keyLength = 32;\n  \n  encrypt(text: string, key?: string): EncryptedData {\n    const encryptionKey = key ? Buffer.from(key, 'hex') : this.getDefaultKey();\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipher(this.algorithm, encryptionKey, iv);\n    \n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return {\n      encrypted,\n      iv: iv.toString('hex'),\n      authTag: authTag.toString('hex'),\n    };\n  }\n  \n  decrypt(encryptedData: EncryptedData, key?: string): string {\n    const encryptionKey = key ? Buffer.from(key, 'hex') : this.getDefaultKey();\n    const decipher = crypto.createDecipher(\n      this.algorithm,\n      encryptionKey,\n      Buffer.from(encryptedData.iv, 'hex')\n    );\n    \n    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));\n    \n    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-architecture",children:"Performance Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"caching-strategy",children:"Caching Strategy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/caching/redis-cache.service.ts\n@Injectable()\nexport class RedisCacheService {\n  constructor(\n    @Inject('REDIS_CLIENT') private readonly redis: Redis,\n  ) {}\n  \n  async get<T>(key: string): Promise<T | null> {\n    try {\n      const value = await this.redis.get(key);\n      return value ? JSON.parse(value) : null;\n    } catch (error) {\n      this.logger.error(`Cache get error for key ${key}:`, error);\n      return null;\n    }\n  }\n  \n  async set(key: string, value: any, ttl: number = 3600): Promise<void> {\n    try {\n      await this.redis.setex(key, ttl, JSON.stringify(value));\n    } catch (error) {\n      this.logger.error(`Cache set error for key ${key}:`, error);\n    }\n  }\n  \n  async del(key: string): Promise<void> {\n    try {\n      await this.redis.del(key);\n    } catch (error) {\n      this.logger.error(`Cache delete error for key ${key}:`, error);\n    }\n  }\n  \n  // Cache decorator\n  @Cache('user:{id}', 300) // 5 minutes TTL\n  async getUserById(id: string): Promise<User> {\n    return this.userRepository.findById(id);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"database-optimization",children:"Database Optimization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/database/query-optimization.service.ts\n@Injectable()\nexport class QueryOptimizationService {\n  constructor(\n    @InjectRepository(User) private readonly userRepository: Repository<User>,\n  ) {}\n  \n  // Optimized query with proper joins and pagination\n  async findUsersWithProfiles(\n    filters: UserFilters,\n    pagination: PaginationOptions,\n  ): Promise<PaginatedResult<UserWithProfile>> {\n    const queryBuilder = this.userRepository\n      .createQueryBuilder('user')\n      .leftJoinAndSelect('user.profile', 'profile')\n      .leftJoinAndSelect('user.roles', 'roles');\n    \n    // Apply filters\n    if (filters.email) {\n      queryBuilder.andWhere('user.email ILIKE :email', { \n        email: `%${filters.email}%` \n      });\n    }\n    \n    if (filters.status) {\n      queryBuilder.andWhere('user.status = :status', { \n        status: filters.status \n      });\n    }\n    \n    // Apply pagination\n    queryBuilder\n      .skip(pagination.offset)\n      .take(pagination.limit)\n      .orderBy('user.createdAt', 'DESC');\n    \n    const [users, total] = await queryBuilder.getManyAndCount();\n    \n    return {\n      data: users,\n      total,\n      page: pagination.page,\n      limit: pagination.limit,\n    };\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"monitoring--observability",children:"Monitoring & Observability"}),"\n",(0,i.jsx)(n.h3,{id:"health-checks",children:"Health Checks"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/health/health.service.ts\n@Injectable()\nexport class HealthService {\n  constructor(\n    private readonly health: HealthCheckService,\n    private readonly typeorm: TypeOrmHealthIndicator,\n    private readonly redis: RedisHealthIndicator,\n    private readonly microservice: MicroserviceHealthIndicator,\n  ) {}\n  \n  @Get()\n  @HealthCheck()\n  check() {\n    return this.health.check([\n      // Database health\n      () => this.typeorm.pingCheck('database'),\n      \n      // Redis health\n      () => this.redis.pingCheck('redis'),\n      \n      // External service health\n      () => this.microservice.pingCheck('user-service', {\n        transport: Transport.HTTP,\n        options: { url: process.env.USER_SERVICE_URL + '/health' },\n      }),\n      \n      // Custom business logic health\n      () => this.checkBusinessLogic(),\n    ]);\n  }\n  \n  private async checkBusinessLogic(): Promise<HealthIndicatorResult> {\n    try {\n      // Check critical business functionality\n      const criticalCheck = await this.performCriticalCheck();\n      \n      if (criticalCheck.isHealthy) {\n        return {\n          'business-logic': {\n            status: 'up',\n            info: criticalCheck.info,\n          },\n        };\n      } else {\n        throw new Error(criticalCheck.error);\n      }\n    } catch (error) {\n      return {\n        'business-logic': {\n          status: 'down',\n          message: error.message,\n        },\n      };\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"architecture-guidelines",children:"Architecture Guidelines"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Separation of Concerns"}),": Clear layer boundaries and responsibilities"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dependency Inversion"}),": Depend on abstractions, not concretions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Responsibility"}),": Each component has one reason to change"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Open/Closed Principle"}),": Open for extension, closed for modification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Interface Segregation"}),": Clients shouldn't depend on unused interfaces"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementation-standards",children:"Implementation Standards"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Comprehensive error handling at all layers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Logging"}),": Structured logging with correlation IDs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security"}),": Defense in depth with multiple security layers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Caching, optimization, and monitoring"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testing"}),": Unit, integration, and end-to-end test coverage"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"documentation-requirements",children:"Documentation Requirements"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"API Documentation"}),": OpenAPI/Swagger specifications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Architecture Diagrams"}),": C4 model documentation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runbooks"}),": Operational procedures and troubleshooting"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decision Records"}),": Architecture decision documentation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-definition/dev-environment-setup",children:"Development Environment Setup"})})," - Environment configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-definition/coding-standards",children:"Coding Standards"})})," - Code quality standards"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline",children:"CI/CD Pipeline"})})," - Deployment automation"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"This architecture foundation should be regularly reviewed and updated to reflect evolving best practices and technology capabilities."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);