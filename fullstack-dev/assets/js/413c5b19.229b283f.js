"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[6103],{7814:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(9729);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}},9803:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"coding-conventions/nestjs-guidelines","title":"NestJS Guidelines","description":"Comprehensive guidelines for building scalable, maintainable NestJS applications with proper architecture patterns and best practices.","source":"@site/docs/coding-conventions/nestjs-guidelines.md","sourceDirName":"coding-conventions","slug":"/coding-conventions/nestjs-guidelines","permalink":"/fullstack-dev/docs/coding-conventions/nestjs-guidelines","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/coding-conventions/nestjs-guidelines.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Node.js Best Practices","permalink":"/fullstack-dev/docs/coding-conventions/nodejs-best-practices"},"next":{"title":"Database Conventions","permalink":"/fullstack-dev/docs/coding-conventions/database-conventions"}}');var s=r(5813),o=r(7814);const i={},a="NestJS Guidelines",d={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Architecture Patterns",id:"architecture-patterns",level:2},{value:"Clean Architecture with NestJS",id:"clean-architecture-with-nestjs",level:3},{value:"Domain-Driven Design Structure",id:"domain-driven-design-structure",level:3},{value:"Dependency Injection",id:"dependency-injection",level:2},{value:"Service Registration Patterns",id:"service-registration-patterns",level:3},{value:"Custom Providers and Factories",id:"custom-providers-and-factories",level:3},{value:"Injection Tokens and Interfaces",id:"injection-tokens-and-interfaces",level:3},{value:"Modules and Organization",id:"modules-and-organization",level:2},{value:"Feature Module Pattern",id:"feature-module-pattern",level:3},{value:"Global Modules",id:"global-modules",level:3},{value:"Controllers and DTOs",id:"controllers-and-dtos",level:2},{value:"RESTful Controller Design",id:"restful-controller-design",level:3},{value:"Data Transfer Objects (DTOs)",id:"data-transfer-objects-dtos",level:3},{value:"Services and Providers",id:"services-and-providers",level:2},{value:"Service Layer Design",id:"service-layer-design",level:3},{value:"Repository Pattern",id:"repository-pattern",level:3},{value:"Database Integration",id:"database-integration",level:2},{value:"Entity Definition",id:"entity-definition",level:3},{value:"Database Transactions",id:"database-transactions",level:3},{value:"Validation and Pipes",id:"validation-and-pipes",level:2},{value:"Custom Validation Pipes",id:"custom-validation-pipes",level:3},{value:"Custom Validators",id:"custom-validators",level:3},{value:"Authentication and Guards",id:"authentication-and-guards",level:2},{value:"JWT Authentication Strategy",id:"jwt-authentication-strategy",level:3},{value:"Custom Guards",id:"custom-guards",level:3},{value:"Rate Limiting Guard",id:"rate-limiting-guard",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"nestjs-guidelines",children:"NestJS Guidelines"})}),"\n",(0,s.jsx)(n.p,{children:"Comprehensive guidelines for building scalable, maintainable NestJS applications with proper architecture patterns and best practices."}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#architecture-patterns",children:"Architecture Patterns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#dependency-injection",children:"Dependency Injection"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#modules-and-organization",children:"Modules and Organization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#controllers-and-dtos",children:"Controllers and DTOs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#services-and-providers",children:"Services and Providers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#database-integration",children:"Database Integration"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#validation-and-pipes",children:"Validation and Pipes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#authentication-and-guards",children:"Authentication and Guards"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"architecture-patterns",children:"Architecture Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"clean-architecture-with-nestjs",children:"Clean Architecture with NestJS"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"src/\n\u251c\u2500\u2500 app.module.ts\n\u251c\u2500\u2500 main.ts\n\u251c\u2500\u2500 common/                 # Shared utilities and decorators\n\u2502   \u251c\u2500\u2500 decorators/\n\u2502   \u251c\u2500\u2500 filters/\n\u2502   \u251c\u2500\u2500 guards/\n\u2502   \u251c\u2500\u2500 interceptors/\n\u2502   \u251c\u2500\u2500 pipes/\n\u2502   \u2514\u2500\u2500 utils/\n\u251c\u2500\u2500 config/                 # Configuration files\n\u2502   \u251c\u2500\u2500 database.config.ts\n\u2502   \u251c\u2500\u2500 jwt.config.ts\n\u2502   \u2514\u2500\u2500 app.config.ts\n\u251c\u2500\u2500 modules/                # Feature modules\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 auth.module.ts\n\u2502   \u2502   \u251c\u2500\u2500 auth.controller.ts\n\u2502   \u2502   \u251c\u2500\u2500 auth.service.ts\n\u2502   \u2502   \u251c\u2500\u2500 dto/\n\u2502   \u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u2514\u2500\u2500 strategies/\n\u2502   \u251c\u2500\u2500 users/\n\u2502   \u2502   \u251c\u2500\u2500 users.module.ts\n\u2502   \u2502   \u251c\u2500\u2500 users.controller.ts\n\u2502   \u2502   \u251c\u2500\u2500 users.service.ts\n\u2502   \u2502   \u251c\u2500\u2500 users.repository.ts\n\u2502   \u2502   \u251c\u2500\u2500 dto/\n\u2502   \u2502   \u2514\u2500\u2500 entities/\n\u2502   \u2514\u2500\u2500 products/\n\u2514\u2500\u2500 shared/                 # Shared modules and services\n    \u251c\u2500\u2500 database/\n    \u251c\u2500\u2500 logger/\n    \u2514\u2500\u2500 email/\n"})}),"\n",(0,s.jsx)(n.h3,{id:"domain-driven-design-structure",children:"Domain-Driven Design Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/user/domain/user.entity.ts\nexport class User {\n  constructor(\n    public readonly id: UserId,\n    public readonly email: Email,\n    public readonly profile: UserProfile,\n    private _isActive: boolean = true\n  ) {}\n\n  activate(): void {\n    this._isActive = true;\n  }\n\n  deactivate(): void {\n    this._isActive = false;\n  }\n\n  updateProfile(newProfile: UserProfile): void {\n    // Business logic for updating profile\n    this.profile = newProfile;\n  }\n\n  get isActive(): boolean {\n    return this._isActive;\n  }\n}\n\n// Value objects\nexport class UserId {\n  constructor(private readonly value: string) {\n    if (!value || value.trim().length === 0) {\n      throw new Error('UserId cannot be empty');\n    }\n  }\n\n  toString(): string {\n    return this.value;\n  }\n\n  equals(other: UserId): boolean {\n    return this.value === other.value;\n  }\n}\n\nexport class Email {\n  constructor(private readonly value: string) {\n    if (!this.isValidEmail(value)) {\n      throw new Error('Invalid email format');\n    }\n  }\n\n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  toString(): string {\n    return this.value;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dependency-injection",children:"Dependency Injection"}),"\n",(0,s.jsx)(n.h3,{id:"service-registration-patterns",children:"Service Registration Patterns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/users/users.module.ts\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UsersController } from './users.controller';\nimport { UsersService } from './users.service';\nimport { UsersRepository } from './users.repository';\nimport { User } from './entities/user.entity';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  controllers: [UsersController],\n  providers: [\n    UsersService,\n    UsersRepository,\n    {\n      provide: 'USER_REPOSITORY',\n      useClass: UsersRepository,\n    },\n    {\n      provide: 'EMAIL_SERVICE',\n      useFactory: (configService: ConfigService) => {\n        return new EmailService(configService.get('EMAIL_CONFIG'));\n      },\n      inject: [ConfigService],\n    },\n  ],\n  exports: [UsersService, UsersRepository],\n})\nexport class UsersModule {}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"custom-providers-and-factories",children:"Custom Providers and Factories"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/users/providers/user.providers.ts\nimport { Provider } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\nexport const userProviders: Provider[] = [\n  {\n    provide: 'USER_CONFIG',\n    useFactory: (configService: ConfigService) => ({\n      defaultRole: configService.get('DEFAULT_USER_ROLE'),\n      maxLoginAttempts: configService.get('MAX_LOGIN_ATTEMPTS'),\n      sessionTimeout: configService.get('SESSION_TIMEOUT'),\n    }),\n    inject: [ConfigService],\n  },\n  {\n    provide: 'PASSWORD_HASHER',\n    useFactory: () => {\n      return {\n        hash: async (password: string): Promise<string> => {\n          const bcrypt = await import('bcrypt');\n          return bcrypt.hash(password, 12);\n        },\n        compare: async (password: string, hash: string): Promise<boolean> => {\n          const bcrypt = await import('bcrypt');\n          return bcrypt.compare(password, hash);\n        },\n      };\n    },\n  },\n];\n"})}),"\n",(0,s.jsx)(n.h3,{id:"injection-tokens-and-interfaces",children:"Injection Tokens and Interfaces"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/users/interfaces/user-repository.interface.ts\nexport interface IUserRepository {\n  findById(id: string): Promise<User | null>;\n  findByEmail(email: string): Promise<User | null>;\n  create(userData: CreateUserRequest): Promise<User>;\n  update(id: string, updateData: UpdateUserRequest): Promise<User>;\n  delete(id: string): Promise<void>;\n}\n\nexport const USER_REPOSITORY_TOKEN = Symbol('USER_REPOSITORY');\n\n// src/modules/users/users.service.ts\nimport { Injectable, Inject } from '@nestjs/common';\nimport { IUserRepository, USER_REPOSITORY_TOKEN } from './interfaces/user-repository.interface';\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    @Inject(USER_REPOSITORY_TOKEN)\n    private readonly userRepository: IUserRepository,\n    @Inject('PASSWORD_HASHER')\n    private readonly passwordHasher: any,\n  ) {}\n\n  async createUser(userData: CreateUserRequest): Promise<User> {\n    const hashedPassword = await this.passwordHasher.hash(userData.password);\n    \n    return this.userRepository.create({\n      ...userData,\n      password: hashedPassword,\n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"modules-and-organization",children:"Modules and Organization"}),"\n",(0,s.jsx)(n.h3,{id:"feature-module-pattern",children:"Feature Module Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/orders/orders.module.ts\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { OrdersController } from './orders.controller';\nimport { OrdersService } from './orders.service';\nimport { OrdersRepository } from './orders.repository';\nimport { Order } from './entities/order.entity';\nimport { OrderItem } from './entities/order-item.entity';\nimport { UsersModule } from '../users/users.module';\nimport { ProductsModule } from '../products/products.module';\nimport { PaymentModule } from '../payment/payment.module';\n\n@Module({\n  imports: [\n    TypeOrmModule.forFeature([Order, OrderItem]),\n    UsersModule, // Import user services\n    ProductsModule, // Import product services\n    PaymentModule, // Import payment services\n  ],\n  controllers: [OrdersController],\n  providers: [OrdersService, OrdersRepository],\n  exports: [OrdersService], // Export for other modules\n})\nexport class OrdersModule {}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"global-modules",children:"Global Modules"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/shared/logger/logger.module.ts\nimport { Global, Module } from '@nestjs/common';\nimport { LoggerService } from './logger.service';\n\n@Global()\n@Module({\n  providers: [\n    {\n      provide: LoggerService,\n      useFactory: () => {\n        return new LoggerService({\n          level: process.env.LOG_LEVEL || 'info',\n          service: process.env.SERVICE_NAME || 'api',\n        });\n      },\n    },\n  ],\n  exports: [LoggerService],\n})\nexport class LoggerModule {}\n\n// src/shared/database/database.module.ts\nimport { Global, Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\n@Global()\n@Module({\n  imports: [\n    TypeOrmModule.forRootAsync({\n      imports: [ConfigModule],\n      useFactory: (configService: ConfigService) => ({\n        type: 'postgres',\n        host: configService.get('DATABASE_HOST'),\n        port: configService.get('DATABASE_PORT'),\n        username: configService.get('DATABASE_USERNAME'),\n        password: configService.get('DATABASE_PASSWORD'),\n        database: configService.get('DATABASE_NAME'),\n        entities: [__dirname + '/../**/*.entity{.ts,.js}'],\n        synchronize: configService.get('NODE_ENV') === 'development',\n        logging: configService.get('DATABASE_LOGGING') === 'true',\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n})\nexport class DatabaseModule {}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"controllers-and-dtos",children:"Controllers and DTOs"}),"\n",(0,s.jsx)(n.h3,{id:"restful-controller-design",children:"RESTful Controller Design"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/users/users.controller.ts\nimport {\n  Controller,\n  Get,\n  Post,\n  Put,\n  Delete,\n  Body,\n  Param,\n  Query,\n  UseGuards,\n  UseInterceptors,\n  ParseUUIDPipe,\n  HttpStatus,\n  HttpCode,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiParam,\n  ApiQuery,\n  ApiBearerAuth,\n} from '@nestjs/swagger';\nimport { UsersService } from './users.service';\nimport { CreateUserDto, UpdateUserDto, UserResponseDto } from './dto';\nimport { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';\nimport { RolesGuard } from '../auth/guards/roles.guard';\nimport { Roles } from '../auth/decorators/roles.decorator';\nimport { CurrentUser } from '../auth/decorators/current-user.decorator';\nimport { LoggingInterceptor } from '../../common/interceptors/logging.interceptor';\nimport { PaginationDto } from '../../common/dto/pagination.dto';\n\n@ApiTags('users')\n@Controller('users')\n@UseInterceptors(LoggingInterceptor)\n@ApiBearerAuth()\nexport class UsersController {\n  constructor(private readonly usersService: UsersService) {}\n\n  @Post()\n  @HttpCode(HttpStatus.CREATED)\n  @ApiOperation({ summary: 'Create a new user' })\n  @ApiResponse({\n    status: 201,\n    description: 'User created successfully',\n    type: UserResponseDto,\n  })\n  @ApiResponse({\n    status: 400,\n    description: 'Invalid input data',\n  })\n  async createUser(@Body() createUserDto: CreateUserDto): Promise<UserResponseDto> {\n    return this.usersService.create(createUserDto);\n  }\n\n  @Get()\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Roles('admin')\n  @ApiOperation({ summary: 'Get all users with pagination' })\n  @ApiQuery({ type: PaginationDto })\n  @ApiResponse({\n    status: 200,\n    description: 'Users retrieved successfully',\n    type: [UserResponseDto],\n  })\n  async getUsers(@Query() paginationDto: PaginationDto) {\n    return this.usersService.findAll(paginationDto);\n  }\n\n  @Get(':id')\n  @UseGuards(JwtAuthGuard)\n  @ApiOperation({ summary: 'Get user by ID' })\n  @ApiParam({ name: 'id', type: 'string', format: 'uuid' })\n  @ApiResponse({\n    status: 200,\n    description: 'User found',\n    type: UserResponseDto,\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'User not found',\n  })\n  async getUserById(\n    @Param('id', ParseUUIDPipe) id: string,\n  ): Promise<UserResponseDto> {\n    return this.usersService.findById(id);\n  }\n\n  @Put(':id')\n  @UseGuards(JwtAuthGuard)\n  @ApiOperation({ summary: 'Update user' })\n  @ApiParam({ name: 'id', type: 'string', format: 'uuid' })\n  @ApiResponse({\n    status: 200,\n    description: 'User updated successfully',\n    type: UserResponseDto,\n  })\n  async updateUser(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Body() updateUserDto: UpdateUserDto,\n    @CurrentUser() currentUser: any,\n  ): Promise<UserResponseDto> {\n    return this.usersService.update(id, updateUserDto, currentUser);\n  }\n\n  @Delete(':id')\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Roles('admin')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Delete user' })\n  @ApiParam({ name: 'id', type: 'string', format: 'uuid' })\n  @ApiResponse({\n    status: 204,\n    description: 'User deleted successfully',\n  })\n  async deleteUser(@Param('id', ParseUUIDPipe) id: string): Promise<void> {\n    return this.usersService.delete(id);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"data-transfer-objects-dtos",children:"Data Transfer Objects (DTOs)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/users/dto/create-user.dto.ts\nimport {\n  IsEmail,\n  IsString,\n  IsOptional,\n  IsEnum,\n  IsInt,\n  Min,\n  Max,\n  MinLength,\n  MaxLength,\n  Matches,\n} from 'class-validator';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport { Transform } from 'class-transformer';\n\nexport enum UserRole {\n  USER = 'user',\n  ADMIN = 'admin',\n  MODERATOR = 'moderator',\n}\n\nexport class CreateUserDto {\n  @ApiProperty({\n    description: 'User email address',\n    example: 'user@example.com',\n  })\n  @IsEmail({}, { message: 'Please provide a valid email address' })\n  @Transform(({ value }) => value.toLowerCase().trim())\n  email: string;\n\n  @ApiProperty({\n    description: 'User full name',\n    example: 'John Doe',\n    minLength: 2,\n    maxLength: 50,\n  })\n  @IsString()\n  @MinLength(2, { message: 'Name must be at least 2 characters long' })\n  @MaxLength(50, { message: 'Name must not exceed 50 characters' })\n  @Transform(({ value }) => value.trim())\n  name: string;\n\n  @ApiProperty({\n    description: 'User password',\n    example: 'SecurePassword123!',\n    minLength: 8,\n  })\n  @IsString()\n  @MinLength(8, { message: 'Password must be at least 8 characters long' })\n  @Matches(\n    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/,\n    {\n      message: 'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',\n    },\n  )\n  password: string;\n\n  @ApiPropertyOptional({\n    description: 'User age',\n    example: 25,\n    minimum: 18,\n    maximum: 120,\n  })\n  @IsOptional()\n  @IsInt({ message: 'Age must be an integer' })\n  @Min(18, { message: 'User must be at least 18 years old' })\n  @Max(120, { message: 'Age must not exceed 120' })\n  age?: number;\n\n  @ApiPropertyOptional({\n    description: 'User role',\n    enum: UserRole,\n    default: UserRole.USER,\n  })\n  @IsOptional()\n  @IsEnum(UserRole, { message: 'Role must be a valid user role' })\n  role?: UserRole = UserRole.USER;\n}\n\n// src/modules/users/dto/update-user.dto.ts\nimport { PartialType, OmitType } from '@nestjs/swagger';\nimport { CreateUserDto } from './create-user.dto';\n\nexport class UpdateUserDto extends PartialType(\n  OmitType(CreateUserDto, ['email', 'password'] as const),\n) {}\n\n// src/modules/users/dto/user-response.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\nimport { Exclude, Expose, Transform } from 'class-transformer';\nimport { UserRole } from './create-user.dto';\n\nexport class UserResponseDto {\n  @ApiProperty({ example: '123e4567-e89b-12d3-a456-426614174000' })\n  @Expose()\n  id: string;\n\n  @ApiProperty({ example: 'user@example.com' })\n  @Expose()\n  email: string;\n\n  @ApiProperty({ example: 'John Doe' })\n  @Expose()\n  name: string;\n\n  @ApiProperty({ example: 25 })\n  @Expose()\n  age?: number;\n\n  @ApiProperty({ enum: UserRole, example: UserRole.USER })\n  @Expose()\n  role: UserRole;\n\n  @ApiProperty({ example: '2023-01-01T00:00:00.000Z' })\n  @Expose()\n  @Transform(({ value }) => value.toISOString())\n  createdAt: Date;\n\n  @ApiProperty({ example: '2023-01-01T00:00:00.000Z' })\n  @Expose()\n  @Transform(({ value }) => value.toISOString())\n  updatedAt: Date;\n\n  @Exclude()\n  password: string;\n\n  constructor(partial: Partial<UserResponseDto>) {\n    Object.assign(this, partial);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"services-and-providers",children:"Services and Providers"}),"\n",(0,s.jsx)(n.h3,{id:"service-layer-design",children:"Service Layer Design"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/users/users.service.ts\nimport {\n  Injectable,\n  NotFoundException,\n  ConflictException,\n  ForbiddenException,\n  Inject,\n} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { User } from './entities/user.entity';\nimport { CreateUserDto, UpdateUserDto, UserResponseDto } from './dto';\nimport { PaginationDto } from '../../common/dto/pagination.dto';\nimport { LoggerService } from '../../shared/logger/logger.service';\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    @InjectRepository(User)\n    private readonly userRepository: Repository<User>,\n    @Inject('PASSWORD_HASHER')\n    private readonly passwordHasher: any,\n    private readonly logger: LoggerService,\n  ) {}\n\n  async create(createUserDto: CreateUserDto): Promise<UserResponseDto> {\n    this.logger.log('Creating new user', { email: createUserDto.email });\n\n    // Check if user already exists\n    const existingUser = await this.userRepository.findOne({\n      where: { email: createUserDto.email },\n    });\n\n    if (existingUser) {\n      throw new ConflictException('User with this email already exists');\n    }\n\n    // Hash password\n    const hashedPassword = await this.passwordHasher.hash(createUserDto.password);\n\n    // Create user entity\n    const user = this.userRepository.create({\n      ...createUserDto,\n      password: hashedPassword,\n    });\n\n    // Save to database\n    const savedUser = await this.userRepository.save(user);\n\n    this.logger.log('User created successfully', { userId: savedUser.id });\n\n    return new UserResponseDto(savedUser);\n  }\n\n  async findAll(paginationDto: PaginationDto) {\n    const { page = 1, limit = 10 } = paginationDto;\n    const skip = (page - 1) * limit;\n\n    const [users, total] = await this.userRepository.findAndCount({\n      skip,\n      take: limit,\n      order: { createdAt: 'DESC' },\n    });\n\n    return {\n      data: users.map(user => new UserResponseDto(user)),\n      pagination: {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil(total / limit),\n      },\n    };\n  }\n\n  async findById(id: string): Promise<UserResponseDto> {\n    const user = await this.userRepository.findOne({ where: { id } });\n\n    if (!user) {\n      throw new NotFoundException(`User with ID ${id} not found`);\n    }\n\n    return new UserResponseDto(user);\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    return this.userRepository.findOne({ where: { email } });\n  }\n\n  async update(\n    id: string,\n    updateUserDto: UpdateUserDto,\n    currentUser: any,\n  ): Promise<UserResponseDto> {\n    // Check if user exists\n    const user = await this.userRepository.findOne({ where: { id } });\n\n    if (!user) {\n      throw new NotFoundException(`User with ID ${id} not found`);\n    }\n\n    // Check permissions (users can only update their own profile)\n    if (currentUser.role !== 'admin' && currentUser.id !== id) {\n      throw new ForbiddenException('You can only update your own profile');\n    }\n\n    // Update user\n    Object.assign(user, updateUserDto);\n    const updatedUser = await this.userRepository.save(user);\n\n    this.logger.log('User updated successfully', { userId: id });\n\n    return new UserResponseDto(updatedUser);\n  }\n\n  async delete(id: string): Promise<void> {\n    const user = await this.userRepository.findOne({ where: { id } });\n\n    if (!user) {\n      throw new NotFoundException(`User with ID ${id} not found`);\n    }\n\n    await this.userRepository.remove(user);\n\n    this.logger.log('User deleted successfully', { userId: id });\n  }\n\n  async validateUser(email: string, password: string): Promise<User | null> {\n    const user = await this.userRepository.findOne({ where: { email } });\n\n    if (user && await this.passwordHasher.compare(password, user.password)) {\n      return user;\n    }\n\n    return null;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"repository-pattern",children:"Repository Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/users/users.repository.ts\nimport { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, FindManyOptions } from 'typeorm';\nimport { User } from './entities/user.entity';\nimport { CreateUserDto, UpdateUserDto } from './dto';\n\n@Injectable()\nexport class UsersRepository {\n  constructor(\n    @InjectRepository(User)\n    private readonly repository: Repository<User>,\n  ) {}\n\n  async create(createUserDto: CreateUserDto): Promise<User> {\n    const user = this.repository.create(createUserDto);\n    return this.repository.save(user);\n  }\n\n  async findById(id: string): Promise<User | null> {\n    return this.repository.findOne({ where: { id } });\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    return this.repository.findOne({ where: { email } });\n  }\n\n  async findAll(options: FindManyOptions<User> = {}): Promise<User[]> {\n    return this.repository.find(options);\n  }\n\n  async findAndCount(options: FindManyOptions<User> = {}): Promise<[User[], number]> {\n    return this.repository.findAndCount(options);\n  }\n\n  async update(id: string, updateUserDto: UpdateUserDto): Promise<User> {\n    await this.repository.update(id, updateUserDto);\n    return this.findById(id);\n  }\n\n  async delete(id: string): Promise<void> {\n    await this.repository.delete(id);\n  }\n\n  async softDelete(id: string): Promise<void> {\n    await this.repository.softDelete(id);\n  }\n\n  async findActiveUsers(): Promise<User[]> {\n    return this.repository.find({\n      where: { isActive: true },\n      order: { createdAt: 'DESC' },\n    });\n  }\n\n  async countByRole(role: string): Promise<number> {\n    return this.repository.count({ where: { role } });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"database-integration",children:"Database Integration"}),"\n",(0,s.jsx)(n.h3,{id:"entity-definition",children:"Entity Definition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/users/entities/user.entity.ts\nimport {\n  Entity,\n  PrimaryGeneratedColumn,\n  Column,\n  CreateDateColumn,\n  UpdateDateColumn,\n  DeleteDateColumn,\n  Index,\n  OneToMany,\n  BeforeInsert,\n  BeforeUpdate,\n} from 'typeorm';\nimport { Order } from '../../orders/entities/order.entity';\n\n@Entity('users')\n@Index(['email'], { unique: true })\n@Index(['role'])\nexport class User {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ unique: true })\n  email: string;\n\n  @Column()\n  name: string;\n\n  @Column({ select: false }) // Exclude from default selects\n  password: string;\n\n  @Column({ nullable: true })\n  age?: number;\n\n  @Column({ default: 'user' })\n  role: string;\n\n  @Column({ default: true })\n  isActive: boolean;\n\n  @Column({ nullable: true })\n  lastLoginAt?: Date;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  @DeleteDateColumn()\n  deletedAt?: Date;\n\n  // Relations\n  @OneToMany(() => Order, order => order.user)\n  orders: Order[];\n\n  // Hooks\n  @BeforeInsert()\n  @BeforeUpdate()\n  emailToLowerCase() {\n    this.email = this.email.toLowerCase();\n  }\n\n  @BeforeInsert()\n  @BeforeUpdate()\n  trimName() {\n    this.name = this.name.trim();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"database-transactions",children:"Database Transactions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/orders/orders.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, DataSource } from 'typeorm';\nimport { Order } from './entities/order.entity';\nimport { OrderItem } from './entities/order-item.entity';\nimport { User } from '../users/entities/user.entity';\nimport { Product } from '../products/entities/product.entity';\n\n@Injectable()\nexport class OrdersService {\n  constructor(\n    @InjectRepository(Order)\n    private readonly orderRepository: Repository<Order>,\n    @InjectRepository(OrderItem)\n    private readonly orderItemRepository: Repository<OrderItem>,\n    private readonly dataSource: DataSource,\n  ) {}\n\n  async createOrder(userId: string, orderItems: CreateOrderItemDto[]): Promise<Order> {\n    return this.dataSource.transaction(async manager => {\n      // Create order\n      const order = manager.create(Order, {\n        userId,\n        status: 'pending',\n        total: 0,\n      });\n      const savedOrder = await manager.save(order);\n\n      let total = 0;\n\n      // Create order items\n      for (const item of orderItems) {\n        // Check product availability\n        const product = await manager.findOne(Product, {\n          where: { id: item.productId },\n        });\n\n        if (!product) {\n          throw new NotFoundException(`Product ${item.productId} not found`);\n        }\n\n        if (product.stock < item.quantity) {\n          throw new BadRequestException(\n            `Insufficient stock for product ${product.name}`,\n          );\n        }\n\n        // Create order item\n        const orderItem = manager.create(OrderItem, {\n          orderId: savedOrder.id,\n          productId: item.productId,\n          quantity: item.quantity,\n          price: product.price,\n        });\n        await manager.save(orderItem);\n\n        // Update product stock\n        product.stock -= item.quantity;\n        await manager.save(product);\n\n        total += product.price * item.quantity;\n      }\n\n      // Update order total\n      savedOrder.total = total;\n      await manager.save(savedOrder);\n\n      return savedOrder;\n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"validation-and-pipes",children:"Validation and Pipes"}),"\n",(0,s.jsx)(n.h3,{id:"custom-validation-pipes",children:"Custom Validation Pipes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/common/pipes/parse-object-id.pipe.ts\nimport {\n  PipeTransform,\n  Injectable,\n  ArgumentMetadata,\n  BadRequestException,\n} from '@nestjs/common';\nimport { isUUID } from 'class-validator';\n\n@Injectable()\nexport class ParseObjectIdPipe implements PipeTransform<string, string> {\n  transform(value: string, metadata: ArgumentMetadata): string {\n    if (!isUUID(value)) {\n      throw new BadRequestException('Invalid UUID format');\n    }\n    return value;\n  }\n}\n\n// src/common/pipes/validation.pipe.ts\nimport {\n  PipeTransform,\n  Injectable,\n  ArgumentMetadata,\n  BadRequestException,\n} from '@nestjs/common';\nimport { validate } from 'class-validator';\nimport { plainToClass } from 'class-transformer';\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform<any> {\n  async transform(value: any, { metatype }: ArgumentMetadata) {\n    if (!metatype || !this.toValidate(metatype)) {\n      return value;\n    }\n\n    const object = plainToClass(metatype, value);\n    const errors = await validate(object);\n\n    if (errors.length > 0) {\n      const messages = errors.map(error => {\n        return {\n          field: error.property,\n          constraints: Object.values(error.constraints || {}),\n        };\n      });\n\n      throw new BadRequestException({\n        message: 'Validation failed',\n        errors: messages,\n      });\n    }\n\n    return object;\n  }\n\n  private toValidate(metatype: Function): boolean {\n    const types: Function[] = [String, Boolean, Number, Array, Object];\n    return !types.includes(metatype);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"custom-validators",children:"Custom Validators"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/common/validators/is-unique.validator.ts\nimport {\n  registerDecorator,\n  ValidationOptions,\n  ValidatorConstraint,\n  ValidatorConstraintInterface,\n  ValidationArguments,\n} from 'class-validator';\nimport { Injectable } from '@nestjs/common';\nimport { DataSource } from 'typeorm';\n\n@ValidatorConstraint({ async: true })\n@Injectable()\nexport class IsUniqueConstraint implements ValidatorConstraintInterface {\n  constructor(private dataSource: DataSource) {}\n\n  async validate(value: any, args: ValidationArguments) {\n    const [entityClass, property] = args.constraints;\n    const repository = this.dataSource.getRepository(entityClass);\n    \n    const entity = await repository.findOne({\n      where: { [property]: value },\n    });\n    \n    return !entity;\n  }\n\n  defaultMessage(args: ValidationArguments) {\n    const [entityClass, property] = args.constraints;\n    return `${property} must be unique`;\n  }\n}\n\nexport function IsUnique(\n  entityClass: any,\n  property: string,\n  validationOptions?: ValidationOptions,\n) {\n  return function (object: Object, propertyName: string) {\n    registerDecorator({\n      target: object.constructor,\n      propertyName: propertyName,\n      options: validationOptions,\n      constraints: [entityClass, property],\n      validator: IsUniqueConstraint,\n    });\n  };\n}\n\n// Usage in DTO\nexport class CreateUserDto {\n  @IsEmail()\n  @IsUnique(User, 'email', { message: 'Email already exists' })\n  email: string;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"authentication-and-guards",children:"Authentication and Guards"}),"\n",(0,s.jsx)(n.h3,{id:"jwt-authentication-strategy",children:"JWT Authentication Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/modules/auth/strategies/jwt.strategy.ts\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { UsersService } from '../../users/users.service';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor(\n    private configService: ConfigService,\n    private usersService: UsersService,\n  ) {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: configService.get('JWT_SECRET'),\n    });\n  }\n\n  async validate(payload: any) {\n    const user = await this.usersService.findById(payload.sub);\n    \n    if (!user) {\n      throw new UnauthorizedException('User not found');\n    }\n\n    if (!user.isActive) {\n      throw new UnauthorizedException('User account is disabled');\n    }\n\n    return {\n      id: user.id,\n      email: user.email,\n      role: user.role,\n    };\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"custom-guards",children:"Custom Guards"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/common/guards/roles.guard.ts\nimport {\n  Injectable,\n  CanActivate,\n  ExecutionContext,\n  ForbiddenException,\n} from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { ROLES_KEY } from '../decorators/roles.decorator';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<string[]>(\n      ROLES_KEY,\n      [context.getHandler(), context.getClass()],\n    );\n\n    if (!requiredRoles) {\n      return true;\n    }\n\n    const { user } = context.switchToHttp().getRequest();\n    \n    if (!user) {\n      throw new ForbiddenException('User not authenticated');\n    }\n\n    const hasRole = requiredRoles.some(role => user.role === role);\n    \n    if (!hasRole) {\n      throw new ForbiddenException(\n        `Access denied. Required roles: ${requiredRoles.join(', ')}`,\n      );\n    }\n\n    return true;\n  }\n}\n\n// src/common/decorators/roles.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);\n\n// src/common/decorators/current-user.decorator.ts\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const CurrentUser = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return request.user;\n  },\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"rate-limiting-guard",children:"Rate Limiting Guard"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/common/guards/rate-limit.guard.ts\nimport {\n  Injectable,\n  CanActivate,\n  ExecutionContext,\n  HttpException,\n  HttpStatus,\n} from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { RATE_LIMIT_KEY } from '../decorators/rate-limit.decorator';\n\ninterface RateLimitOptions {\n  points: number;\n  duration: number;\n}\n\n@Injectable()\nexport class RateLimitGuard implements CanActivate {\n  private requests = new Map<string, { count: number; resetTime: number }>();\n\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const rateLimitOptions = this.reflector.get<RateLimitOptions>(\n      RATE_LIMIT_KEY,\n      context.getHandler(),\n    );\n\n    if (!rateLimitOptions) {\n      return true;\n    }\n\n    const request = context.switchToHttp().getRequest();\n    const key = this.generateKey(request);\n    const now = Date.now();\n\n    let requestInfo = this.requests.get(key);\n\n    if (!requestInfo || now > requestInfo.resetTime) {\n      requestInfo = {\n        count: 1,\n        resetTime: now + rateLimitOptions.duration * 1000,\n      };\n      this.requests.set(key, requestInfo);\n      return true;\n    }\n\n    if (requestInfo.count >= rateLimitOptions.points) {\n      throw new HttpException(\n        'Too Many Requests',\n        HttpStatus.TOO_MANY_REQUESTS,\n      );\n    }\n\n    requestInfo.count++;\n    return true;\n  }\n\n  private generateKey(request: any): string {\n    return `${request.ip}:${request.route?.path || request.url}`;\n  }\n}\n\n// src/common/decorators/rate-limit.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const RATE_LIMIT_KEY = 'rateLimit';\nexport const RateLimit = (points: number, duration: number) =>\n  SetMetadata(RATE_LIMIT_KEY, { points, duration });\n\n// Usage\n@Controller('auth')\nexport class AuthController {\n  @Post('login')\n  @RateLimit(5, 60) // 5 requests per minute\n  async login(@Body() loginDto: LoginDto) {\n    return this.authService.login(loginDto);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use modular architecture"})," with clear separation of concerns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement proper dependency injection"})," with interfaces and tokens"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Design RESTful APIs"})," with proper HTTP status codes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use DTOs for data validation"})," and transformation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement comprehensive error handling"})," with custom exceptions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use database transactions"})," for complex operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Apply security best practices"})," with guards and middleware"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Write testable code"})," with proper dependency injection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use TypeORM"})," effectively with entities and repositories"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Follow consistent naming conventions"})," and code organization"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);