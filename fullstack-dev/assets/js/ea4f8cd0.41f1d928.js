"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[7756],{5741:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var r=s(9729);const i={},a=r.createContext(i);function t(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(a.Provider,{value:n},e.children)}},8024:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"devops/gcp/gke-ingress-setup","title":"GKE Ingress Setup Guide","description":"A comprehensive guide to setting up and configuring ingress controllers in Google Kubernetes Engine (GKE).","source":"@site/docs/devops/gcp/gke-ingress-setup.md","sourceDirName":"devops/gcp","slug":"/devops/gcp/gke-ingress-setup","permalink":"/fullstack-dev/docs/devops/gcp/gke-ingress-setup","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/devops/gcp/gke-ingress-setup.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"GKE Cluster Setup Guide","permalink":"/fullstack-dev/docs/devops/gcp/gke-cluster-setup"},"next":{"title":"Comprehensive Microservices Architecture on GCP with Terraform","permalink":"/fullstack-dev/docs/devops/gcp/microservices-terraform-guide"}}');var i=s(5813),a=s(5741);const t={},o="GKE Ingress Setup Guide",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Required IAM Permissions",id:"required-iam-permissions",level:3},{value:"Ingress Controller Options",id:"ingress-controller-options",level:2},{value:"1. GKE Ingress (Google Cloud Load Balancer)",id:"1-gke-ingress-google-cloud-load-balancer",level:3},{value:"2. NGINX Ingress Controller",id:"2-nginx-ingress-controller",level:3},{value:"GKE Ingress (Google Cloud Load Balancer)",id:"gke-ingress-google-cloud-load-balancer",level:2},{value:"Step 1: Enable Required APIs",id:"step-1-enable-required-apis",level:3},{value:"Step 2: Create a Sample Application",id:"step-2-create-a-sample-application",level:3},{value:"Step 3: Create GKE Ingress",id:"step-3-create-gke-ingress",level:3},{value:"Step 4: Reserve Static IP",id:"step-4-reserve-static-ip",level:3},{value:"Step 5: Create Managed SSL Certificate",id:"step-5-create-managed-ssl-certificate",level:3},{value:"NGINX Ingress Controller",id:"nginx-ingress-controller",level:2},{value:"Step 1: Install NGINX Ingress Controller",id:"step-1-install-nginx-ingress-controller",level:3},{value:"Prerequisites for GKE",id:"prerequisites-for-gke",level:4},{value:"Installation Methods",id:"installation-methods",level:4},{value:"GKE-Specific Configuration Considerations",id:"gke-specific-configuration-considerations",level:4},{value:"Verification",id:"verification",level:4},{value:"How NGINX Ingress Creates Load Balancers",id:"how-nginx-ingress-creates-load-balancers",level:4},{value:"Step 2: Create IngressClass (Recommended Approach)",id:"step-2-create-ingressclass-recommended-approach",level:3},{value:"Step 3: Create Modern NGINX Ingress",id:"step-3-create-modern-nginx-ingress",level:3},{value:"Advanced Load Balancer Configuration",id:"advanced-load-balancer-configuration",level:4},{value:"Load Balancer Service Configuration Options",id:"load-balancer-service-configuration-options",level:4},{value:"Load Balancer Monitoring and Management",id:"load-balancer-monitoring-and-management",level:4},{value:"Troubleshooting Load Balancer Issues",id:"troubleshooting-load-balancer-issues",level:4},{value:"Using Multiple Load Balancers",id:"using-multiple-load-balancers",level:4},{value:"NGINX Ingress Annotations Explained",id:"nginx-ingress-annotations-explained",level:3},{value:"<strong>Core Annotations (from the example)</strong>",id:"core-annotations-from-the-example",level:4},{value:"<strong>Traffic Management Annotations</strong>",id:"traffic-management-annotations",level:4},{value:"<strong>Security Annotations</strong>",id:"security-annotations",level:4},{value:"<strong>Performance and Timeout Annotations</strong>",id:"performance-and-timeout-annotations",level:4},{value:"<strong>Advanced Routing Annotations</strong>",id:"advanced-routing-annotations",level:4},{value:"<strong>Monitoring and Logging Annotations</strong>",id:"monitoring-and-logging-annotations",level:4},{value:"<strong>Complete Real-World Example</strong>",id:"complete-real-world-example",level:4},{value:"<strong>Troubleshooting Annotations</strong>",id:"troubleshooting-annotations",level:4},{value:"SSL/TLS Configuration",id:"ssltls-configuration",level:2},{value:"Option 1: Google-managed SSL Certificates (GKE Ingress)",id:"option-1-google-managed-ssl-certificates-gke-ingress",level:3},{value:"Option 2: Let&#39;s Encrypt with cert-manager (NGINX)",id:"option-2-lets-encrypt-with-cert-manager-nginx",level:3},{value:"Option 3: Self-signed Certificate",id:"option-3-self-signed-certificate",level:3},{value:"Advanced Configuration",id:"advanced-configuration",level:2},{value:"Path-based Routing",id:"path-based-routing",level:3},{value:"Host-based Routing",id:"host-based-routing",level:3},{value:"Custom Backend Configuration (NGINX)",id:"custom-backend-configuration-nginx",level:3},{value:"Health Checks and Readiness",id:"health-checks-and-readiness",level:3},{value:"Internal Load Balancer Configuration",id:"internal-load-balancer-configuration",level:3},{value:"Use Cases for Internal Load Balancers",id:"use-cases-for-internal-load-balancers",level:4},{value:"Step 1: Create Internal Load Balancer Service",id:"step-1-create-internal-load-balancer-service",level:4},{value:"Step 2: Deploy Internal Application",id:"step-2-deploy-internal-application",level:4},{value:"Step 3: Create Internal Ingress (Optional)",id:"step-3-create-internal-ingress-optional",level:4},{value:"Step 4: Reserve Internal Static IP",id:"step-4-reserve-internal-static-ip",level:4},{value:"Step 5: Configure Firewall Rules",id:"step-5-configure-firewall-rules",level:4},{value:"Step 6: DNS Configuration for Internal Services",id:"step-6-dns-configuration-for-internal-services",level:4},{value:"Step 7: Internal SSL Configuration",id:"step-7-internal-ssl-configuration",level:4},{value:"Step 8: Monitoring Internal Load Balancers",id:"step-8-monitoring-internal-load-balancers",level:4},{value:"Best Practices for Internal Load Balancers",id:"best-practices-for-internal-load-balancers",level:4},{value:"Troubleshooting Internal Load Balancers",id:"troubleshooting-internal-load-balancers",level:4},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"1. Ingress IP Address Not Assigned",id:"1-ingress-ip-address-not-assigned",level:4},{value:"2. SSL Certificate Issues",id:"2-ssl-certificate-issues",level:4},{value:"3. Backend Service Issues",id:"3-backend-service-issues",level:4},{value:"4. DNS Resolution Issues",id:"4-dns-resolution-issues",level:4},{value:"Debugging Commands",id:"debugging-commands",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Resource Management",id:"1-resource-management",level:3},{value:"2. Security",id:"2-security",level:3},{value:"3. Performance",id:"3-performance",level:3},{value:"4. Monitoring",id:"4-monitoring",level:3},{value:"5. Backup and Disaster Recovery",id:"5-backup-and-disaster-recovery",level:3},{value:"5.1 Configuration Backup Strategies",id:"51-configuration-backup-strategies",level:4},{value:"Automated Configuration Export",id:"automated-configuration-export",level:5},{value:"Version Control Integration",id:"version-control-integration",level:5},{value:"5.2 DNS Configuration Documentation",id:"52-dns-configuration-documentation",level:4},{value:"DNS Records Inventory",id:"dns-records-inventory",level:5},{value:"DNS Backup Script",id:"dns-backup-script",level:5},{value:"5.3 Disaster Recovery Procedures",id:"53-disaster-recovery-procedures",level:4},{value:"Multi-Region Setup",id:"multi-region-setup",level:5},{value:"Failover Testing Script",id:"failover-testing-script",level:5},{value:"5.4 Recovery Procedures",id:"54-recovery-procedures",level:4},{value:"Ingress Configuration Recovery",id:"ingress-configuration-recovery",level:5},{value:"DNS Recovery",id:"dns-recovery",level:5},{value:"5.5 Monitoring and Alerting for DR",id:"55-monitoring-and-alerting-for-dr",level:4},{value:"Health Check Monitoring",id:"health-check-monitoring",level:5},{value:"Automated Recovery Triggers",id:"automated-recovery-triggers",level:5},{value:"5.6 Documentation and Runbooks",id:"56-documentation-and-runbooks",level:4},{value:"Disaster Recovery Runbook",id:"disaster-recovery-runbook",level:5},{value:"Conclusion",id:"conclusion",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"gke-ingress-setup-guide",children:"GKE Ingress Setup Guide"})}),"\n",(0,i.jsx)(n.p,{children:"A comprehensive guide to setting up and configuring ingress controllers in Google Kubernetes Engine (GKE)."}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#prerequisites",children:"Prerequisites"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#ingress-controller-options",children:"Ingress Controller Options"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#gke-ingress-google-cloud-load-balancer",children:"GKE Ingress (Google Cloud Load Balancer)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#nginx-ingress-controller",children:"NGINX Ingress Controller"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#ssltls-configuration",children:"SSL/TLS Configuration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#advanced-configuration",children:"Advanced Configuration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#troubleshooting",children:"Troubleshooting"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Ingress in Kubernetes provides HTTP and HTTPS routing to services within your cluster. In GKE, you have several options for ingress controllers, each with their own benefits and use cases."}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.p,{children:"Before setting up ingress, ensure you have:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A running GKE cluster"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"kubectl"})," configured to access your cluster"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"gcloud"})," CLI installed and authenticated"]}),"\n",(0,i.jsx)(n.li,{children:"Domain name pointing to your cluster (for SSL/TLS)"}),"\n",(0,i.jsx)(n.li,{children:"Required IAM permissions"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"required-iam-permissions",children:"Required IAM Permissions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Grant necessary permissions for ingress setup\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n    --member="serviceAccount:SERVICE_ACCOUNT_EMAIL" \\\n    --role="roles/compute.loadBalancerAdmin"\n\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n    --member="serviceAccount:SERVICE_ACCOUNT_EMAIL" \\\n    --role="roles/compute.securityAdmin"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"ingress-controller-options",children:"Ingress Controller Options"}),"\n",(0,i.jsx)(n.h3,{id:"1-gke-ingress-google-cloud-load-balancer",children:"1. GKE Ingress (Google Cloud Load Balancer)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),": Native integration, automatic SSL certificates, global load balancing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cons"}),": Limited customization, Google Cloud specific"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Simple setups, Google Cloud native solutions"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-nginx-ingress-controller",children:"2. NGINX Ingress Controller"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),": Highly customizable, portable across clouds, rich feature set"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cons"}),": Additional management overhead, requires more configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Complex routing requirements, multi-cloud deployments"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"gke-ingress-google-cloud-load-balancer",children:"GKE Ingress (Google Cloud Load Balancer)"}),"\n",(0,i.jsx)(n.h3,{id:"step-1-enable-required-apis",children:"Step 1: Enable Required APIs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Enable necessary Google Cloud APIs\ngcloud services enable compute.googleapis.com\ngcloud services enable container.googleapis.com\ngcloud services enable certificatemanager.googleapis.com\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-create-a-sample-application",children:"Step 2: Create a Sample Application"}),"\n",(0,i.jsx)(n.p,{children:"Create a deployment and service:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# app-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app\n  labels:\n    app: web-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web-app\n  template:\n    metadata:\n      labels:\n        app: web-app\n    spec:\n      containers:\n      - name: web-app\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        resources:\n          requests:\n            memory: "64Mi"\n            cpu: "250m"\n          limits:\n            memory: "128Mi"\n            cpu: "500m"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: web-app-service\n  annotations:\n    cloud.google.com/neg: \'{"ingress": true}\'\nspec:\n  type: ClusterIP\n  selector:\n    app: web-app\n  ports:\n  - port: 80\n    targetPort: 80\n    protocol: TCP\n'})}),"\n",(0,i.jsx)(n.p,{children:"Apply the configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f app-deployment.yaml\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-3-create-gke-ingress",children:"Step 3: Create GKE Ingress"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# gke-ingress.yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-app-ingress\n  annotations:\n    kubernetes.io/ingress.class: "gce"\n    kubernetes.io/ingress.global-static-ip-name: "web-app-ip"\n    networking.gke.io/managed-certificates: "web-app-ssl-cert"\n    kubernetes.io/ingress.allow-http: "false"\nspec:\n  rules:\n  - host: your-domain.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-app-service\n            port:\n              number: 80\n'})}),"\n",(0,i.jsx)(n.h3,{id:"step-4-reserve-static-ip",children:"Step 4: Reserve Static IP"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Reserve a global static IP\ngcloud compute addresses create web-app-ip --global\n\n# Get the IP address\ngcloud compute addresses describe web-app-ip --global --format="value(address)"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"step-5-create-managed-ssl-certificate",children:"Step 5: Create Managed SSL Certificate"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# managed-cert.yaml\napiVersion: networking.gke.io/v1\nkind: ManagedCertificate\nmetadata:\n  name: web-app-ssl-cert\nspec:\n  domains:\n    - your-domain.com\n    - www.your-domain.com\n"})}),"\n",(0,i.jsx)(n.p,{children:"Apply the configurations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f managed-cert.yaml\nkubectl apply -f gke-ingress.yaml\n"})}),"\n",(0,i.jsx)(n.h2,{id:"nginx-ingress-controller",children:"NGINX Ingress Controller"}),"\n",(0,i.jsx)(n.h3,{id:"step-1-install-nginx-ingress-controller",children:"Step 1: Install NGINX Ingress Controller"}),"\n",(0,i.jsx)(n.h4,{id:"prerequisites-for-gke",children:"Prerequisites for GKE"}),"\n",(0,i.jsx)(n.p,{children:"First, ensure your user has the necessary permissions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Grant cluster-admin permissions (required for NGINX installation)\nkubectl create clusterrolebinding cluster-admin-binding \\\n  --clusterrole cluster-admin \\\n  --user $(gcloud config get-value account)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"installation-methods",children:"Installation Methods"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Option A: Using Helm (Recommended)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Add NGINX Ingress Helm repository\nhelm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo update\n\n# Install NGINX Ingress Controller with GKE-optimized settings\nhelm install ingress-nginx ingress-nginx/ingress-nginx \\\n  --namespace ingress-nginx \\\n  --create-namespace \\\n  --set controller.service.type=LoadBalancer \\\n  --set controller.service.externalTrafficPolicy=Local \\\n  --set controller.config.use-proxy-protocol=false \\\n  --set controller.service.annotations."cloud\\.google\\.com/load-balancer-type"="External" \\\n  --set controller.service.annotations."cloud\\.google\\.com/neg"=\'{"ingress": true}\' \\\n  --set controller.metrics.enabled=true \\\n  --set controller.podSecurityContext.runAsNonRoot=true \\\n  --set controller.podSecurityContext.runAsUser=101 \\\n  --set controller.podSecurityContext.fsGroup=101\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Option B: Using kubectl with YAML manifest"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Install using the official GKE-compatible manifest\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.13.3/deploy/static/provider/cloud/deploy.yaml\n"})}),"\n",(0,i.jsx)(n.h4,{id:"gke-specific-configuration-considerations",children:"GKE-Specific Configuration Considerations"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For Private GKE Clusters:"})}),"\n",(0,i.jsx)(n.p,{children:"Private clusters require additional firewall rules for the admission webhook:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Add firewall rule for private clusters (webhook communication)\ngcloud compute firewall-rules create allow-ingress-nginx-admission \\\n  --direction=INGRESS \\\n  --priority=1000 \\\n  --network=default \\\n  --action=ALLOW \\\n  --rules=tcp:8443 \\\n  --source-ranges=172.16.0.0/12 \\\n  --target-tags=gke-node\n\n# Replace source-ranges with your cluster's master CIDR\n# You can find this with: gcloud container clusters describe CLUSTER_NAME --zone=ZONE\n"})}),"\n",(0,i.jsx)(n.h4,{id:"verification",children:"Verification"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Wait for the controller to be ready\nkubectl wait --namespace ingress-nginx \\\n  --for=condition=ready pod \\\n  --selector=app.kubernetes.io/component=controller \\\n  --timeout=120s\n\n# Check the LoadBalancer service\nkubectl get service ingress-nginx-controller -n ingress-nginx\n\n# Expected output should show an EXTERNAL-IP\n# NAME                                 TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)\n# ingress-nginx-controller             LoadBalancer   10.48.15.200   34.123.45.67    80:32000/TCP,443:32001/TCP\n"})}),"\n",(0,i.jsx)(n.h4,{id:"how-nginx-ingress-creates-load-balancers",children:"How NGINX Ingress Creates Load Balancers"}),"\n",(0,i.jsxs)(n.p,{children:["When you install NGINX Ingress Controller with ",(0,i.jsx)(n.code,{children:"controller.service.type=LoadBalancer"}),", it automatically creates a Google Cloud Load Balancer. Here's how the process works:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Service Creation Process:"})}),"\n",(0,i.jsxs)(n.p,{children:["The NGINX controller creates a Kubernetes Service of type ",(0,i.jsx)(n.code,{children:"LoadBalancer"}),", which triggers GKE to provision a Google Cloud Load Balancer automatically."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Load Balancer Components Created:"})}),"\n",(0,i.jsx)(n.p,{children:"When the NGINX controller starts, GKE automatically creates these GCP resources:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"External Load Balancer"}),": Routes traffic from internet to NGINX pods"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backend Service"}),": Manages health checks and traffic distribution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Target Pool/Instance Groups"}),": Contains GKE nodes running NGINX pods"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Firewall Rules"}),": Allow traffic on ports 80 and 443"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Health Checks"}),": Monitor NGINX controller health on port 10254"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Verify Load Balancer Creation:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Get the external IP address\nEXTERNAL_IP=$(kubectl get service ingress-nginx-controller \\\n  -n ingress-nginx \\\n  -o jsonpath=\'{.status.loadBalancer.ingress[0].ip}\')\n\necho "Load Balancer External IP: $EXTERNAL_IP"\n\n# Test load balancer connectivity\ncurl -k https://$EXTERNAL_IP/healthz\n\n# Check load balancer components in GCP\ngcloud compute forwarding-rules list --filter="name~k8s"\ngcloud compute backend-services list --filter="name~k8s"\ngcloud compute health-checks list --filter="name~k8s"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-create-ingressclass-recommended-approach",children:"Step 2: Create IngressClass (Recommended Approach)"}),"\n",(0,i.jsx)(n.p,{children:"Modern Kubernetes (1.19+) uses IngressClass instead of the deprecated annotation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# nginx-ingress-class.yaml\napiVersion: networking.k8s.io/v1\nkind: IngressClass\nmetadata:\n  name: nginx\n  annotations:\n    ingressclass.kubernetes.io/is-default-class: "true"\nspec:\n  controller: k8s.io/ingress-nginx\n'})}),"\n",(0,i.jsx)(n.p,{children:"Apply the IngressClass:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f nginx-ingress-class.yaml\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-3-create-modern-nginx-ingress",children:"Step 3: Create Modern NGINX Ingress"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Using ingressClassName (Recommended):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# nginx-ingress-modern.yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-app-nginx-ingress\n  namespace: default\n  annotations:\n    # Modern NGINX annotations\n    nginx.ingress.kubernetes.io/ssl-redirect: "true"\n    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"\n    cert-manager.io/cluster-issuer: "letsencrypt-prod"\n    nginx.ingress.kubernetes.io/proxy-body-size: "10m"\n    nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"\n    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"\n    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"\nspec:\n  ingressClassName: nginx  # Modern way instead of annotation\n  tls:\n  - hosts:\n    - your-domain.com\n    secretName: web-app-tls\n  rules:\n  - host: your-domain.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-app-service\n            port:\n              number: 80\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Legacy annotation method (for compatibility):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# nginx-ingress-legacy.yaml  \napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-app-nginx-ingress-legacy\n  namespace: default\n  annotations:\n    kubernetes.io/ingress.class: "nginx"  # Legacy annotation\n    nginx.ingress.kubernetes.io/ssl-redirect: "true"\n    cert-manager.io/cluster-issuer: "letsencrypt-prod"\nspec:\n  tls:\n  - hosts:\n    - your-domain.com\n    secretName: web-app-tls\n  rules:\n  - host: your-domain.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-app-service\n            port:\n              number: 80\n'})}),"\n",(0,i.jsx)(n.h4,{id:"advanced-load-balancer-configuration",children:"Advanced Load Balancer Configuration"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Internal Load Balancer for NGINX:"})}),"\n",(0,i.jsx)(n.p,{children:"If you need an internal load balancer (only accessible within VPC):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Install NGINX with internal load balancer\nhelm install ingress-nginx-internal ingress-nginx/ingress-nginx \\\n  --namespace ingress-nginx-internal \\\n  --create-namespace \\\n  --set controller.service.type=LoadBalancer \\\n  --set controller.service.annotations."cloud\\.google\\.com/load-balancer-type"="Internal" \\\n  --set controller.service.annotations."cloud\\.google\\.com/load-balancer-subnet"="internal-subnet" \\\n  --set controller.ingressClass="nginx-internal" \\\n  --set controller.ingressClassResource.name="nginx-internal"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Regional Load Balancer Configuration:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Install with optimized regional load balancer\nhelm install ingress-nginx ingress-nginx/ingress-nginx \\\n  --namespace ingress-nginx \\\n  --create-namespace \\\n  --set controller.service.type=LoadBalancer \\\n  --set controller.service.externalTrafficPolicy=Local \\\n  --set controller.service.annotations."cloud\\.google\\.com/load-balancer-type"="External" \\\n  --set controller.service.annotations."cloud\\.google\\.com/neg"=\'{"ingress": true}\' \\\n  --set controller.service.annotations."cloud\\.google\\.com/backend-config"=\'{"default": "nginx-backend-config"}\'\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Static IP Assignment:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Reserve a global static IP for the load balancer\ngcloud compute addresses create nginx-static-ip --global\n\n# Get the reserved IP\nSTATIC_IP=$(gcloud compute addresses describe nginx-static-ip --global --format="value(address)")\n\n# Install NGINX with static IP\nhelm install ingress-nginx ingress-nginx/ingress-nginx \\\n  --namespace ingress-nginx \\\n  --create-namespace \\\n  --set controller.service.type=LoadBalancer \\\n  --set controller.service.loadBalancerIP="$STATIC_IP" \\\n  --set controller.service.annotations."cloud\\.google\\.com/load-balancer-type"="External"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"load-balancer-service-configuration-options",children:"Load Balancer Service Configuration Options"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Complete Service Configuration:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# nginx-lb-service-modern.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: ingress-nginx-controller\n  namespace: ingress-nginx\n  annotations:\n    # Load balancer type (External or Internal)\n    cloud.google.com/load-balancer-type: "External"\n    \n    # Enable NEG for better performance and health checks\n    cloud.google.com/neg: \'{"ingress": true}\'\n    \n    # Static IP (optional)\n    # cloud.google.com/load-balancer-ip: "34.123.45.67"\n    \n    # Backend configuration\n    cloud.google.com/backend-config: \'{"default": "nginx-backend-config"}\'\n    \n    # Load balancer name (optional, for easier identification)\n    cloud.google.com/load-balancer-name: "nginx-ingress-lb"\nspec:\n  type: LoadBalancer\n  externalTrafficPolicy: Local  # Preserves source IP and reduces latency\n  sessionAffinity: None\n  ipFamilyPolicy: SingleStack\n  ipFamilies:\n  - IPv4\n  ports:\n  - name: http\n    port: 80\n    protocol: TCP\n    targetPort: http\n    appProtocol: http\n  - name: https\n    port: 443\n    protocol: TCP\n    targetPort: https\n    appProtocol: https\n  selector:\n    app.kubernetes.io/component: controller\n    app.kubernetes.io/instance: ingress-nginx\n    app.kubernetes.io/name: ingress-nginx\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Enhanced Backend Configuration for NGINX Load Balancer:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# nginx-backend-config-modern.yaml\napiVersion: cloud.google.com/v1\nkind: BackendConfig\nmetadata:\n  name: nginx-backend-config\n  namespace: ingress-nginx\nspec:\n  # Health check configuration optimized for NGINX\n  healthCheck:\n    checkIntervalSec: 10\n    timeoutSec: 5\n    healthyThreshold: 2\n    unhealthyThreshold: 3\n    type: HTTP\n    requestPath: /healthz\n    port: 10254\n  \n  # Connection draining for graceful updates\n  connectionDraining:\n    drainingTimeoutSec: 300\n  \n  # Session affinity (optional, usually not needed for ingress)\n  sessionAffinity:\n    affinityType: "NONE"\n  \n  # Security policy reference (optional)\n  # securityPolicy:\n  #   name: "nginx-security-policy"\n  \n  # Logging configuration\n  logging:\n    enable: true\n    sampleRate: 0.1  # 10% sampling for cost optimization\n  \n  # Cloud CDN configuration (optional)\n  # cdn:\n  #   enabled: true\n  #   cachePolicy:\n  #     includeHost: true\n  #     includeProtocol: true\n  #     includeQueryString: false\n'})}),"\n",(0,i.jsx)(n.h4,{id:"load-balancer-monitoring-and-management",children:"Load Balancer Monitoring and Management"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Monitor Load Balancer Status:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Check load balancer service status\nkubectl get service ingress-nginx-controller -n ingress-nginx -w\n\n# Get detailed service information  \nkubectl describe service ingress-nginx-controller -n ingress-nginx\n\n# Check load balancer events\nkubectl get events -n ingress-nginx --sort-by=.metadata.creationTimestamp\n\n# Monitor NGINX controller logs\nkubectl logs -f deployment/ingress-nginx-controller -n ingress-nginx\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Load Balancer Health Checks:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Test load balancer health endpoint\nEXTERNAL_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\n\n# Test health check endpoint (should return 200)\ncurl -v http://$EXTERNAL_IP/healthz\n\n# Check metrics endpoint\ncurl http://$EXTERNAL_IP:10254/metrics\n\n# Test specific ingress rule\ncurl -H \"Host: your-domain.com\" http://$EXTERNAL_IP/\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Load Balancer Scaling and Performance:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Scale NGINX controller replicas for high availability\nkubectl scale deployment ingress-nginx-controller \\\n  --replicas=3 \\\n  -n ingress-nginx\n\n# Enable Horizontal Pod Autoscaler\nkubectl autoscale deployment ingress-nginx-controller \\\n  --cpu-percent=70 \\\n  --min=2 \\\n  --max=10 \\\n  -n ingress-nginx\n\n# Check HPA status\nkubectl get hpa -n ingress-nginx\n\n# Monitor resource usage\nkubectl top pods -n ingress-nginx\n"})}),"\n",(0,i.jsx)(n.h4,{id:"troubleshooting-load-balancer-issues",children:"Troubleshooting Load Balancer Issues"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Load Balancer Not Getting External IP:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Check service events and status\nkubectl describe service ingress-nginx-controller -n ingress-nginx\n\n# Check if nodes have proper network tags\nkubectl get nodes -o wide\n\n# Verify firewall rules for GKE\ngcloud compute firewall-rules list --filter="name~k8s"\n\n# Check regional quotas\ngcloud compute project-info describe --project=PROJECT_ID\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Load Balancer Health Check Failures:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Check NGINX controller pod status\nkubectl get pods -n ingress-nginx -o wide\n\n# Check controller logs for errors\nkubectl logs deployment/ingress-nginx-controller -n ingress-nginx --tail=100\n\n# Test health check endpoint directly via port-forward\nkubectl port-forward -n ingress-nginx deployment/ingress-nginx-controller 8080:10254\ncurl http://localhost:8080/healthz\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Performance Optimization:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# nginx-performance-config.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: nginx-configuration\n  namespace: ingress-nginx\ndata:\n  # Worker process optimization\n  worker-processes: "auto"\n  worker-connections: "16384"\n  worker-rlimit-nofile: "65536"\n  \n  # Keep-alive settings\n  keep-alive: "75"\n  keep-alive-requests: "1000"\n  \n  # Buffer sizes optimized for GKE\n  client-body-buffer-size: "128k"\n  client-header-buffer-size: "1k"\n  large-client-header-buffers: "4 8k"\n  client-max-body-size: "50m"\n  \n  # Proxy settings\n  proxy-connect-timeout: "60"\n  proxy-send-timeout: "60"  \n  proxy-read-timeout: "60"\n  proxy-buffers-number: "8"\n  proxy-buffer-size: "16k"\n  \n  # Enable gzip compression\n  enable-gzip: "true"\n  gzip-types: "text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript"\n  \n  # SSL configuration\n  ssl-protocols: "TLSv1.2 TLSv1.3"\n  ssl-ciphers: "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384"\n  ssl-prefer-server-ciphers: "on"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"using-multiple-load-balancers",children:"Using Multiple Load Balancers"}),"\n",(0,i.jsx)(n.p,{children:"You can create multiple NGINX controllers with different load balancers for different purposes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Public-facing load balancer\nhelm install nginx-public ingress-nginx/ingress-nginx \\\n  --namespace nginx-public \\\n  --create-namespace \\\n  --set controller.service.type=LoadBalancer \\\n  --set controller.ingressClass="nginx-public" \\\n  --set controller.ingressClassResource.name="nginx-public" \\\n  --set controller.service.annotations."cloud\\.google\\.com/load-balancer-type"="External"\n\n# Internal load balancer  \nhelm install nginx-internal ingress-nginx/ingress-nginx \\\n  --namespace nginx-internal \\\n  --create-namespace \\\n  --set controller.service.type=LoadBalancer \\\n  --set controller.ingressClass="nginx-internal" \\\n  --set controller.ingressClassResource.name="nginx-internal" \\\n  --set controller.service.annotations."cloud\\.google\\.com/load-balancer-type"="Internal"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Create corresponding IngressClass resources:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# multiple-ingress-classes.yaml\napiVersion: networking.k8s.io/v1\nkind: IngressClass\nmetadata:\n  name: nginx-public\nspec:\n  controller: k8s.io/ingress-nginx\n---\napiVersion: networking.k8s.io/v1\nkind: IngressClass\nmetadata:\n  name: nginx-internal\nspec:\n  controller: k8s.io/ingress-nginx\n---\n# Public ingress example\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: public-app-ingress\nspec:\n  ingressClassName: nginx-public\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: public-app-service\n            port:\n              number: 80\n---\n# Internal ingress example\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: internal-app-ingress\nspec:\n  ingressClassName: nginx-internal\n  rules:\n  - host: internal-api.company.local\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: internal-app-service\n            port:\n              number: 80\n"})}),"\n",(0,i.jsx)(n.h3,{id:"nginx-ingress-annotations-explained",children:"NGINX Ingress Annotations Explained"}),"\n",(0,i.jsx)(n.p,{children:"The annotations in the above example control how NGINX processes requests. Here's a detailed explanation of each annotation and many other commonly used ones:"}),"\n",(0,i.jsx)(n.h4,{id:"core-annotations-from-the-example",children:(0,i.jsx)(n.strong,{children:"Core Annotations (from the example)"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:'kubernetes.io/ingress.class: "nginx"'})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Specifies which ingress controller should handle this ingress"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage"}),": Tells Kubernetes to use the NGINX Ingress Controller"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": ",(0,i.jsx)(n.code,{children:'kubernetes.io/ingress.class: "nginx"'})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Note"}),": In newer Kubernetes versions, use ",(0,i.jsx)(n.code,{children:"spec.ingressClassName: nginx"})," instead"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/rewrite-target: /"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Rewrites the request path before forwarding to the backend"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage"}),": Removes path prefixes or transforms URLs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": Request to ",(0,i.jsx)(n.code,{children:"/api/v1/users"})," becomes ",(0,i.jsx)(n.code,{children:"/users"})," if path is ",(0,i.jsx)(n.code,{children:"/api/v1"})," and rewrite-target is ",(0,i.jsx)(n.code,{children:"/"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advanced"}),": Use capture groups: ",(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/rewrite-target: /$2"})," with path ",(0,i.jsx)(n.code,{children:"/something(/|$)(.*)"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:'nginx.ingress.kubernetes.io/ssl-redirect: "true"'})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Automatically redirects HTTP requests to HTTPS"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage"}),": Forces secure connections for all traffic"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Values"}),": ",(0,i.jsx)(n.code,{children:'"true"'})," (redirect) or ",(0,i.jsx)(n.code,{children:'"false"'})," (allow HTTP)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Default"}),": Depends on ingress controller configuration"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:'cert-manager.io/cluster-issuer: "letsencrypt-prod"'})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Automatically provisions SSL certificates using cert-manager"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage"}),": References a ClusterIssuer resource for certificate generation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": Uses Let's Encrypt production environment for certificates"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Alternative"}),": ",(0,i.jsx)(n.code,{children:'cert-manager.io/issuer: "my-issuer"'})," for namespace-scoped issuer"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"traffic-management-annotations",children:(0,i.jsx)(n.strong,{children:"Traffic Management Annotations"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Complete traffic management example\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: traffic-management-ingress\n  annotations:\n    # Load balancing configuration\n    nginx.ingress.kubernetes.io/upstream-hash-by: "$request_uri"\n    nginx.ingress.kubernetes.io/load-balance: "ip_hash"\n    \n    # Session affinity\n    nginx.ingress.kubernetes.io/affinity: "cookie"\n    nginx.ingress.kubernetes.io/affinity-mode: "persistent"\n    nginx.ingress.kubernetes.io/session-cookie-name: "NGINX_AFFINITY"\n    nginx.ingress.kubernetes.io/session-cookie-expires: "86400"\n    nginx.ingress.kubernetes.io/session-cookie-max-age: "86400"\n    nginx.ingress.kubernetes.io/session-cookie-path: "/"\n    \n    # Rate limiting\n    nginx.ingress.kubernetes.io/rate-limit: "100"\n    nginx.ingress.kubernetes.io/rate-limit-window: "1m"\n    nginx.ingress.kubernetes.io/rate-limit-connections: "10"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Load Balancing Annotations:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/load-balance"})}),": Algorithm for distributing requests"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Values: ",(0,i.jsx)(n.code,{children:"round_robin"})," (default), ",(0,i.jsx)(n.code,{children:"least_conn"}),", ",(0,i.jsx)(n.code,{children:"ip_hash"}),", ",(0,i.jsx)(n.code,{children:"random"})]}),"\n",(0,i.jsxs)(n.li,{children:["Example: ",(0,i.jsx)(n.code,{children:"ip_hash"})," ensures same client always goes to same backend"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/upstream-hash-by"})}),": Custom hash key for load balancing"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Values: ",(0,i.jsx)(n.code,{children:'"$request_uri"'}),", ",(0,i.jsx)(n.code,{children:'"$remote_addr"'}),", ",(0,i.jsx)(n.code,{children:'"$http_x_forwarded_for"'})]}),"\n",(0,i.jsx)(n.li,{children:"Example: Hash by URI to ensure same endpoint for same request"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Session Affinity:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:'nginx.ingress.kubernetes.io/affinity: "cookie"'})}),": Enable session persistence"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/session-cookie-name"})}),": Cookie name for affinity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/session-cookie-expires"})}),": Cookie expiration time"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Rate Limiting:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/rate-limit"})}),": Requests per minute per IP"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/rate-limit-window"})}),": Time window for rate limiting"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/rate-limit-connections"})}),": Concurrent connections per IP"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"security-annotations",children:(0,i.jsx)(n.strong,{children:"Security Annotations"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Security-focused ingress\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: security-ingress\n  annotations:\n    # CORS configuration\n    nginx.ingress.kubernetes.io/enable-cors: "true"\n    nginx.ingress.kubernetes.io/cors-allow-origin: "https://trusted-domain.com"\n    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE"\n    nginx.ingress.kubernetes.io/cors-allow-headers: "Authorization, Content-Type"\n    nginx.ingress.kubernetes.io/cors-allow-credentials: "true"\n    \n    # Authentication\n    nginx.ingress.kubernetes.io/auth-type: "basic"\n    nginx.ingress.kubernetes.io/auth-secret: "basic-auth-secret"\n    nginx.ingress.kubernetes.io/auth-realm: "Authentication Required"\n    \n    # Security headers\n    nginx.ingress.kubernetes.io/server-snippet: |\n      add_header X-Frame-Options "SAMEORIGIN" always;\n      add_header X-Content-Type-Options "nosniff" always;\n      add_header X-XSS-Protection "1; mode=block" always;\n      add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;\n    \n    # Client certificate authentication\n    nginx.ingress.kubernetes.io/auth-tls-verify-client: "on"\n    nginx.ingress.kubernetes.io/auth-tls-secret: "client-ca-secret"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"CORS Configuration:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/enable-cors"})}),": Enable Cross-Origin Resource Sharing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/cors-allow-origin"})}),": Allowed origins for CORS"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/cors-allow-methods"})}),": Allowed HTTP methods"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/cors-allow-headers"})}),": Allowed request headers"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Authentication:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/auth-type"})}),": Authentication method (",(0,i.jsx)(n.code,{children:"basic"}),", ",(0,i.jsx)(n.code,{children:"digest"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/auth-secret"})}),": Secret containing auth credentials"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/auth-realm"})}),": Authentication realm message"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"performance-and-timeout-annotations",children:(0,i.jsx)(n.strong,{children:"Performance and Timeout Annotations"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Performance optimization ingress\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: performance-ingress\n  annotations:\n    # Timeout configurations\n    nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"\n    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"\n    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"\n    nginx.ingress.kubernetes.io/proxy-next-upstream-timeout: "600"\n    \n    # Buffer configurations\n    nginx.ingress.kubernetes.io/proxy-body-size: "32m"\n    nginx.ingress.kubernetes.io/proxy-buffer-size: "16k"\n    nginx.ingress.kubernetes.io/proxy-buffers-number: "8"\n    \n    # Connection management\n    nginx.ingress.kubernetes.io/upstream-keepalive-connections: "100"\n    nginx.ingress.kubernetes.io/upstream-keepalive-timeout: "60"\n    nginx.ingress.kubernetes.io/upstream-keepalive-requests: "1000"\n    \n    # Compression\n    nginx.ingress.kubernetes.io/enable-gzip: "true"\n    nginx.ingress.kubernetes.io/gzip-types: "text/plain,text/css,application/json,application/javascript"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Timeout Settings:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/proxy-connect-timeout"})}),": Time to establish backend connection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/proxy-send-timeout"})}),": Time to send request to backend"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/proxy-read-timeout"})}),": Time to read response from backend"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/proxy-next-upstream-timeout"})}),": Time before trying next upstream"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Buffer Settings:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/proxy-body-size"})}),": Maximum request body size"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/proxy-buffer-size"})}),": Buffer size for response headers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/proxy-buffers-number"})}),": Number of buffers for response"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"advanced-routing-annotations",children:(0,i.jsx)(n.strong,{children:"Advanced Routing Annotations"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Advanced routing ingress\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: advanced-routing-ingress\n  annotations:\n    # Custom backend selection\n    nginx.ingress.kubernetes.io/canary: "true"\n    nginx.ingress.kubernetes.io/canary-by-header: "X-Canary"\n    nginx.ingress.kubernetes.io/canary-by-header-value: "always"\n    nginx.ingress.kubernetes.io/canary-weight: "30"\n    \n    # Request modification\n    nginx.ingress.kubernetes.io/proxy-set-headers: "custom-headers"\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      more_set_headers "X-Custom-Header: custom-value";\n      set $custom_var "custom_value";\n    \n    # Response modification\n    nginx.ingress.kubernetes.io/server-snippet: |\n      location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg)$ {\n        expires 1y;\n        add_header Cache-Control "public, immutable";\n      }\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Canary Deployments:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/canary"})}),": Enable canary deployment for this ingress"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/canary-weight"})}),": Percentage of traffic to route to canary"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/canary-by-header"})}),": Route based on header presence"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/canary-by-cookie"})}),": Route based on cookie value"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Header Manipulation:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/proxy-set-headers"})}),": Reference to ConfigMap with headers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/configuration-snippet"})}),": Custom NGINX configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/server-snippet"})}),": Server-level NGINX configuration"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"monitoring-and-logging-annotations",children:(0,i.jsx)(n.strong,{children:"Monitoring and Logging Annotations"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Monitoring ingress\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: monitoring-ingress\n  annotations:\n    # Access logging\n    nginx.ingress.kubernetes.io/enable-access-log: "true"\n    nginx.ingress.kubernetes.io/access-log-path: "/var/log/nginx/access.log"\n    \n    # Custom log format\n    nginx.ingress.kubernetes.io/log-format-escape-json: "true"\n    nginx.ingress.kubernetes.io/log-format-upstream: |\n      {"time": "$time_iso8601", "remote_addr": "$remote_addr", \n       "request": "$request", "status": $status, "bytes": $bytes_sent,\n       "referer": "$http_referer", "agent": "$http_user_agent",\n       "request_time": $request_time, "upstream_time": "$upstream_response_time"}\n    \n    # Metrics exposure\n    nginx.ingress.kubernetes.io/enable-metrics: "true"\n    nginx.ingress.kubernetes.io/metrics-port: "10254"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"complete-real-world-example",children:(0,i.jsx)(n.strong,{children:"Complete Real-World Example"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Production-ready ingress with comprehensive annotations\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: production-app-ingress\n  namespace: production\n  annotations:\n    # Basic configuration\n    kubernetes.io/ingress.class: "nginx"\n    nginx.ingress.kubernetes.io/ssl-redirect: "true"\n    cert-manager.io/cluster-issuer: "letsencrypt-prod"\n    \n    # Performance optimization\n    nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"\n    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"\n    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"\n    nginx.ingress.kubernetes.io/proxy-body-size: "10m"\n    nginx.ingress.kubernetes.io/enable-gzip: "true"\n    \n    # Security\n    nginx.ingress.kubernetes.io/enable-cors: "true"\n    nginx.ingress.kubernetes.io/cors-allow-origin: "https://app.example.com"\n    nginx.ingress.kubernetes.io/cors-allow-credentials: "true"\n    \n    # Rate limiting\n    nginx.ingress.kubernetes.io/rate-limit: "1000"\n    nginx.ingress.kubernetes.io/rate-limit-window: "1m"\n    \n    # Load balancing\n    nginx.ingress.kubernetes.io/load-balance: "least_conn"\n    \n    # Custom headers\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      more_set_headers "X-Frame-Options: SAMEORIGIN";\n      more_set_headers "X-Content-Type-Options: nosniff";\n      more_set_headers "X-XSS-Protection: 1; mode=block";\nspec:\n  tls:\n  - hosts:\n    - api.example.com\n    secretName: production-tls\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: production-app-service\n            port:\n              number: 80\n'})}),"\n",(0,i.jsx)(n.h4,{id:"troubleshooting-annotations",children:(0,i.jsx)(n.strong,{children:"Troubleshooting Annotations"})}),"\n",(0,i.jsx)(n.p,{children:"When debugging NGINX ingress issues, these annotations can be helpful:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Debug annotations\nnginx.ingress.kubernetes.io/enable-access-log: "true"\nnginx.ingress.kubernetes.io/enable-rewrite-log: "true"\nnginx.ingress.kubernetes.io/proxy-set-headers: "debug-headers"\nnginx.ingress.kubernetes.io/configuration-snippet: |\n  # Log all request headers for debugging\n  access_log /var/log/nginx/debug.log debug;\n'})}),"\n",(0,i.jsx)(n.p,{children:"These annotations provide fine-grained control over NGINX behavior, allowing you to optimize performance, enhance security, and customize routing for your specific application needs."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\n### Step 3: Install cert-manager for SSL\n\n```bash\n# Install cert-manager\nkubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml\n\n# Create ClusterIssuer for Let's Encrypt\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# cluster-issuer.yaml\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: letsencrypt-prod\nspec:\n  acme:\n    server: https://acme-v02.api.letsencrypt.org/directory\n    email: your-email@example.com\n    privateKeySecretRef:\n      name: letsencrypt-prod\n    solvers:\n    - http01:\n        ingress:\n          class: nginx\n"})}),"\n",(0,i.jsx)(n.p,{children:"Apply the configurations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f cluster-issuer.yaml\nkubectl apply -f nginx-ingress.yaml\n"})}),"\n",(0,i.jsx)(n.h2,{id:"ssltls-configuration",children:"SSL/TLS Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"option-1-google-managed-ssl-certificates-gke-ingress",children:"Option 1: Google-managed SSL Certificates (GKE Ingress)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.gke.io/v1\nkind: ManagedCertificate\nmetadata:\n  name: ssl-certificate\nspec:\n  domains:\n  - your-domain.com\n  - www.your-domain.com\n"})}),"\n",(0,i.jsx)(n.h3,{id:"option-2-lets-encrypt-with-cert-manager-nginx",children:"Option 2: Let's Encrypt with cert-manager (NGINX)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: web-app-tls\nspec:\n  secretName: web-app-tls\n  issuerRef:\n    name: letsencrypt-prod\n    kind: ClusterIssuer\n  dnsNames:\n  - your-domain.com\n  - www.your-domain.com\n"})}),"\n",(0,i.jsx)(n.h3,{id:"option-3-self-signed-certificate",children:"Option 3: Self-signed Certificate"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Generate self-signed certificate\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n  -keyout tls.key -out tls.crt -subj "/CN=your-domain.com"\n\n# Create Kubernetes secret\nkubectl create secret tls web-app-tls --key tls.key --cert tls.crt\n'})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-configuration",children:"Advanced Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"path-based-routing",children:"Path-based Routing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: path-based-ingress\nspec:\n  rules:\n  - host: your-domain.com\n    http:\n      paths:\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 80\n      - path: /web\n        pathType: Prefix\n        backend:\n          service:\n            name: web-service\n            port:\n              number: 80\n"})}),"\n",(0,i.jsx)(n.h3,{id:"host-based-routing",children:"Host-based Routing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: host-based-ingress\nspec:\n  rules:\n  - host: api.your-domain.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 80\n  - host: web.your-domain.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-service\n            port:\n              number: 80\n"})}),"\n",(0,i.jsx)(n.h3,{id:"custom-backend-configuration-nginx",children:"Custom Backend Configuration (NGINX)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: custom-backend-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/upstream-hash-by: "$request_uri"\n    nginx.ingress.kubernetes.io/load-balance: "ip_hash"\n    nginx.ingress.kubernetes.io/rate-limit: "100"\n    nginx.ingress.kubernetes.io/rate-limit-window: "1m"\nspec:\n  rules:\n  - host: your-domain.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-app-service\n            port:\n              number: 80\n'})}),"\n",(0,i.jsx)(n.h3,{id:"health-checks-and-readiness",children:"Health Checks and Readiness"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Add health check annotations for GKE\napiVersion: v1\nkind: Service\nmetadata:\n  name: web-app-service\n  annotations:\n    cloud.google.com/neg: \'{"ingress": true}\'\n    cloud.google.com/backend-config: \'{"default": "web-app-backendconfig"}\'\nspec:\n  type: ClusterIP\n  selector:\n    app: web-app\n  ports:\n  - port: 80\n    targetPort: 80\n---\napiVersion: cloud.google.com/v1\nkind: BackendConfig\nmetadata:\n  name: web-app-backendconfig\nspec:\n  healthCheck:\n    checkIntervalSec: 15\n    timeoutSec: 15\n    healthyThreshold: 1\n    unhealthyThreshold: 3\n    type: HTTP\n    requestPath: /health\n'})}),"\n",(0,i.jsx)(n.h3,{id:"internal-load-balancer-configuration",children:"Internal Load Balancer Configuration"}),"\n",(0,i.jsx)(n.p,{children:"Internal load balancers are ideal for private applications that should only be accessible within your VPC network or from on-premises networks connected via VPN or Interconnect."}),"\n",(0,i.jsx)(n.h4,{id:"use-cases-for-internal-load-balancers",children:"Use Cases for Internal Load Balancers"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Internal APIs"}),": Backend services that should not be exposed to the internet"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Admin Interfaces"}),": Management dashboards accessible only from corporate networks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Database Connections"}),": Internal database proxy services"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Microservices Communication"}),": Service-to-service communication within VPC"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"step-1-create-internal-load-balancer-service",children:"Step 1: Create Internal Load Balancer Service"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# internal-service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: internal-web-service\n  annotations:\n    # Configure as internal load balancer\n    cloud.google.com/load-balancer-type: "Internal"\n    # Specify subnet for the load balancer (optional)\n    cloud.google.com/load-balancer-subnet: "internal-subnet"\n    # Enable NEG for better performance\n    cloud.google.com/neg: \'{"ingress": true}\'\n    # Backend configuration\n    cloud.google.com/backend-config: \'{"default": "internal-backend-config"}\'\nspec:\n  type: LoadBalancer\n  selector:\n    app: internal-web-app\n  ports:\n  - port: 80\n    targetPort: 8080\n    protocol: TCP\n  - port: 443\n    targetPort: 8443\n    protocol: TCP\n---\n# Backend configuration for internal load balancer\napiVersion: cloud.google.com/v1\nkind: BackendConfig\nmetadata:\n  name: internal-backend-config\nspec:\n  # Session affinity for internal applications\n  sessionAffinity:\n    affinityType: "CLIENT_IP"\n    affinityCookieTtlSec: 3600\n  # Health check configuration\n  healthCheck:\n    checkIntervalSec: 10\n    timeoutSec: 5\n    healthyThreshold: 2\n    unhealthyThreshold: 3\n    type: HTTP\n    requestPath: /health\n    port: 8080\n  # Connection draining\n  connectionDraining:\n    drainingTimeoutSec: 300\n  # Logging configuration\n  logging:\n    enable: true\n    sampleRate: 0.5\n'})}),"\n",(0,i.jsx)(n.h4,{id:"step-2-deploy-internal-application",children:"Step 2: Deploy Internal Application"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# internal-app-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: internal-web-app\n  labels:\n    app: internal-web-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: internal-web-app\n  template:\n    metadata:\n      labels:\n        app: internal-web-app\n    spec:\n      containers:\n      - name: internal-app\n        image: nginx:1.21\n        ports:\n        - containerPort: 8080\n          name: http\n        - containerPort: 8443\n          name: https\n        # Add health check endpoint\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 5\n        resources:\n          requests:\n            memory: "128Mi"\n            cpu: "100m"\n          limits:\n            memory: "256Mi"\n            cpu: "500m"\n        # Environment variables for internal apps\n        env:\n        - name: ENVIRONMENT\n          value: "internal"\n        - name: LOG_LEVEL\n          value: "debug"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"step-3-create-internal-ingress-optional",children:"Step 3: Create Internal Ingress (Optional)"}),"\n",(0,i.jsx)(n.p,{children:"For more advanced routing within your internal network:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# internal-ingress.yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: internal-ingress\n  annotations:\n    # Use GKE ingress for internal load balancer\n    kubernetes.io/ingress.class: "gce-internal"\n    # Reserve internal static IP\n    kubernetes.io/ingress.global-static-ip-name: "internal-web-ip"\n    # Allow HTTP for internal use (optional)\n    kubernetes.io/ingress.allow-http: "true"\n    # Internal load balancer subnet\n    ingress.gcp.kubernetes.io/load-balancer-subnet: "internal-subnet"\nspec:\n  rules:\n  - host: internal-api.company.local\n    http:\n      paths:\n      - path: /api/v1\n        pathType: Prefix\n        backend:\n          service:\n            name: internal-api-service\n            port:\n              number: 80\n      - path: /admin\n        pathType: Prefix\n        backend:\n          service:\n            name: internal-admin-service\n            port:\n              number: 80\n  - host: internal-dashboard.company.local\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: internal-web-service\n            port:\n              number: 80\n'})}),"\n",(0,i.jsx)(n.h4,{id:"step-4-reserve-internal-static-ip",children:"Step 4: Reserve Internal Static IP"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Reserve internal static IP address\ngcloud compute addresses create internal-web-ip \\\n    --region=us-central1 \\\n    --subnet=internal-subnet \\\n    --address-type=INTERNAL\n\n# Get the internal IP address\ngcloud compute addresses describe internal-web-ip \\\n    --region=us-central1 \\\n    --format="value(address)"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"step-5-configure-firewall-rules",children:"Step 5: Configure Firewall Rules"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Allow internal traffic to the load balancer\ngcloud compute firewall-rules create allow-internal-lb \\\n    --direction=INGRESS \\\n    --priority=1000 \\\n    --network=default \\\n    --action=ALLOW \\\n    --rules=tcp:80,tcp:443 \\\n    --source-ranges=10.0.0.0/8,172.16.0.0/12,192.168.0.0/16 \\\n    --target-tags=gke-internal-lb\n\n# Allow health checks from Google Cloud health checkers\ngcloud compute firewall-rules create allow-internal-health-check \\\n    --direction=INGRESS \\\n    --priority=1000 \\\n    --network=default \\\n    --action=ALLOW \\\n    --rules=tcp \\\n    --source-ranges=130.211.0.0/22,35.191.0.0/16 \\\n    --target-tags=gke-internal-lb\n"})}),"\n",(0,i.jsx)(n.h4,{id:"step-6-dns-configuration-for-internal-services",children:"Step 6: DNS Configuration for Internal Services"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# internal-dns-config.yaml\n# For Google Cloud DNS private zones\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: internal-dns-config\ndata:\n  setup.sh: |\n    #!/bin/bash\n    \n    # Create private DNS zone for internal services\n    gcloud dns managed-zones create internal-company-zone \\\n        --description="Internal company services" \\\n        --dns-name="company.local." \\\n        --networks="default" \\\n        --visibility="private"\n    \n    # Add A record for internal API\n    gcloud dns record-sets transaction start --zone="internal-company-zone"\n    gcloud dns record-sets transaction add "10.1.1.100" \\\n        --name="internal-api.company.local." \\\n        --ttl="300" \\\n        --type="A" \\\n        --zone="internal-company-zone"\n    \n    # Add A record for internal dashboard\n    gcloud dns record-sets transaction add "10.1.1.100" \\\n        --name="internal-dashboard.company.local." \\\n        --ttl="300" \\\n        --type="A" \\\n        --zone="internal-company-zone"\n    \n    gcloud dns record-sets transaction execute --zone="internal-company-zone"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"step-7-internal-ssl-configuration",children:"Step 7: Internal SSL Configuration"}),"\n",(0,i.jsx)(n.p,{children:"For internal SSL certificates (self-signed or internal CA):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# internal-ssl-secret.yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: internal-tls-cert\ntype: kubernetes.io/tls\ndata:\n  tls.crt: # Base64 encoded internal certificate\n  tls.key: # Base64 encoded private key\n---\n# Internal ingress with SSL\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: internal-ssl-ingress\n  annotations:\n    kubernetes.io/ingress.class: "gce-internal"\n    kubernetes.io/ingress.global-static-ip-name: "internal-web-ip"\nspec:\n  tls:\n  - hosts:\n    - internal-api.company.local\n    - internal-dashboard.company.local\n    secretName: internal-tls-cert\n  rules:\n  - host: internal-api.company.local\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: internal-web-service\n            port:\n              number: 443\n'})}),"\n",(0,i.jsx)(n.h4,{id:"step-8-monitoring-internal-load-balancers",children:"Step 8: Monitoring Internal Load Balancers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# internal-monitoring.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: internal-lb-monitoring\ndata:\n  check-internal-lb.sh: |\n    #!/bin/bash\n    \n    # Check internal load balancer health\n    INTERNAL_LB_IP="10.1.1.100"\n    HEALTH_ENDPOINT="http://${INTERNAL_LB_IP}/health"\n    \n    # Test from within VPC\n    response=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_ENDPOINT")\n    \n    if [ "$response" -eq 200 ]; then\n        echo "\u2705 Internal load balancer is healthy"\n    else\n        echo "\u274c Internal load balancer health check failed (Status: $response)"\n        # Send internal alerts\n        kubectl create job alert-internal-lb-down --image=alpine/curl \\\n            --restart=Never \\\n            -- sh -c "curl -X POST https://internal-alerts.company.local/webhook"\n    fi\n    \n    # Check backend service status\n    gcloud compute backend-services list --filter="loadBalancingScheme:INTERNAL"\n    \n    # Monitor internal ingress\n    kubectl get ingress internal-ingress -o wide\n'})}),"\n",(0,i.jsx)(n.h4,{id:"best-practices-for-internal-load-balancers",children:"Best Practices for Internal Load Balancers"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Network Security"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Restrict access to specific subnets\ngcloud compute firewall-rules create restrict-internal-access \\\n    --direction=INGRESS \\\n    --action=ALLOW \\\n    --rules=tcp:80,tcp:443 \\\n    --source-ranges=10.10.0.0/16 \\\n    --target-tags=internal-lb-restricted\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Command Explanation:"})}),"\n",(0,i.jsx)(n.p,{children:"This firewall rule creates a security boundary for internal load balancers by restricting network access to specific IP ranges. Let's break down each parameter:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"gcloud compute firewall-rules create restrict-internal-access"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'Creates a new firewall rule named "restrict-internal-access"'}),"\n",(0,i.jsx)(n.li,{children:"This rule will be applied at the VPC network level"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"--direction=INGRESS"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Specifies this rule applies to ",(0,i.jsx)(n.strong,{children:"incoming traffic"})," (traffic entering your network)"]}),"\n",(0,i.jsxs)(n.li,{children:["Alternative would be ",(0,i.jsx)(n.code,{children:"EGRESS"})," for outgoing traffic"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"--action=ALLOW"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Permits"})," the specified traffic to pass through"]}),"\n",(0,i.jsxs)(n.li,{children:["Alternative would be ",(0,i.jsx)(n.code,{children:"DENY"})," to block traffic"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"--rules=tcp:80,tcp:443"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Allows TCP traffic on ",(0,i.jsx)(n.strong,{children:"port 80"})," (HTTP) and ",(0,i.jsx)(n.strong,{children:"port 443"})," (HTTPS)"]}),"\n",(0,i.jsxs)(n.li,{children:["Format: ",(0,i.jsx)(n.code,{children:"protocol:port"})," or ",(0,i.jsx)(n.code,{children:"protocol:port-range"})]}),"\n",(0,i.jsxs)(n.li,{children:["Examples: ",(0,i.jsx)(n.code,{children:"tcp:8080"}),", ",(0,i.jsx)(n.code,{children:"tcp:8000-9000"}),", ",(0,i.jsx)(n.code,{children:"udp:53"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"--source-ranges=10.10.0.0/16"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Restricts access"})," to only IP addresses in the ",(0,i.jsx)(n.code,{children:"10.10.0.0/16"})," CIDR block"]}),"\n",(0,i.jsxs)(n.li,{children:["This means only IPs from ",(0,i.jsx)(n.code,{children:"10.10.0.1"})," to ",(0,i.jsx)(n.code,{children:"10.10.255.254"})," can access the service"]}),"\n",(0,i.jsxs)(n.li,{children:["Common private IP ranges:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"10.0.0.0/8"})," (10.0.0.0 - 10.255.255.255)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"172.16.0.0/12"})," (172.16.0.0 - 172.31.255.255)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"192.168.0.0/16"})," (192.168.0.0 - 192.168.255.255)"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"--target-tags=internal-lb-restricted"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Applies this rule only to resources tagged with ",(0,i.jsx)(n.code,{children:"internal-lb-restricted"})]}),"\n",(0,i.jsx)(n.li,{children:"Resources must have this network tag to be affected by this firewall rule"}),"\n",(0,i.jsx)(n.li,{children:"You can assign tags to VMs, load balancers, and other compute resources"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Real-World Use Cases:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Example 1: Restrict to office network only\ngcloud compute firewall-rules create office-only-access \\\n    --direction=INGRESS \\\n    --action=ALLOW \\\n    --rules=tcp:80,tcp:443 \\\n    --source-ranges=203.0.113.0/24 \\\n    --target-tags=office-accessible\n\n# Example 2: Allow access from multiple internal subnets\ngcloud compute firewall-rules create multi-subnet-access \\\n    --direction=INGRESS \\\n    --action=ALLOW \\\n    --rules=tcp:80,tcp:443,tcp:8080 \\\n    --source-ranges=10.1.0.0/16,10.2.0.0/16,10.3.0.0/16 \\\n    --target-tags=internal-services\n\n# Example 3: Restrict database access to app servers only\ngcloud compute firewall-rules create db-access-restricted \\\n    --direction=INGRESS \\\n    --action=ALLOW \\\n    --rules=tcp:5432,tcp:3306 \\\n    --source-ranges=10.100.1.0/24 \\\n    --target-tags=database-servers\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Security Benefits:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Zero-trust networking"}),": Only specified IP ranges can access services"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Defense in depth"}),": Additional layer beyond application-level security"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Compliance"}),": Meets regulatory requirements for network isolation"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Audit trail"}),": All firewall rule changes are logged for security auditing"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How to Apply Tags to Resources:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Tag a VM instance\ngcloud compute instances add-tags INSTANCE_NAME \\\n    --tags=internal-lb-restricted \\\n    --zone=us-central1-a\n\n# Tag during VM creation\ngcloud compute instances create internal-app-vm \\\n    --tags=internal-lb-restricted \\\n    --zone=us-central1-a\n\n# Tag a GKE node pool (applies to all nodes)\ngcloud container node-pools update POOL_NAME \\\n    --cluster=CLUSTER_NAME \\\n    --zone=us-central1-a \\\n    --node-tags=internal-lb-restricted\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Logging and Monitoring"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Enable comprehensive logging\nspec:\n  logging:\n    enable: true\n    sampleRate: 1.0  # 100% sampling for internal apps\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Session Persistence"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Configure session affinity for stateful apps\nsessionAffinity:\n  affinityType: "CLIENT_IP_PROTO"\n  affinityCookieTtlSec: 7200\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Health Checks"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Aggressive health checks for internal services\nhealthCheck:\n  checkIntervalSec: 5\n  timeoutSec: 3\n  healthyThreshold: 2\n  unhealthyThreshold: 2\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"troubleshooting-internal-load-balancers",children:"Troubleshooting Internal Load Balancers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Check internal load balancer status\ngcloud compute backend-services list --filter="loadBalancingScheme:INTERNAL"\n\n# Verify firewall rules\ngcloud compute firewall-rules list --filter="direction:INGRESS AND allowed.ports:80"\n\n# Test connectivity from within VPC\nkubectl run test-internal --image=busybox --rm -it -- \\\n    wget -qO- http://internal-api.company.local/health\n\n# Check internal DNS resolution\nkubectl run test-dns --image=busybox --rm -it -- \\\n    nslookup internal-api.company.local\n\n# Monitor internal load balancer logs\ngcloud logging read "resource.type=gce_internal_load_balancer" --limit=50\n'})}),"\n",(0,i.jsx)(n.p,{children:"Apply the configurations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Deploy internal application\nkubectl apply -f internal-app-deployment.yaml\nkubectl apply -f internal-service.yaml\n\n# Create ingress (if needed)\nkubectl apply -f internal-ingress.yaml\n\n# Set up DNS and monitoring\nkubectl apply -f internal-dns-config.yaml\nkubectl apply -f internal-monitoring.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:"This internal load balancer setup provides secure, high-performance access to your internal applications while maintaining network isolation and proper monitoring."}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(n.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,i.jsx)(n.h4,{id:"1-ingress-ip-address-not-assigned",children:"1. Ingress IP Address Not Assigned"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Check ingress status\nkubectl get ingress -o wide\n\n# Check ingress events\nkubectl describe ingress your-ingress-name\n\n# Check firewall rules\ngcloud compute firewall-rules list --filter="name~gke"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"2-ssl-certificate-issues",children:"2. SSL Certificate Issues"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Check managed certificate status\nkubectl get managedcertificate -o wide\n\n# Check certificate events\nkubectl describe managedcertificate your-cert-name\n\n# For cert-manager certificates\nkubectl get certificates\nkubectl describe certificate your-cert-name\n"})}),"\n",(0,i.jsx)(n.h4,{id:"3-backend-service-issues",children:"3. Backend Service Issues"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Check service endpoints\nkubectl get endpoints\n\n# Check backend service health\nkubectl get backendconfig -o yaml\n\n# Check NEG status\ngcloud compute network-endpoint-groups list\n"})}),"\n",(0,i.jsx)(n.h4,{id:"4-dns-resolution-issues",children:"4. DNS Resolution Issues"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Check DNS propagation\ndig your-domain.com\n\n# Check Google Cloud DNS\ngcloud dns managed-zones list\ngcloud dns record-sets list --zone=your-zone-name\n"})}),"\n",(0,i.jsx)(n.h3,{id:"debugging-commands",children:"Debugging Commands"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Get detailed ingress information\nkubectl get ingress -o yaml\n\n# Check ingress controller logs (NGINX)\nkubectl logs -n ingress-nginx deployment/ingress-nginx-controller\n\n# Check Google Cloud Load Balancer\ngcloud compute url-maps list\ngcloud compute backend-services list\ngcloud compute forwarding-rules list\n\n# Test connectivity\nkubectl run test-pod --image=busybox --rm -it -- wget -qO- http://web-app-service\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-resource-management",children:"1. Resource Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use resource requests and limits for ingress controllers"}),"\n",(0,i.jsx)(n.li,{children:"Monitor ingress controller performance"}),"\n",(0,i.jsx)(n.li,{children:"Scale ingress controllers based on traffic"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'resources:\n  requests:\n    memory: "256Mi"\n    cpu: "100m"\n  limits:\n    memory: "512Mi"\n    cpu: "500m"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-security",children:"2. Security"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Always use HTTPS in production"}),"\n",(0,i.jsx)(n.li,{children:"Implement proper authentication and authorization"}),"\n",(0,i.jsx)(n.li,{children:"Use network policies to restrict traffic"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Force HTTPS redirect\nannotations:\n  kubernetes.io/ingress.allow-http: "false"\n  nginx.ingress.kubernetes.io/ssl-redirect: "true"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-performance",children:"3. Performance"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Enable HTTP/2 and gRPC support"}),"\n",(0,i.jsx)(n.li,{children:"Configure appropriate timeouts"}),"\n",(0,i.jsx)(n.li,{children:"Use connection pooling"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# NGINX performance annotations\nannotations:\n  nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"\n  nginx.ingress.kubernetes.io/proxy-send-timeout: "600"\n  nginx.ingress.kubernetes.io/proxy-read-timeout: "600"\n  nginx.ingress.kubernetes.io/proxy-body-size: "32m"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-monitoring",children:"4. Monitoring"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Set up monitoring for ingress controllers"}),"\n",(0,i.jsx)(n.li,{children:"Monitor SSL certificate expiration"}),"\n",(0,i.jsx)(n.li,{children:"Track ingress performance metrics"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Monitor ingress metrics\nkubectl top pods -n ingress-nginx\nkubectl get events --sort-by=.metadata.creationTimestamp\n"})}),"\n",(0,i.jsx)(n.h3,{id:"5-backup-and-disaster-recovery",children:"5. Backup and Disaster Recovery"}),"\n",(0,i.jsx)(n.p,{children:"Implementing a comprehensive backup and disaster recovery strategy for your GKE ingress setup is crucial for maintaining high availability and minimizing downtime during unexpected events."}),"\n",(0,i.jsx)(n.h4,{id:"51-configuration-backup-strategies",children:"5.1 Configuration Backup Strategies"}),"\n",(0,i.jsx)(n.h5,{id:"automated-configuration-export",children:"Automated Configuration Export"}),"\n",(0,i.jsx)(n.p,{children:"Create automated scripts to backup your ingress configurations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# backup-ingress-configs.sh\n\n# Set variables\nBACKUP_DIR="/backup/ingress-configs/$(date +%Y-%m-%d)"\nNAMESPACE="default"\n\n# Create backup directory\nmkdir -p "$BACKUP_DIR"\n\n# Backup all ingress resources\necho "Backing up ingress configurations..."\nkubectl get ingress -n "$NAMESPACE" -o yaml > "$BACKUP_DIR/ingress-backup.yaml"\n\n# Backup services\nkubectl get services -n "$NAMESPACE" -o yaml > "$BACKUP_DIR/services-backup.yaml"\n\n# Backup SSL certificates (managed certificates)\nkubectl get managedcertificate -n "$NAMESPACE" -o yaml > "$BACKUP_DIR/managed-certs-backup.yaml"\n\n# Backup cert-manager certificates (if using NGINX)\nkubectl get certificates -n "$NAMESPACE" -o yaml > "$BACKUP_DIR/certificates-backup.yaml"\n\n# Backup secrets (TLS certificates)\nkubectl get secrets -n "$NAMESPACE" --field-selector type=kubernetes.io/tls -o yaml > "$BACKUP_DIR/tls-secrets-backup.yaml"\n\n# Backup backend configs (GKE specific)\nkubectl get backendconfig -n "$NAMESPACE" -o yaml > "$BACKUP_DIR/backend-configs-backup.yaml"\n\n# Backup ingress controller configuration (NGINX)\nif kubectl get namespace ingress-nginx &> /dev/null; then\n    kubectl get configmap -n ingress-nginx -o yaml > "$BACKUP_DIR/nginx-configmap-backup.yaml"\n    kubectl get deployment -n ingress-nginx -o yaml > "$BACKUP_DIR/nginx-deployment-backup.yaml"\nfi\n\n# Create tarball\ntar -czf "$BACKUP_DIR/../ingress-backup-$(date +%Y-%m-%d).tar.gz" -C "$BACKUP_DIR/.." "$(basename "$BACKUP_DIR")"\n\necho "Backup completed: $BACKUP_DIR/../ingress-backup-$(date +%Y-%m-%d).tar.gz"\n'})}),"\n",(0,i.jsx)(n.h5,{id:"version-control-integration",children:"Version Control Integration"}),"\n",(0,i.jsx)(n.p,{children:"Store configurations in Git for version control and easy restoration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Initialize git repository for configurations\nmkdir ingress-configs-repo\ncd ingress-configs-repo\ngit init\n\n# Create directory structure\nmkdir -p {ingress,services,certificates,secrets,backend-configs}\n\n# Export current configurations\nkubectl get ingress --all-namespaces -o yaml > ingress/current-ingress.yaml\nkubectl get managedcertificate --all-namespaces -o yaml > certificates/managed-certs.yaml\n\n# Commit to version control\ngit add .\ngit commit -m "Initial ingress configuration backup - $(date)"\ngit remote add origin YOUR_BACKUP_REPOSITORY_URL\ngit push -u origin main\n'})}),"\n",(0,i.jsx)(n.h4,{id:"52-dns-configuration-documentation",children:"5.2 DNS Configuration Documentation"}),"\n",(0,i.jsx)(n.h5,{id:"dns-records-inventory",children:"DNS Records Inventory"}),"\n",(0,i.jsx)(n.p,{children:"Maintain a comprehensive inventory of your DNS configurations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# dns-inventory.yaml\ndns_configuration:\n  primary_domain: "your-domain.com"\n  subdomains:\n    - name: "api.your-domain.com"\n      type: "A"\n      value: "34.102.136.180"  # Load balancer IP\n      ttl: 300\n    - name: "www.your-domain.com"\n      type: "CNAME"\n      value: "your-domain.com"\n      ttl: 3600\n    - name: "your-domain.com"\n      type: "A"\n      value: "34.102.136.180"\n      ttl: 300\n\nload_balancers:\n  - name: "web-app-lb"\n    ip: "34.102.136.180"\n    ingress: "web-app-ingress"\n    ssl_cert: "web-app-ssl-cert"\n    \ndns_providers:\n  primary: "Google Cloud DNS"\n  secondary: "Cloudflare"  # Optional secondary provider\n  \nhealth_checks:\n  - url: "https://your-domain.com/health"\n    expected_status: 200\n    check_interval: "5m"\n'})}),"\n",(0,i.jsx)(n.h5,{id:"dns-backup-script",children:"DNS Backup Script"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# backup-dns-configs.sh\n\nPROJECT_ID="your-project-id"\nBACKUP_FILE="dns-backup-$(date +%Y-%m-%d).json"\n\n# Export DNS zones\ngcloud dns managed-zones list --project="$PROJECT_ID" --format="json" > "zones-$BACKUP_FILE"\n\n# Export DNS records for each zone\ngcloud dns managed-zones list --project="$PROJECT_ID" --format="value(name)" | while read zone; do\n    echo "Backing up DNS records for zone: $zone"\n    gcloud dns record-sets list --zone="$zone" --project="$PROJECT_ID" --format="json" > "records-${zone}-$BACKUP_FILE"\ndone\n\n# Backup static IP addresses\ngcloud compute addresses list --global --project="$PROJECT_ID" --format="json" > "static-ips-$BACKUP_FILE"\n\necho "DNS backup completed"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"53-disaster-recovery-procedures",children:"5.3 Disaster Recovery Procedures"}),"\n",(0,i.jsx)(n.h5,{id:"multi-region-setup",children:"Multi-Region Setup"}),"\n",(0,i.jsx)(n.p,{children:"Configure ingress across multiple regions for high availability:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# multi-region-ingress.yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: multi-region-ingress\n  annotations:\n    kubernetes.io/ingress.class: "gce"\n    kubernetes.io/ingress.global-static-ip-name: "global-web-ip"\n    networking.gke.io/managed-certificates: "global-ssl-cert"\n    kubernetes.gke.io/ingress.allow-http: "false"\nspec:\n  rules:\n  - host: your-domain.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-app-service\n            port:\n              number: 80\n---\n# Global backend service configuration\napiVersion: cloud.google.com/v1\nkind: BackendConfig\nmetadata:\n  name: global-backend-config\nspec:\n  healthCheck:\n    checkIntervalSec: 15\n    timeoutSec: 10\n    healthyThreshold: 1\n    unhealthyThreshold: 3\n    type: HTTP\n    requestPath: /health\n  connectionDraining:\n    drainingTimeoutSec: 60\n  affinityConfig:\n    affinityType: "CLIENT_IP"\n'})}),"\n",(0,i.jsx)(n.h5,{id:"failover-testing-script",children:"Failover Testing Script"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# test-failover.sh\n\n# Configuration\nPRIMARY_ENDPOINT="https://your-domain.com"\nSECONDARY_ENDPOINT="https://backup.your-domain.com"\nHEALTH_CHECK_PATH="/health"\n\necho "Starting failover test..."\n\n# Test primary endpoint\necho "Testing primary endpoint: $PRIMARY_ENDPOINT"\nprimary_status=$(curl -s -o /dev/null -w "%{http_code}" "$PRIMARY_ENDPOINT$HEALTH_CHECK_PATH")\n\nif [ "$primary_status" -eq 200 ]; then\n    echo "\u2705 Primary endpoint is healthy (Status: $primary_status)"\nelse\n    echo "\u274c Primary endpoint failed (Status: $primary_status)"\n    \n    # Test secondary endpoint\n    echo "Testing secondary endpoint: $SECONDARY_ENDPOINT"\n    secondary_status=$(curl -s -o /dev/null -w "%{http_code}" "$SECONDARY_ENDPOINT$HEALTH_CHECK_PATH")\n    \n    if [ "$secondary_status" -eq 200 ]; then\n        echo "\u2705 Secondary endpoint is healthy (Status: $secondary_status)"\n        echo "\ud83d\udd04 Initiating failover procedures..."\n        \n        # Add your failover logic here\n        # Examples:\n        # - Update DNS records\n        # - Notify monitoring systems\n        # - Scale up secondary region\n        \n    else\n        echo "\u274c Both endpoints failed! Manual intervention required."\n        # Send critical alerts\n    fi\nfi\n\n# Test SSL certificate expiration\necho "Checking SSL certificate expiration..."\ncert_expiry=$(echo | openssl s_client -servername your-domain.com -connect your-domain.com:443 2>/dev/null | openssl x509 -noout -dates | grep "notAfter" | cut -d= -f2)\nexpiry_epoch=$(date -d "$cert_expiry" +%s)\ncurrent_epoch=$(date +%s)\ndays_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))\n\nif [ "$days_until_expiry" -lt 30 ]; then\n    echo "\u26a0\ufe0f  SSL certificate expires in $days_until_expiry days"\nelse\n    echo "\u2705 SSL certificate is valid for $days_until_expiry days"\nfi\n'})}),"\n",(0,i.jsx)(n.h4,{id:"54-recovery-procedures",children:"5.4 Recovery Procedures"}),"\n",(0,i.jsx)(n.h5,{id:"ingress-configuration-recovery",children:"Ingress Configuration Recovery"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# restore-ingress.sh\n\nBACKUP_FILE="$1"\nNAMESPACE="${2:-default}"\n\nif [ -z "$BACKUP_FILE" ]; then\n    echo "Usage: $0 <backup-file> [namespace]"\n    exit 1\nfi\n\necho "Restoring ingress configuration from: $BACKUP_FILE"\n\n# Extract backup if it\'s a tarball\nif [[ "$BACKUP_FILE" == *.tar.gz ]]; then\n    tar -xzf "$BACKUP_FILE"\n    BACKUP_DIR=$(basename "$BACKUP_FILE" .tar.gz)\nelse\n    BACKUP_DIR="$BACKUP_FILE"\nfi\n\n# Restore ingress resources\necho "Restoring ingress resources..."\nkubectl apply -f "$BACKUP_DIR/ingress-backup.yaml" -n "$NAMESPACE"\n\n# Restore services\necho "Restoring services..."\nkubectl apply -f "$BACKUP_DIR/services-backup.yaml" -n "$NAMESPACE"\n\n# Restore managed certificates\necho "Restoring managed certificates..."\nif [ -f "$BACKUP_DIR/managed-certs-backup.yaml" ]; then\n    kubectl apply -f "$BACKUP_DIR/managed-certs-backup.yaml" -n "$NAMESPACE"\nfi\n\n# Restore TLS secrets\necho "Restoring TLS secrets..."\nif [ -f "$BACKUP_DIR/tls-secrets-backup.yaml" ]; then\n    kubectl apply -f "$BACKUP_DIR/tls-secrets-backup.yaml" -n "$NAMESPACE"\nfi\n\n# Restore backend configs\necho "Restoring backend configurations..."\nif [ -f "$BACKUP_DIR/backend-configs-backup.yaml" ]; then\n    kubectl apply -f "$BACKUP_DIR/backend-configs-backup.yaml" -n "$NAMESPACE"\nfi\n\necho "Recovery completed. Verifying ingress status..."\nkubectl get ingress -n "$NAMESPACE"\n'})}),"\n",(0,i.jsx)(n.h5,{id:"dns-recovery",children:"DNS Recovery"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# restore-dns.sh\n\nPROJECT_ID="$1"\nBACKUP_DATE="$2"\n\nif [ -z "$PROJECT_ID" ] || [ -z "$BACKUP_DATE" ]; then\n    echo "Usage: $0 <project-id> <backup-date>"\n    echo "Example: $0 my-project 2025-10-12"\n    exit 1\nfi\n\necho "Restoring DNS configuration for project: $PROJECT_ID"\n\n# Restore static IP addresses\necho "Restoring static IP addresses..."\ngcloud compute addresses create web-app-ip --global --project="$PROJECT_ID"\n\n# Restore DNS zones (if needed)\n# Note: This is typically not needed as zones usually persist\n\n# Restore DNS records\necho "Restoring DNS records..."\nZONES=$(gcloud dns managed-zones list --project="$PROJECT_ID" --format="value(name)")\n\nfor zone in $ZONES; do\n    echo "Restoring records for zone: $zone"\n    \n    # Clear existing records (except NS and SOA)\n    gcloud dns record-sets list --zone="$zone" --project="$PROJECT_ID" --format="value(name,type)" | \\\n    grep -v "NS\\|SOA" | while read name type; do\n        if [ "$name" != "" ] && [ "$type" != "" ]; then\n            gcloud dns record-sets delete "$name" --zone="$zone" --type="$type" --project="$PROJECT_ID" --quiet || true\n        fi\n    done\n    \n    # Import records from backup\n    if [ -f "records-${zone}-dns-backup-${BACKUP_DATE}.json" ]; then\n        # Parse and recreate records from backup\n        # (Implementation depends on your backup format)\n        echo "Importing records from backup file"\n    fi\ndone\n'})}),"\n",(0,i.jsx)(n.h4,{id:"55-monitoring-and-alerting-for-dr",children:"5.5 Monitoring and Alerting for DR"}),"\n",(0,i.jsx)(n.h5,{id:"health-check-monitoring",children:"Health Check Monitoring"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# monitoring-config.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: ingress-monitoring\ndata:\n  prometheus.yml: |\n    global:\n      scrape_interval: 15s\n    scrape_configs:\n    - job_name: 'ingress-health'\n      metrics_path: /metrics\n      static_configs:\n      - targets: ['your-domain.com:443']\n    - job_name: 'certificate-expiry'\n      metrics_path: /probe\n      params:\n        module: [http_2xx]\n      static_configs:\n      - targets: ['your-domain.com']\n"})}),"\n",(0,i.jsx)(n.h5,{id:"automated-recovery-triggers",children:"Automated Recovery Triggers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# automated-recovery.sh\n\n# This script can be triggered by monitoring alerts\nALERT_TYPE="$1"\nSEVERITY="$2"\n\ncase "$ALERT_TYPE" in\n    "ingress_down")\n        echo "Ingress is down. Starting recovery procedures..."\n        # Restart ingress controllers\n        kubectl rollout restart deployment/ingress-nginx-controller -n ingress-nginx\n        ;;\n    "ssl_expiring")\n        echo "SSL certificate expiring. Triggering renewal..."\n        # Force certificate renewal\n        kubectl annotate managedcertificate web-app-ssl-cert cert-manager.io/force-renewal=$(date +%s)\n        ;;\n    "high_error_rate")\n        echo "High error rate detected. Scaling ingress controllers..."\n        # Scale ingress controllers\n        kubectl scale deployment/ingress-nginx-controller --replicas=5 -n ingress-nginx\n        ;;\n    *)\n        echo "Unknown alert type: $ALERT_TYPE"\n        ;;\nesac\n'})}),"\n",(0,i.jsx)(n.h4,{id:"56-documentation-and-runbooks",children:"5.6 Documentation and Runbooks"}),"\n",(0,i.jsx)(n.h5,{id:"disaster-recovery-runbook",children:"Disaster Recovery Runbook"}),"\n",(0,i.jsx)(n.p,{children:"Create a detailed runbook for your team:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-markdown",children:"# Ingress Disaster Recovery Runbook\n\n## Emergency Contacts\n- DevOps Team Lead: +1-xxx-xxx-xxxx\n- Security Team: security@company.com\n- DNS Provider Support: dns-support@provider.com\n\n## Recovery Procedures by Scenario\n\n### Scenario 1: Complete Ingress Failure\n1. Check ingress controller status: `kubectl get pods -n ingress-nginx`\n2. Check load balancer status in GCP Console\n3. Verify DNS resolution: `dig your-domain.com`\n4. If needed, restore from backup: `./restore-ingress.sh backup-file.tar.gz`\n\n### Scenario 2: SSL Certificate Issues\n1. Check certificate status: `kubectl get managedcertificate`\n2. Verify DNS records point to correct IP\n3. Check certificate expiration\n4. Force renewal if needed\n\n### Scenario 3: DNS Resolution Problems\n1. Check DNS propagation: `dig +trace your-domain.com`\n2. Verify DNS records in provider console\n3. Check static IP assignment\n4. Restore DNS records if needed: `./restore-dns.sh project-id backup-date`\n\n## Recovery Time Objectives (RTO)\n- DNS failover: 5 minutes\n- Ingress restoration: 15 minutes\n- Full service recovery: 30 minutes\n\n## Recovery Point Objectives (RPO)\n- Configuration backups: 4 hours\n- DNS record backups: Daily\n"})}),"\n",(0,i.jsx)(n.p,{children:"This comprehensive backup and disaster recovery strategy ensures that your GKE ingress setup can be quickly restored in case of failures, with minimal downtime and data loss."}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Setting up ingress in GKE provides multiple options depending on your requirements. GKE Ingress offers simple setup with Google Cloud integration, while NGINX Ingress provides more flexibility and features. Choose the option that best fits your use case and follow the best practices for security, performance, and reliability."}),"\n",(0,i.jsx)(n.p,{children:"For production deployments, always:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use HTTPS with valid certificates"}),"\n",(0,i.jsx)(n.li,{children:"Implement proper monitoring"}),"\n",(0,i.jsx)(n.li,{children:"Plan for disaster recovery"}),"\n",(0,i.jsx)(n.li,{children:"Test your configuration thoroughly"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://cloud.google.com/kubernetes-engine/docs/concepts/ingress",children:"GKE Ingress Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://kubernetes.github.io/ingress-nginx/",children:"NGINX Ingress Controller Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://cert-manager.io/docs/",children:"cert-manager Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://cloud.google.com/load-balancing",children:"Google Cloud Load Balancer"})}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);