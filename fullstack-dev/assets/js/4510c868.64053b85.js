"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[5562],{5741:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>s});var o=t(9729);const r={},i=o.createContext(r);function a(n){const e=o.useContext(i);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),o.createElement(i.Provider,{value:e},n.children)}},7885:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>g,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"features/cookie-consent/geo-targeting-implementation","title":"Geo-targeting Implementation Guide","description":"This comprehensive guide covers implementing geo-targeting functionality in modern web applications, including location detection, content personalization, and geo-based business logic for Node.js/NestJS backends and React/Next.js frontends.","source":"@site/docs/features/cookie-consent/geo-targeting-implementation.md","sourceDirName":"features/cookie-consent","slug":"/features/cookie-consent/geo-targeting-implementation","permalink":"/fullstack-dev/docs/features/cookie-consent/geo-targeting-implementation","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/features/cookie-consent/geo-targeting-implementation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Cookie Consent Management for E-commerce Website","permalink":"/fullstack-dev/docs/features/cookie-consent/cookie-consent-management"},"next":{"title":"Real-time Notification Application with Node.js, Next.js, FCM & GKE","permalink":"/fullstack-dev/docs/features/notifications/realtime-notifications-guide"}}');var r=t(5813),i=t(5741);const a={},s="Geo-targeting Implementation Guide",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Architecture Overview",id:"architecture-overview",level:3},{value:"Client-Side Geo-targeting",id:"client-side-geo-targeting",level:2},{value:"Browser Geolocation API",id:"browser-geolocation-api",level:3},{value:"IP-based Geolocation",id:"ip-based-geolocation",level:3},{value:"Server-Side Geo-targeting",id:"server-side-geo-targeting",level:2},{value:"NestJS Geo-targeting Service",id:"nestjs-geo-targeting-service",level:3},{value:"Geo-targeting Decorator",id:"geo-targeting-decorator",level:3},{value:"Geo-targeting Middleware",id:"geo-targeting-middleware",level:3},{value:"Database Design",id:"database-design",level:2},{value:"Entity Definitions",id:"entity-definitions",level:3},{value:"API Implementation",id:"api-implementation",level:2},{value:"Geo-targeting Controller",id:"geo-targeting-controller",level:3},{value:"Frontend Implementation",id:"frontend-implementation",level:2},{value:"React Geo-targeting Hook",id:"react-geo-targeting-hook",level:3},{value:"Geo-targeted Component",id:"geo-targeted-component",level:3},{value:"Currency Display Component",id:"currency-display-component",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Geo-fencing Implementation",id:"geo-fencing-implementation",level:3},{value:"A/B Testing with Geo-targeting",id:"ab-testing-with-geo-targeting",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Caching Strategy",id:"caching-strategy",level:3},{value:"CDN Integration",id:"cdn-integration",level:3},{value:"Privacy and Compliance",id:"privacy-and-compliance",level:2},{value:"GDPR Compliance",id:"gdpr-compliance",level:3}];function u(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"geo-targeting-implementation-guide",children:"Geo-targeting Implementation Guide"})}),"\n",(0,r.jsx)(e.p,{children:"This comprehensive guide covers implementing geo-targeting functionality in modern web applications, including location detection, content personalization, and geo-based business logic for Node.js/NestJS backends and React/Next.js frontends."}),"\n",(0,r.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#overview",children:"Overview"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#client-side-geo-targeting",children:"Client-Side Geo-targeting"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#server-side-geo-targeting",children:"Server-Side Geo-targeting"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#database-design",children:"Database Design"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#api-implementation",children:"API Implementation"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#frontend-implementation",children:"Frontend Implementation"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#advanced-features",children:"Advanced Features"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#privacy-and-compliance",children:"Privacy and Compliance"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#testing-strategies",children:"Testing Strategies"})}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(e.p,{children:"Geo-targeting enables applications to deliver personalized experiences based on user location, including:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Content Localization"}),": Language, currency, and region-specific content"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Service Availability"}),": Location-based feature restrictions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Pricing Strategy"}),": Regional pricing and promotions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Compliance"}),": GDPR, data residency requirements"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Performance"}),": CDN and server selection"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mermaid",children:"graph TD\n    A[User Request] --\x3e B[CDN/Load Balancer]\n    B --\x3e C[Geo Detection Service]\n    C --\x3e D[Location Data]\n    D --\x3e E[Content Personalization]\n    E --\x3e F[Cache Layer]\n    F --\x3e G[Response to User]\n    \n    H[IP Geolocation APIs] --\x3e C\n    I[Browser Geolocation] --\x3e C\n    J[User Preferences] --\x3e C\n    \n    K[Database] --\x3e L[Geo-specific Content]\n    L --\x3e E\n    M[CDN Edge Locations] --\x3e F\n"})}),"\n",(0,r.jsx)(e.h2,{id:"client-side-geo-targeting",children:"Client-Side Geo-targeting"}),"\n",(0,r.jsx)(e.h3,{id:"browser-geolocation-api",children:"Browser Geolocation API"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// utils/geolocation.ts\nexport interface GeolocationData {\n  latitude: number;\n  longitude: number;\n  accuracy: number;\n  timestamp: number;\n}\n\nexport interface GeoLocationError {\n  code: number;\n  message: string;\n}\n\nexport class GeolocationService {\n  private static instance: GeolocationService;\n  private cache: Map<string, GeolocationData> = new Map();\n  private readonly CACHE_DURATION = 30 * 60 * 1000; // 30 minutes\n\n  static getInstance(): GeolocationService {\n    if (!GeolocationService.instance) {\n      GeolocationService.instance = new GeolocationService();\n    }\n    return GeolocationService.instance;\n  }\n\n  async getCurrentPosition(\n    options: PositionOptions = {}\n  ): Promise<GeolocationData> {\n    const cacheKey = 'current-position';\n    const cached = this.cache.get(cacheKey);\n    \n    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {\n      return cached;\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported by this browser'));\n        return;\n      }\n\n      const defaultOptions: PositionOptions = {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 300000, // 5 minutes\n        ...options,\n      };\n\n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          const geoData: GeolocationData = {\n            latitude: position.coords.latitude,\n            longitude: position.coords.longitude,\n            accuracy: position.coords.accuracy,\n            timestamp: Date.now(),\n          };\n          \n          this.cache.set(cacheKey, geoData);\n          resolve(geoData);\n        },\n        (error) => {\n          const geoError: GeoLocationError = {\n            code: error.code,\n            message: this.getErrorMessage(error.code),\n          };\n          reject(geoError);\n        },\n        defaultOptions\n      );\n    });\n  }\n\n  private getErrorMessage(code: number): string {\n    switch (code) {\n      case 1:\n        return 'Location access denied by user';\n      case 2:\n        return 'Location information unavailable';\n      case 3:\n        return 'Location request timeout';\n      default:\n        return 'Unknown location error';\n    }\n  }\n\n  watchPosition(\n    callback: (position: GeolocationData) => void,\n    errorCallback: (error: GeoLocationError) => void,\n    options: PositionOptions = {}\n  ): number {\n    if (!navigator.geolocation) {\n      errorCallback({\n        code: 0,\n        message: 'Geolocation is not supported',\n      });\n      return -1;\n    }\n\n    return navigator.geolocation.watchPosition(\n      (position) => {\n        const geoData: GeolocationData = {\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude,\n          accuracy: position.coords.accuracy,\n          timestamp: Date.now(),\n        };\n        callback(geoData);\n      },\n      (error) => {\n        errorCallback({\n          code: error.code,\n          message: this.getErrorMessage(error.code),\n        });\n      },\n      {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 60000,\n        ...options,\n      }\n    );\n  }\n\n  clearWatch(watchId: number): void {\n    navigator.geolocation.clearWatch(watchId);\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"ip-based-geolocation",children:"IP-based Geolocation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// services/ip-geolocation.ts\nexport interface IPGeolocationData {\n  ip: string;\n  country: string;\n  countryCode: string;\n  region: string;\n  regionCode: string;\n  city: string;\n  zip: string;\n  latitude: number;\n  longitude: number;\n  timezone: string;\n  isp: string;\n  org: string;\n  as: string;\n}\n\nexport class IPGeolocationService {\n  private readonly apiKey: string;\n  private readonly baseUrl: string;\n  private cache: Map<string, IPGeolocationData> = new Map();\n\n  constructor(apiKey: string, provider: 'ipapi' | 'ipgeolocation' = 'ipapi') {\n    this.apiKey = apiKey;\n    this.baseUrl = provider === 'ipapi' \n      ? 'http://api.ipapi.com' \n      : 'https://api.ipgeolocation.io';\n  }\n\n  async getLocationByIP(ip?: string): Promise<IPGeolocationData> {\n    const targetIP = ip || 'check'; // 'check' for current IP\n    const cacheKey = `ip-${targetIP}`;\n    \n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    try {\n      const response = await fetch(\n        `${this.baseUrl}/${targetIP}?access_key=${this.apiKey}&format=1`\n      );\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      if (data.success === false) {\n        throw new Error(data.error?.info || 'IP geolocation failed');\n      }\n\n      const geoData: IPGeolocationData = {\n        ip: data.ip,\n        country: data.country_name,\n        countryCode: data.country_code,\n        region: data.region_name,\n        regionCode: data.region_code,\n        city: data.city,\n        zip: data.zip,\n        latitude: data.latitude,\n        longitude: data.longitude,\n        timezone: data.time_zone?.id || '',\n        isp: data.connection?.isp || '',\n        org: data.connection?.organization || '',\n        as: data.connection?.asn || '',\n      };\n\n      this.cache.set(cacheKey, geoData);\n      return geoData;\n    } catch (error) {\n      console.error('IP geolocation error:', error);\n      throw error;\n    }\n  }\n\n  async getBulkLocations(ips: string[]): Promise<Map<string, IPGeolocationData>> {\n    const results = new Map<string, IPGeolocationData>();\n    const uncachedIPs: string[] = [];\n\n    // Check cache first\n    for (const ip of ips) {\n      const cached = this.cache.get(`ip-${ip}`);\n      if (cached) {\n        results.set(ip, cached);\n      } else {\n        uncachedIPs.push(ip);\n      }\n    }\n\n    // Fetch uncached IPs in batches\n    const batchSize = 50;\n    for (let i = 0; i < uncachedIPs.length; i += batchSize) {\n      const batch = uncachedIPs.slice(i, i + batchSize);\n      const batchPromises = batch.map(ip => this.getLocationByIP(ip));\n      \n      try {\n        const batchResults = await Promise.allSettled(batchPromises);\n        \n        batchResults.forEach((result, index) => {\n          if (result.status === 'fulfilled') {\n            const ip = batch[index];\n            results.set(ip, result.value);\n          }\n        });\n      } catch (error) {\n        console.error('Batch IP geolocation error:', error);\n      }\n    }\n\n    return results;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"server-side-geo-targeting",children:"Server-Side Geo-targeting"}),"\n",(0,r.jsx)(e.h3,{id:"nestjs-geo-targeting-service",children:"NestJS Geo-targeting Service"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/geotargeting/geotargeting.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Request } from 'express';\nimport geoip from 'geoip-lite';\nimport { GeoLocation } from './entities/geo-location.entity';\nimport { GeoRule } from './entities/geo-rule.entity';\n\nexport interface LocationInfo {\n  ip: string;\n  country: string;\n  countryCode: string;\n  region: string;\n  city: string;\n  latitude: number;\n  longitude: number;\n  timezone: string;\n  accuracy: 'high' | 'medium' | 'low';\n  source: 'browser' | 'ip' | 'header' | 'default';\n}\n\nexport interface GeoTargetingContext {\n  location: LocationInfo;\n  rules: GeoRule[];\n  content: any;\n  restrictions: string[];\n}\n\n@Injectable()\nexport class GeotargetingService {\n  private readonly logger = new Logger(GeotargetingService.name);\n\n  constructor(\n    private configService: ConfigService,\n    @InjectRepository(GeoLocation)\n    private geoLocationRepository: Repository<GeoLocation>,\n    @InjectRepository(GeoRule)\n    private geoRuleRepository: Repository<GeoRule>,\n  ) {}\n\n  async detectLocationFromRequest(request: Request): Promise<LocationInfo> {\n    const ip = this.extractIP(request);\n    \n    // Try to get location from headers first (CDN/proxy headers)\n    const headerLocation = this.getLocationFromHeaders(request);\n    if (headerLocation) {\n      return {\n        ...headerLocation,\n        ip,\n        accuracy: 'high',\n        source: 'header',\n      };\n    }\n\n    // Fallback to IP geolocation\n    const geoData = geoip.lookup(ip);\n    if (geoData) {\n      return {\n        ip,\n        country: geoData.country,\n        countryCode: geoData.country,\n        region: geoData.region,\n        city: geoData.city,\n        latitude: geoData.ll[0],\n        longitude: geoData.ll[1],\n        timezone: geoData.timezone,\n        accuracy: 'medium',\n        source: 'ip',\n      };\n    }\n\n    // Default fallback\n    return this.getDefaultLocation(ip);\n  }\n\n  private extractIP(request: Request): string {\n    const forwarded = request.headers['x-forwarded-for'] as string;\n    const realIP = request.headers['x-real-ip'] as string;\n    const remoteAddress = request.connection?.remoteAddress;\n\n    if (forwarded) {\n      return forwarded.split(',')[0].trim();\n    }\n    \n    if (realIP) {\n      return realIP;\n    }\n\n    return remoteAddress || '127.0.0.1';\n  }\n\n  private getLocationFromHeaders(request: Request): Partial<LocationInfo> | null {\n    const cfCountry = request.headers['cf-ipcountry'] as string;\n    const cfRegion = request.headers['cf-region'] as string;\n    const cfCity = request.headers['cf-city'] as string;\n\n    if (cfCountry && cfCountry !== 'XX') {\n      return {\n        country: cfCountry,\n        countryCode: cfCountry,\n        region: cfRegion || '',\n        city: cfCity || '',\n        latitude: 0,\n        longitude: 0,\n        timezone: '',\n      };\n    }\n\n    return null;\n  }\n\n  private getDefaultLocation(ip: string): LocationInfo {\n    return {\n      ip,\n      country: 'Unknown',\n      countryCode: 'XX',\n      region: '',\n      city: '',\n      latitude: 0,\n      longitude: 0,\n      timezone: 'UTC',\n      accuracy: 'low',\n      source: 'default',\n    };\n  }\n\n  async getGeoTargetingContext(\n    location: LocationInfo,\n    userId?: string\n  ): Promise<GeoTargetingContext> {\n    // Get applicable geo rules\n    const rules = await this.geoRuleRepository\n      .createQueryBuilder('rule')\n      .where('rule.isActive = :isActive', { isActive: true })\n      .andWhere(\n        '(rule.countries IS NULL OR :country = ANY(rule.countries))',\n        { country: location.countryCode }\n      )\n      .andWhere(\n        '(rule.regions IS NULL OR :region = ANY(rule.regions))',\n        { region: location.region }\n      )\n      .orderBy('rule.priority', 'DESC')\n      .getMany();\n\n    // Get geo-specific content\n    const content = await this.getGeoContent(location, rules);\n\n    // Check restrictions\n    const restrictions = this.checkRestrictions(location, rules);\n\n    return {\n      location,\n      rules,\n      content,\n      restrictions,\n    };\n  }\n\n  private async getGeoContent(\n    location: LocationInfo,\n    rules: GeoRule[]\n  ): Promise<any> {\n    const contentOverrides: any = {};\n\n    for (const rule of rules) {\n      if (rule.contentOverrides) {\n        Object.assign(contentOverrides, rule.contentOverrides);\n      }\n    }\n\n    return {\n      currency: this.getCurrencyForCountry(location.countryCode),\n      language: this.getLanguageForCountry(location.countryCode),\n      timezone: location.timezone,\n      ...contentOverrides,\n    };\n  }\n\n  private checkRestrictions(\n    location: LocationInfo,\n    rules: GeoRule[]\n  ): string[] {\n    const restrictions: string[] = [];\n\n    for (const rule of rules) {\n      if (rule.type === 'block' && this.ruleMatches(rule, location)) {\n        restrictions.push(rule.description || 'Content blocked in your region');\n      }\n    }\n\n    return restrictions;\n  }\n\n  private ruleMatches(rule: GeoRule, location: LocationInfo): boolean {\n    if (rule.countries && !rule.countries.includes(location.countryCode)) {\n      return false;\n    }\n\n    if (rule.regions && !rule.regions.includes(location.region)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private getCurrencyForCountry(countryCode: string): string {\n    const currencyMap: Record<string, string> = {\n      'US': 'USD',\n      'GB': 'GBP',\n      'DE': 'EUR',\n      'FR': 'EUR',\n      'JP': 'JPY',\n      'CA': 'CAD',\n      'AU': 'AUD',\n      // Add more mappings\n    };\n\n    return currencyMap[countryCode] || 'USD';\n  }\n\n  private getLanguageForCountry(countryCode: string): string {\n    const languageMap: Record<string, string> = {\n      'US': 'en',\n      'GB': 'en',\n      'DE': 'de',\n      'FR': 'fr',\n      'ES': 'es',\n      'JP': 'ja',\n      // Add more mappings\n    };\n\n    return languageMap[countryCode] || 'en';\n  }\n\n  async saveLocationHistory(\n    userId: string,\n    location: LocationInfo\n  ): Promise<GeoLocation> {\n    const geoLocation = this.geoLocationRepository.create({\n      userId,\n      ip: location.ip,\n      country: location.country,\n      countryCode: location.countryCode,\n      region: location.region,\n      city: location.city,\n      latitude: location.latitude,\n      longitude: location.longitude,\n      timezone: location.timezone,\n      accuracy: location.accuracy,\n      source: location.source,\n      timestamp: new Date(),\n    });\n\n    return this.geoLocationRepository.save(geoLocation);\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"geo-targeting-decorator",children:"Geo-targeting Decorator"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/geotargeting/decorators/geo-targeting.decorator.ts\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\nimport { Request } from 'express';\n\nexport const GeoLocation = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest<Request>();\n    return request['geoLocation'];\n  },\n);\n\nexport const GeoContext = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest<Request>();\n    return request['geoContext'];\n  },\n);\n"})}),"\n",(0,r.jsx)(e.h3,{id:"geo-targeting-middleware",children:"Geo-targeting Middleware"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/geotargeting/middleware/geo-targeting.middleware.ts\nimport { Injectable, NestMiddleware } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport { GeotargetingService } from '../geotargeting.service';\n\n@Injectable()\nexport class GeoTargetingMiddleware implements NestMiddleware {\n  constructor(private readonly geotargetingService: GeotargetingService) {}\n\n  async use(req: Request, res: Response, next: NextFunction) {\n    try {\n      // Detect location from request\n      const location = await this.geotargetingService.detectLocationFromRequest(req);\n      req['geoLocation'] = location;\n\n      // Get geo-targeting context\n      const userId = req['user']?.id; // Assuming auth middleware sets user\n      const geoContext = await this.geotargetingService.getGeoTargetingContext(\n        location,\n        userId\n      );\n      req['geoContext'] = geoContext;\n\n      // Save location history for authenticated users\n      if (userId) {\n        await this.geotargetingService.saveLocationHistory(userId, location);\n      }\n\n      next();\n    } catch (error) {\n      console.error('Geo-targeting middleware error:', error);\n      // Continue without geo-targeting if there's an error\n      next();\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"database-design",children:"Database Design"}),"\n",(0,r.jsx)(e.h3,{id:"entity-definitions",children:"Entity Definitions"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/geotargeting/entities/geo-location.entity.ts\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, Index } from 'typeorm';\n\n@Entity('geo_locations')\n@Index(['userId', 'timestamp'])\n@Index(['countryCode', 'region'])\nexport class GeoLocation {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ nullable: true })\n  userId: string;\n\n  @Column()\n  ip: string;\n\n  @Column()\n  country: string;\n\n  @Column({ length: 2 })\n  countryCode: string;\n\n  @Column({ nullable: true })\n  region: string;\n\n  @Column({ nullable: true })\n  city: string;\n\n  @Column('decimal', { precision: 10, scale: 8, nullable: true })\n  latitude: number;\n\n  @Column('decimal', { precision: 11, scale: 8, nullable: true })\n  longitude: number;\n\n  @Column({ nullable: true })\n  timezone: string;\n\n  @Column({\n    type: 'enum',\n    enum: ['high', 'medium', 'low'],\n    default: 'medium'\n  })\n  accuracy: string;\n\n  @Column({\n    type: 'enum',\n    enum: ['browser', 'ip', 'header', 'default'],\n    default: 'ip'\n  })\n  source: string;\n\n  @CreateDateColumn()\n  timestamp: Date;\n}\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/geotargeting/entities/geo-rule.entity.ts\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';\n\n@Entity('geo_rules')\nexport class GeoRule {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column()\n  name: string;\n\n  @Column({ nullable: true })\n  description: string;\n\n  @Column({\n    type: 'enum',\n    enum: ['allow', 'block', 'redirect', 'content'],\n    default: 'content'\n  })\n  type: string;\n\n  @Column('simple-array', { nullable: true })\n  countries: string[];\n\n  @Column('simple-array', { nullable: true })\n  regions: string[];\n\n  @Column('simple-array', { nullable: true })\n  cities: string[];\n\n  @Column('jsonb', { nullable: true })\n  contentOverrides: any;\n\n  @Column({ nullable: true })\n  redirectUrl: string;\n\n  @Column({ default: 0 })\n  priority: number;\n\n  @Column({ default: true })\n  isActive: boolean;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n}\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/geotargeting/entities/geo-content.entity.ts\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, Index } from 'typeorm';\n\n@Entity('geo_contents')\n@Index(['contentType', 'countryCode'])\nexport class GeoContent {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column()\n  contentType: string; // 'pricing', 'features', 'legal', etc.\n\n  @Column({ length: 2 })\n  countryCode: string;\n\n  @Column({ nullable: true })\n  region: string;\n\n  @Column({ nullable: true })\n  language: string;\n\n  @Column({ nullable: true })\n  currency: string;\n\n  @Column('jsonb')\n  content: any;\n\n  @Column({ default: true })\n  isActive: boolean;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"api-implementation",children:"API Implementation"}),"\n",(0,r.jsx)(e.h3,{id:"geo-targeting-controller",children:"Geo-targeting Controller"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// src/geotargeting/geotargeting.controller.ts\nimport { \n  Controller, \n  Get, \n  Post, \n  Body, \n  Param, \n  Query,\n  UseGuards,\n  Request\n} from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';\nimport { GeotargetingService, LocationInfo, GeoTargetingContext } from './geotargeting.service';\nimport { GeoLocation, GeoContext } from './decorators/geo-targeting.decorator';\nimport { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';\n\n@ApiTags('Geo-targeting')\n@Controller('geo')\nexport class GeotargetingController {\n  constructor(private readonly geotargetingService: GeotargetingService) {}\n\n  @Get('location')\n  @ApiOperation({ summary: 'Get current user location' })\n  @ApiResponse({ status: 200, description: 'Location detected successfully' })\n  async getCurrentLocation(@GeoLocation() location: LocationInfo) {\n    return {\n      success: true,\n      data: location,\n    };\n  }\n\n  @Get('context')\n  @ApiOperation({ summary: 'Get geo-targeting context' })\n  @ApiResponse({ status: 200, description: 'Geo context retrieved successfully' })\n  async getGeoContext(@GeoContext() geoContext: GeoTargetingContext) {\n    return {\n      success: true,\n      data: geoContext,\n    };\n  }\n\n  @Get('content/:type')\n  @ApiOperation({ summary: 'Get geo-specific content' })\n  async getGeoContent(\n    @Param('type') contentType: string,\n    @GeoLocation() location: LocationInfo\n  ) {\n    const content = await this.geotargetingService.getGeoContent(\n      contentType,\n      location.countryCode,\n      location.region\n    );\n\n    return {\n      success: true,\n      data: content,\n    };\n  }\n\n  @Post('preferences')\n  @UseGuards(JwtAuthGuard)\n  @ApiOperation({ summary: 'Update user geo preferences' })\n  async updateGeoPreferences(\n    @Request() req,\n    @Body() preferences: any\n  ) {\n    const userId = req.user.id;\n    const updated = await this.geotargetingService.updateUserGeoPreferences(\n      userId,\n      preferences\n    );\n\n    return {\n      success: true,\n      data: updated,\n    };\n  }\n\n  @Get('history')\n  @UseGuards(JwtAuthGuard)\n  @ApiOperation({ summary: 'Get user location history' })\n  async getLocationHistory(\n    @Request() req,\n    @Query('limit') limit: number = 10\n  ) {\n    const userId = req.user.id;\n    const history = await this.geotargetingService.getLocationHistory(\n      userId,\n      limit\n    );\n\n    return {\n      success: true,\n      data: history,\n    };\n  }\n\n  @Get('pricing')\n  @ApiOperation({ summary: 'Get geo-specific pricing' })\n  async getGeoPricing(@GeoLocation() location: LocationInfo) {\n    const pricing = await this.geotargetingService.getGeoPricing(\n      location.countryCode,\n      location.region\n    );\n\n    return {\n      success: true,\n      data: pricing,\n    };\n  }\n\n  @Get('restrictions')\n  @ApiOperation({ summary: 'Check geo restrictions' })\n  async checkRestrictions(\n    @GeoLocation() location: LocationInfo,\n    @Query('feature') feature?: string\n  ) {\n    const restrictions = await this.geotargetingService.checkFeatureRestrictions(\n      location,\n      feature\n    );\n\n    return {\n      success: true,\n      data: restrictions,\n    };\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"frontend-implementation",children:"Frontend Implementation"}),"\n",(0,r.jsx)(e.h3,{id:"react-geo-targeting-hook",children:"React Geo-targeting Hook"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// hooks/useGeoTargeting.ts\nimport { useState, useEffect, useCallback } from 'react';\nimport { GeolocationService, GeolocationData } from '../utils/geolocation';\nimport { IPGeolocationService, IPGeolocationData } from '../services/ip-geolocation';\n\nexport interface GeoTargetingData {\n  location: GeolocationData | IPGeolocationData | null;\n  country: string;\n  countryCode: string;\n  currency: string;\n  language: string;\n  timezone: string;\n  restrictions: string[];\n  loading: boolean;\n  error: string | null;\n}\n\nexport interface GeoTargetingOptions {\n  enableBrowserGeolocation?: boolean;\n  fallbackToIP?: boolean;\n  cacheResults?: boolean;\n  onLocationChange?: (data: GeoTargetingData) => void;\n}\n\nexport const useGeoTargeting = (options: GeoTargetingOptions = {}) => {\n  const {\n    enableBrowserGeolocation = true,\n    fallbackToIP = true,\n    cacheResults = true,\n    onLocationChange,\n  } = options;\n\n  const [geoData, setGeoData] = useState<GeoTargetingData>({\n    location: null,\n    country: '',\n    countryCode: '',\n    currency: 'USD',\n    language: 'en',\n    timezone: 'UTC',\n    restrictions: [],\n    loading: true,\n    error: null,\n  });\n\n  const geolocationService = GeolocationService.getInstance();\n  const ipGeolocationService = new IPGeolocationService(\n    process.env.NEXT_PUBLIC_IP_API_KEY || ''\n  );\n\n  const updateGeoData = useCallback(async () => {\n    try {\n      setGeoData(prev => ({ ...prev, loading: true, error: null }));\n\n      let locationData: any = null;\n      let source = 'none';\n\n      // Try browser geolocation first\n      if (enableBrowserGeolocation) {\n        try {\n          locationData = await geolocationService.getCurrentPosition({\n            timeout: 5000,\n            maximumAge: 300000,\n          });\n          source = 'browser';\n        } catch (error) {\n          console.warn('Browser geolocation failed:', error);\n        }\n      }\n\n      // Fallback to IP geolocation\n      if (!locationData && fallbackToIP) {\n        try {\n          locationData = await ipGeolocationService.getLocationByIP();\n          source = 'ip';\n        } catch (error) {\n          console.warn('IP geolocation failed:', error);\n        }\n      }\n\n      if (locationData) {\n        // Get geo context from backend\n        const geoContext = await fetchGeoContext(locationData);\n        \n        const newGeoData: GeoTargetingData = {\n          location: locationData,\n          country: geoContext.country || '',\n          countryCode: geoContext.countryCode || '',\n          currency: geoContext.currency || 'USD',\n          language: geoContext.language || 'en',\n          timezone: geoContext.timezone || 'UTC',\n          restrictions: geoContext.restrictions || [],\n          loading: false,\n          error: null,\n        };\n\n        setGeoData(newGeoData);\n        \n        if (onLocationChange) {\n          onLocationChange(newGeoData);\n        }\n\n        // Cache results\n        if (cacheResults) {\n          localStorage.setItem('geoTargetingData', JSON.stringify(newGeoData));\n        }\n      } else {\n        throw new Error('Unable to determine location');\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setGeoData(prev => ({\n        ...prev,\n        loading: false,\n        error: errorMessage,\n      }));\n    }\n  }, [enableBrowserGeolocation, fallbackToIP, cacheResults, onLocationChange]);\n\n  const fetchGeoContext = async (location: any) => {\n    try {\n      const response = await fetch('/api/geo/context', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ location }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to fetch geo context');\n      }\n\n      const result = await response.json();\n      return result.data;\n    } catch (error) {\n      console.error('Error fetching geo context:', error);\n      return {};\n    }\n  };\n\n  const refreshLocation = useCallback(() => {\n    updateGeoData();\n  }, [updateGeoData]);\n\n  useEffect(() => {\n    // Try to load from cache first\n    if (cacheResults) {\n      const cached = localStorage.getItem('geoTargetingData');\n      if (cached) {\n        try {\n          const parsedData = JSON.parse(cached);\n          setGeoData(parsedData);\n        } catch (error) {\n          console.warn('Invalid cached geo data:', error);\n        }\n      }\n    }\n\n    // Then update with fresh data\n    updateGeoData();\n  }, [updateGeoData, cacheResults]);\n\n  return {\n    ...geoData,\n    refreshLocation,\n  };\n};\n"})}),"\n",(0,r.jsx)(e.h3,{id:"geo-targeted-component",children:"Geo-targeted Component"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:'// components/GeoTargetedContent.tsx\nimport React from \'react\';\nimport { useGeoTargeting } from \'../hooks/useGeoTargeting\';\n\ninterface GeoTargetedContentProps {\n  children?: React.ReactNode;\n  fallback?: React.ReactNode;\n  allowedCountries?: string[];\n  blockedCountries?: string[];\n  showRestrictionMessage?: boolean;\n}\n\nexport const GeoTargetedContent: React.FC<GeoTargetedContentProps> = ({\n  children,\n  fallback,\n  allowedCountries,\n  blockedCountries,\n  showRestrictionMessage = true,\n}) => {\n  const { countryCode, restrictions, loading, error } = useGeoTargeting();\n\n  if (loading) {\n    return (\n      <div className="flex items-center justify-center p-4">\n        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>\n        <span className="ml-2">Detecting location...</span>\n      </div>\n    );\n  }\n\n  if (error) {\n    return fallback || (\n      <div className="p-4 text-yellow-600 bg-yellow-50 rounded-md">\n        Unable to detect location. Showing default content.\n      </div>\n    );\n  }\n\n  // Check country restrictions\n  if (allowedCountries && !allowedCountries.includes(countryCode)) {\n    return showRestrictionMessage ? (\n      <div className="p-4 text-red-600 bg-red-50 rounded-md">\n        This content is not available in your region.\n      </div>\n    ) : null;\n  }\n\n  if (blockedCountries && blockedCountries.includes(countryCode)) {\n    return showRestrictionMessage ? (\n      <div className="p-4 text-red-600 bg-red-50 rounded-md">\n        This content is restricted in your region.\n      </div>\n    ) : null;\n  }\n\n  // Check other restrictions\n  if (restrictions.length > 0) {\n    return showRestrictionMessage ? (\n      <div className="p-4 text-red-600 bg-red-50 rounded-md">\n        <ul>\n          {restrictions.map((restriction, index) => (\n            <li key={index}>{restriction}</li>\n          ))}\n        </ul>\n      </div>\n    ) : null;\n  }\n\n  return <>{children}</>;\n};\n'})}),"\n",(0,r.jsx)(e.h3,{id:"currency-display-component",children:"Currency Display Component"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:"// components/CurrencyDisplay.tsx\nimport React from 'react';\nimport { useGeoTargeting } from '../hooks/useGeoTargeting';\n\ninterface CurrencyDisplayProps {\n  amount: number;\n  showSymbol?: boolean;\n  className?: string;\n}\n\nconst CURRENCY_SYMBOLS: Record<string, string> = {\n  USD: '$',\n  EUR: '\u20ac',\n  GBP: '\xa3',\n  JPY: '\xa5',\n  CAD: 'C$',\n  AUD: 'A$',\n};\n\nconst CURRENCY_RATES: Record<string, number> = {\n  USD: 1,\n  EUR: 0.85,\n  GBP: 0.73,\n  JPY: 110,\n  CAD: 1.25,\n  AUD: 1.35,\n};\n\nexport const CurrencyDisplay: React.FC<CurrencyDisplayProps> = ({\n  amount,\n  showSymbol = true,\n  className = '',\n}) => {\n  const { currency } = useGeoTargeting();\n\n  const convertedAmount = amount * (CURRENCY_RATES[currency] || 1);\n  const symbol = CURRENCY_SYMBOLS[currency] || '$';\n\n  const formatCurrency = (value: number, currencyCode: string) => {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: currencyCode,\n      minimumFractionDigits: currencyCode === 'JPY' ? 0 : 2,\n    }).format(value);\n  };\n\n  return (\n    <span className={className}>\n      {showSymbol ? formatCurrency(convertedAmount, currency) : convertedAmount.toFixed(2)}\n    </span>\n  );\n};\n"})}),"\n",(0,r.jsx)(e.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,r.jsx)(e.h3,{id:"geo-fencing-implementation",children:"Geo-fencing Implementation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// services/geofencing.service.ts\nexport interface GeofenceArea {\n  id: string;\n  name: string;\n  type: 'circle' | 'polygon';\n  coordinates: number[][];\n  radius?: number; // for circle type\n  actions: GeofenceAction[];\n}\n\nexport interface GeofenceAction {\n  type: 'enter' | 'exit' | 'dwell';\n  trigger: string;\n  data: any;\n}\n\nexport class GeofencingService {\n  private geofences: Map<string, GeofenceArea> = new Map();\n  private userLocations: Map<string, { lat: number; lng: number; timestamp: number }> = new Map();\n\n  addGeofence(geofence: GeofenceArea): void {\n    this.geofences.set(geofence.id, geofence);\n  }\n\n  removeGeofence(geofenceId: string): void {\n    this.geofences.delete(geofenceId);\n  }\n\n  checkGeofences(\n    userId: string,\n    latitude: number,\n    longitude: number\n  ): GeofenceAction[] {\n    const actions: GeofenceAction[] = [];\n    const currentLocation = { lat: latitude, lng: longitude, timestamp: Date.now() };\n    const previousLocation = this.userLocations.get(userId);\n\n    for (const [id, geofence] of this.geofences) {\n      const isCurrentlyInside = this.isPointInGeofence(latitude, longitude, geofence);\n      const wasPreviouslyInside = previousLocation\n        ? this.isPointInGeofence(previousLocation.lat, previousLocation.lng, geofence)\n        : false;\n\n      // Check for enter/exit events\n      if (isCurrentlyInside && !wasPreviouslyInside) {\n        actions.push(...geofence.actions.filter(action => action.type === 'enter'));\n      } else if (!isCurrentlyInside && wasPreviouslyInside) {\n        actions.push(...geofence.actions.filter(action => action.type === 'exit'));\n      }\n\n      // Check for dwell events\n      if (isCurrentlyInside && wasPreviouslyInside) {\n        const dwellTime = currentLocation.timestamp - previousLocation.timestamp;\n        const dwellActions = geofence.actions.filter(\n          action => action.type === 'dwell' && dwellTime >= (action.data?.minDwellTime || 0)\n        );\n        actions.push(...dwellActions);\n      }\n    }\n\n    this.userLocations.set(userId, currentLocation);\n    return actions;\n  }\n\n  private isPointInGeofence(\n    latitude: number,\n    longitude: number,\n    geofence: GeofenceArea\n  ): boolean {\n    if (geofence.type === 'circle') {\n      const [centerLat, centerLng] = geofence.coordinates[0];\n      const distance = this.calculateDistance(latitude, longitude, centerLat, centerLng);\n      return distance <= (geofence.radius || 0);\n    } else if (geofence.type === 'polygon') {\n      return this.isPointInPolygon(latitude, longitude, geofence.coordinates);\n    }\n\n    return false;\n  }\n\n  private calculateDistance(\n    lat1: number,\n    lng1: number,\n    lat2: number,\n    lng2: number\n  ): number {\n    const R = 6371e3; // Earth's radius in meters\n    const \u03c61 = (lat1 * Math.PI) / 180;\n    const \u03c62 = (lat2 * Math.PI) / 180;\n    const \u0394\u03c6 = ((lat2 - lat1) * Math.PI) / 180;\n    const \u0394\u03bb = ((lng2 - lng1) * Math.PI) / 180;\n\n    const a =\n      Math.sin(\u0394\u03c6 / 2) * Math.sin(\u0394\u03c6 / 2) +\n      Math.cos(\u03c61) * Math.cos(\u03c62) * Math.sin(\u0394\u03bb / 2) * Math.sin(\u0394\u03bb / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c;\n  }\n\n  private isPointInPolygon(\n    latitude: number,\n    longitude: number,\n    polygon: number[][]\n  ): boolean {\n    let inside = false;\n    \n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n      const [xi, yi] = polygon[i];\n      const [xj, yj] = polygon[j];\n      \n      if (((yi > longitude) !== (yj > longitude)) &&\n          (latitude < (xj - xi) * (longitude - yi) / (yj - yi) + xi)) {\n        inside = !inside;\n      }\n    }\n    \n    return inside;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"ab-testing-with-geo-targeting",children:"A/B Testing with Geo-targeting"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// services/geo-ab-testing.service.ts\nexport interface ABTestVariant {\n  id: string;\n  name: string;\n  weight: number;\n  config: any;\n  geoRestrictions?: {\n    allowedCountries?: string[];\n    blockedCountries?: string[];\n    allowedRegions?: string[];\n    blockedRegions?: string[];\n  };\n}\n\nexport interface ABTest {\n  id: string;\n  name: string;\n  isActive: boolean;\n  variants: ABTestVariant[];\n  geoTargeting: {\n    enabled: boolean;\n    defaultVariant: string;\n  };\n}\n\n@Injectable()\nexport class GeoABTestingService {\n  constructor(\n    @InjectRepository(ABTest)\n    private abTestRepository: Repository<ABTest>,\n  ) {}\n\n  async getVariantForUser(\n    testId: string,\n    userId: string,\n    location: LocationInfo\n  ): Promise<ABTestVariant | null> {\n    const test = await this.abTestRepository.findOne({\n      where: { id: testId, isActive: true },\n      relations: ['variants'],\n    });\n\n    if (!test) {\n      return null;\n    }\n\n    // Filter variants based on geo restrictions\n    const eligibleVariants = test.variants.filter(variant =>\n      this.isVariantEligibleForLocation(variant, location)\n    );\n\n    if (eligibleVariants.length === 0) {\n      // Return default variant if no eligible variants\n      return test.variants.find(v => v.id === test.geoTargeting.defaultVariant) || null;\n    }\n\n    // Use consistent hashing to assign variant\n    const hash = this.hashUserLocation(userId, location.countryCode);\n    const totalWeight = eligibleVariants.reduce((sum, v) => sum + v.weight, 0);\n    const threshold = (hash % 100) / 100 * totalWeight;\n\n    let weightSum = 0;\n    for (const variant of eligibleVariants) {\n      weightSum += variant.weight;\n      if (threshold <= weightSum) {\n        return variant;\n      }\n    }\n\n    return eligibleVariants[0];\n  }\n\n  private isVariantEligibleForLocation(\n    variant: ABTestVariant,\n    location: LocationInfo\n  ): boolean {\n    const restrictions = variant.geoRestrictions;\n    if (!restrictions) {\n      return true;\n    }\n\n    // Check country restrictions\n    if (restrictions.allowedCountries && \n        !restrictions.allowedCountries.includes(location.countryCode)) {\n      return false;\n    }\n\n    if (restrictions.blockedCountries && \n        restrictions.blockedCountries.includes(location.countryCode)) {\n      return false;\n    }\n\n    // Check region restrictions\n    if (restrictions.allowedRegions && location.region &&\n        !restrictions.allowedRegions.includes(location.region)) {\n      return false;\n    }\n\n    if (restrictions.blockedRegions && location.region &&\n        restrictions.blockedRegions.includes(location.region)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private hashUserLocation(userId: string, countryCode: string): number {\n    const str = `${userId}-${countryCode}`;\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash);\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(e.h3,{id:"caching-strategy",children:"Caching Strategy"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// services/geo-cache.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { InjectRedis } from '@nestjs-modules/ioredis';\nimport { Redis } from 'ioredis';\n\n@Injectable()\nexport class GeoCacheService {\n  constructor(@InjectRedis() private readonly redis: Redis) {}\n\n  private getKey(type: string, identifier: string): string {\n    return `geo:${type}:${identifier}`;\n  }\n\n  async cacheLocationData(\n    ip: string,\n    locationData: any,\n    ttlSeconds: number = 3600\n  ): Promise<void> {\n    const key = this.getKey('location', ip);\n    await this.redis.setex(key, ttlSeconds, JSON.stringify(locationData));\n  }\n\n  async getCachedLocationData(ip: string): Promise<any | null> {\n    const key = this.getKey('location', ip);\n    const cached = await this.redis.get(key);\n    return cached ? JSON.parse(cached) : null;\n  }\n\n  async cacheGeoContent(\n    contentType: string,\n    countryCode: string,\n    content: any,\n    ttlSeconds: number = 1800\n  ): Promise<void> {\n    const key = this.getKey('content', `${contentType}:${countryCode}`);\n    await this.redis.setex(key, ttlSeconds, JSON.stringify(content));\n  }\n\n  async getCachedGeoContent(\n    contentType: string,\n    countryCode: string\n  ): Promise<any | null> {\n    const key = this.getKey('content', `${contentType}:${countryCode}`);\n    const cached = await this.redis.get(key);\n    return cached ? JSON.parse(cached) : null;\n  }\n\n  async cacheGeoRules(\n    countryCode: string,\n    rules: any[],\n    ttlSeconds: number = 900\n  ): Promise<void> {\n    const key = this.getKey('rules', countryCode);\n    await this.redis.setex(key, ttlSeconds, JSON.stringify(rules));\n  }\n\n  async getCachedGeoRules(countryCode: string): Promise<any[] | null> {\n    const key = this.getKey('rules', countryCode);\n    const cached = await this.redis.get(key);\n    return cached ? JSON.parse(cached) : null;\n  }\n\n  async invalidateCache(pattern: string): Promise<void> {\n    const keys = await this.redis.keys(`geo:${pattern}*`);\n    if (keys.length > 0) {\n      await this.redis.del(...keys);\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"cdn-integration",children:"CDN Integration"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// services/cdn-geo.service.ts\nexport class CDNGeoService {\n  async getCloudflareCountry(request: Request): string | null {\n    return request.headers['cf-ipcountry'] as string || null;\n  }\n\n  async getAWSCloudFrontCountry(request: Request): string | null {\n    return request.headers['cloudfront-viewer-country'] as string || null;\n  }\n\n  async getFastlyCountry(request: Request): string | null {\n    return request.headers['fastly-geoip-country-code'] as string || null;\n  }\n\n  async getBestLocationSource(request: Request): {\n    country: string;\n    source: string;\n    accuracy: string;\n  } {\n    // Try CDN headers first (most accurate for CDN-delivered content)\n    const cfCountry = await this.getCloudflareCountry(request);\n    if (cfCountry && cfCountry !== 'XX') {\n      return { country: cfCountry, source: 'cloudflare', accuracy: 'high' };\n    }\n\n    const awsCountry = await this.getAWSCloudFrontCountry(request);\n    if (awsCountry) {\n      return { country: awsCountry, source: 'cloudfront', accuracy: 'high' };\n    }\n\n    const fastlyCountry = await this.getFastlyCountry(request);\n    if (fastlyCountry) {\n      return { country: fastlyCountry, source: 'fastly', accuracy: 'high' };\n    }\n\n    // Fallback to IP-based detection\n    return { country: 'XX', source: 'fallback', accuracy: 'low' };\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"privacy-and-compliance",children:"Privacy and Compliance"}),"\n",(0,r.jsx)(e.h3,{id:"gdpr-compliance",children:"GDPR Compliance"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// services/geo-privacy.service.ts\n@Injectable()\nexport class GeoPrivacyService {\n  async checkGDPRRequirements(countryCode: string): Promise<{\n    requiresConsent: boolean;\n    requiresOptOut: boolean;\n    dataRetentionDays: number;\n  }> {\n    const gdprCountries = [\n      'AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR',\n      'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL',\n      'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'\n    ];\n\n    const isGDPRCountry = gdprCountries.includes(countryCode);\n\n    return {\n      requiresConsent: isGDPRCountry,\n      requiresOptOut: isGDPRCountry,\n      dataRetentionDays: isGDPRCountry ? 90 : 365,\n    };\n  }\n\n  async anonymizeLocationData(locationData: any): Promise<any> {\n    return {\n      ...locationData,\n      ip: this.anonymizeIP(locationData.ip),\n      latitude: this.roundCoordinate(locationData.latitude, 2),\n      longitude: this.roundCoordinate(locationData.longitude, 2),\n    };\n  }\n\n  private anonymizeIP(ip: string): string {\n    const parts = ip.split('.');\n    if (parts.length === 4) {\n      return `${parts[0]}.${parts[1]}.${parts[2]}.0`;\n    }\n    return ip;\n  }\n\n  private roundCoordinate(coord: number, precision: number): number {\n    const factor = Math.pow(10, precision);\n    return Math.round(coord * factor) / factor;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"This comprehensive geo-targeting implementation provides a robust foundation for location-based features while maintaining privacy compliance and performance optimization. The modular design allows for easy customization and extension based on specific business requirements."})]})}function g(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}}}]);