"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[7238],{1641:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"architecture-practices/architecture-execution/automated-deployment","title":"Automated Deployment Guide","description":"This guide provides comprehensive automated deployment strategies for NestJS microservices and Next.js microfrontend applications using GitOps, container orchestration, blue-green deployments, and progressive delivery techniques.","source":"@site/docs/architecture-practices/architecture-execution/automated-deployment.md","sourceDirName":"architecture-practices/architecture-execution","slug":"/architecture-practices/architecture-execution/automated-deployment","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/automated-deployment","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-execution/automated-deployment.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Configuration Management Guide","permalink":"/fullstack-dev/docs/architecture-practices/architecture-execution/configuration-management"},"next":{"title":"GitOps Microservices Deployment Guide: Node.js on GCP GKE with Kustomize and ArgoCD","permalink":"/fullstack-dev/docs/devops/gitops-microservices-gcp-guide"}}');var s=t(5813),i=t(5741);const o={},a="Automated Deployment Guide",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Deployment Architecture",id:"deployment-architecture",level:2},{value:"Complete Deployment Pipeline",id:"complete-deployment-pipeline",level:3},{value:"Container Configuration",id:"container-configuration",level:2},{value:"Multi-stage Dockerfile for NestJS",id:"multi-stage-dockerfile-for-nestjs",level:3},{value:"Multi-stage Dockerfile for Next.js",id:"multi-stage-dockerfile-for-nextjs",level:3},{value:"Docker Compose for Development",id:"docker-compose-for-development",level:3},{value:"Kubernetes Deployment Manifests",id:"kubernetes-deployment-manifests",level:2},{value:"NestJS Service Deployment",id:"nestjs-service-deployment",level:3},{value:"Next.js Frontend Deployment",id:"nextjs-frontend-deployment",level:3},{value:"GitOps with ArgoCD",id:"gitops-with-argocd",level:2},{value:"ArgoCD Application Configuration",id:"argocd-application-configuration",level:3},{value:"Kustomization Structure",id:"kustomization-structure",level:3},{value:"CI/CD Pipeline Configuration",id:"cicd-pipeline-configuration",level:2},{value:"GitHub Actions Workflow",id:"github-actions-workflow",level:3},{value:"Advanced Deployment Strategies",id:"advanced-deployment-strategies",level:2},{value:"Blue-Green Deployment",id:"blue-green-deployment",level:3},{value:"Canary Deployment with Flagger",id:"canary-deployment-with-flagger",level:3},{value:"Rollback Automation",id:"rollback-automation",level:2},{value:"Automated Rollback Script",id:"automated-rollback-script",level:3},{value:"Deployment Health Checks",id:"deployment-health-checks",level:2},{value:"Comprehensive Health Check Service",id:"comprehensive-health-check-service",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"automated-deployment-guide",children:"Automated Deployment Guide"})}),"\n",(0,s.jsx)(n.p,{children:"This guide provides comprehensive automated deployment strategies for NestJS microservices and Next.js microfrontend applications using GitOps, container orchestration, blue-green deployments, and progressive delivery techniques."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Automated deployment ensures consistent, reliable, and efficient software delivery across environments. This guide covers containerization, Kubernetes deployments, CI/CD pipelines, GitOps workflows, and advanced deployment strategies for microservices and microfrontend architectures."}),"\n",(0,s.jsx)(n.h2,{id:"deployment-architecture",children:"Deployment Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"complete-deployment-pipeline",children:"Complete Deployment Pipeline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Source Code] --\x3e B[Git Repository]\n    B --\x3e C[CI Pipeline]\n    C --\x3e D[Build & Test]\n    D --\x3e E[Container Registry]\n    E --\x3e F[GitOps Repository]\n    \n    F --\x3e G[ArgoCD/Flux]\n    G --\x3e H[Kubernetes Cluster]\n    H --\x3e I[Development]\n    H --\x3e J[Staging]\n    H --\x3e K[Production]\n    \n    L[Monitoring] --\x3e M[Deployment Metrics]\n    M --\x3e N[Rollback Decision]\n    N --\x3e O[Automatic Rollback]\n    \n    P[Feature Flags] --\x3e Q[Progressive Delivery]\n    Q --\x3e R[Canary Deployment]\n    Q --\x3e S[Blue-Green Deployment]\n    \n    I --\x3e L\n    J --\x3e L\n    K --\x3e L\n    \n    R --\x3e K\n    S --\x3e K\n"})}),"\n",(0,s.jsx)(n.h2,{id:"container-configuration",children:"Container Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"multi-stage-dockerfile-for-nestjs",children:"Multi-stage Dockerfile for NestJS"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dockerfile",children:'# Dockerfile.nestjs\n# Build stage\nFROM node:18-alpine AS builder\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\nCOPY pnpm-lock.yaml ./\n\n# Install dependencies\nRUN npm install -g pnpm\nRUN pnpm install --frozen-lockfile\n\n# Copy source code\nCOPY . .\n\n# Build application\nRUN pnpm run build\n\n# Production stage\nFROM node:18-alpine AS production\n\n# Create app directory\nWORKDIR /app\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs\nRUN adduser -S nestjs -u 1001\n\n# Copy package files\nCOPY package*.json ./\nCOPY pnpm-lock.yaml ./\n\n# Install production dependencies only\nRUN npm install -g pnpm\nRUN pnpm install --frozen-lockfile --prod\n\n# Copy built application\nCOPY --from=builder --chown=nestjs:nodejs /app/dist ./dist\nCOPY --from=builder --chown=nestjs:nodejs /app/node_modules ./node_modules\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD node dist/health-check.js\n\n# Security: Run as non-root user\nUSER nestjs\n\n# Expose port\nEXPOSE 3000\n\n# Set environment variables\nENV NODE_ENV=production\nENV PORT=3000\n\n# Start application\nCMD ["node", "dist/main.js"]\n'})}),"\n",(0,s.jsx)(n.h3,{id:"multi-stage-dockerfile-for-nextjs",children:"Multi-stage Dockerfile for Next.js"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dockerfile",children:'# Dockerfile.nextjs\n# Dependencies stage\nFROM node:18-alpine AS deps\nRUN apk add --no-cache libc6-compat\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\nCOPY pnpm-lock.yaml ./\n\n# Install dependencies\nRUN npm install -g pnpm\nRUN pnpm install --frozen-lockfile\n\n# Builder stage\nFROM node:18-alpine AS builder\nWORKDIR /app\n\n# Copy dependencies\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY . .\n\n# Set environment variables for build\nARG NEXT_PUBLIC_API_BASE_URL\nARG NEXT_PUBLIC_ENVIRONMENT\nENV NEXT_PUBLIC_API_BASE_URL=$NEXT_PUBLIC_API_BASE_URL\nENV NEXT_PUBLIC_ENVIRONMENT=$NEXT_PUBLIC_ENVIRONMENT\n\n# Build application\nRUN npm install -g pnpm\nRUN pnpm run build\n\n# Production stage\nFROM node:18-alpine AS runner\nWORKDIR /app\n\n# Create non-root user\nRUN addgroup --system --gid 1001 nodejs\nRUN adduser --system --uid 1001 nextjs\n\n# Copy built application\nCOPY --from=builder /app/public ./public\nCOPY --from=builder /app/package.json ./package.json\n\n# Copy built files with proper ownership\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD wget --no-verbose --tries=1 --spider http://localhost:3000/api/health || exit 1\n\n# Security: Run as non-root user\nUSER nextjs\n\n# Expose port\nEXPOSE 3000\n\n# Set environment variables\nENV NODE_ENV=production\nENV PORT=3000\n\n# Start application\nCMD ["node", "server.js"]\n'})}),"\n",(0,s.jsx)(n.h3,{id:"docker-compose-for-development",children:"Docker Compose for Development"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# docker-compose.yml\nversion: \'3.8\'\n\nservices:\n  # Database\n  postgres:\n    image: postgres:15-alpine\n    container_name: postgres-db\n    environment:\n      POSTGRES_DB: microservice_dev\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: postgres\n    ports:\n      - "5432:5432"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql\n    healthcheck:\n      test: ["CMD-SHELL", "pg_isready -U postgres"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  # Redis\n  redis:\n    image: redis:7-alpine\n    container_name: redis-cache\n    ports:\n      - "6379:6379"\n    volumes:\n      - redis_data:/data\n    healthcheck:\n      test: ["CMD", "redis-cli", "ping"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  # NestJS API Gateway\n  api-gateway:\n    build:\n      context: ./services/api-gateway\n      dockerfile: Dockerfile.nestjs\n    container_name: api-gateway\n    ports:\n      - "3001:3000"\n    environment:\n      - NODE_ENV=development\n      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/microservice_dev\n      - REDIS_URL=redis://redis:6379\n      - JWT_SECRET=dev-secret-key\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    volumes:\n      - ./services/api-gateway:/app\n      - /app/node_modules\n    command: pnpm run start:dev\n\n  # User Service\n  user-service:\n    build:\n      context: ./services/user-service\n      dockerfile: Dockerfile.nestjs\n    container_name: user-service\n    ports:\n      - "3002:3000"\n    environment:\n      - NODE_ENV=development\n      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/microservice_dev\n      - REDIS_URL=redis://redis:6379\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    volumes:\n      - ./services/user-service:/app\n      - /app/node_modules\n\n  # Product Service\n  product-service:\n    build:\n      context: ./services/product-service\n      dockerfile: Dockerfile.nestjs\n    container_name: product-service\n    ports:\n      - "3003:3000"\n    environment:\n      - NODE_ENV=development\n      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/microservice_dev\n      - REDIS_URL=redis://redis:6379\n    depends_on:\n      postgres:\n        condition: service_healthy\n    volumes:\n      - ./services/product-service:/app\n      - /app/node_modules\n\n  # Next.js Frontend\n  frontend:\n    build:\n      context: ./frontend\n      dockerfile: Dockerfile.nextjs\n      args:\n        - NEXT_PUBLIC_API_BASE_URL=http://localhost:3001\n        - NEXT_PUBLIC_ENVIRONMENT=development\n    container_name: frontend\n    ports:\n      - "3000:3000"\n    environment:\n      - NODE_ENV=development\n      - NEXT_PUBLIC_API_BASE_URL=http://localhost:3001\n      - NEXT_PUBLIC_ENVIRONMENT=development\n    depends_on:\n      - api-gateway\n    volumes:\n      - ./frontend:/app\n      - /app/node_modules\n      - /app/.next\n\nvolumes:\n  postgres_data:\n  redis_data:\n\nnetworks:\n  default:\n    driver: bridge\n'})}),"\n",(0,s.jsx)(n.h2,{id:"kubernetes-deployment-manifests",children:"Kubernetes Deployment Manifests"}),"\n",(0,s.jsx)(n.h3,{id:"nestjs-service-deployment",children:"NestJS Service Deployment"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# k8s/nestjs-service.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: user-service\n  namespace: microservices\n  labels:\n    app: user-service\n    version: v1\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 1\n  selector:\n    matchLabels:\n      app: user-service\n  template:\n    metadata:\n      labels:\n        app: user-service\n        version: v1\n      annotations:\n        prometheus.io/scrape: "true"\n        prometheus.io/port: "3000"\n        prometheus.io/path: "/metrics"\n    spec:\n      serviceAccountName: microservice-sa\n      containers:\n      - name: user-service\n        image: your-registry/user-service:latest\n        ports:\n        - containerPort: 3000\n          name: http\n        env:\n        - name: NODE_ENV\n          value: "production"\n        - name: PORT\n          value: "3000"\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: database-secret\n              key: url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: redis-secret\n              key: url\n        - name: JWT_SECRET\n          valueFrom:\n            secretKeyRef:\n              name: jwt-secret\n              key: secret\n        resources:\n          requests:\n            memory: "256Mi"\n            cpu: "100m"\n          limits:\n            memory: "512Mi"\n            cpu: "500m"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n          timeoutSeconds: 5\n          failureThreshold: 3\n        readinessProbe:\n          httpGet:\n            path: /health/ready\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n          timeoutSeconds: 3\n          failureThreshold: 3\n        securityContext:\n          runAsNonRoot: true\n          runAsUser: 1001\n          allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: true\n        volumeMounts:\n        - name: tmp\n          mountPath: /tmp\n        - name: app-cache\n          mountPath: /app/.cache\n      volumes:\n      - name: tmp\n        emptyDir: {}\n      - name: app-cache\n        emptyDir: {}\n      terminationGracePeriodSeconds: 30\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: user-service\n  namespace: microservices\n  labels:\n    app: user-service\nspec:\n  selector:\n    app: user-service\n  ports:\n  - port: 80\n    targetPort: 3000\n    protocol: TCP\n    name: http\n  type: ClusterIP\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: user-service-ingress\n  namespace: microservices\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n    nginx.ingress.kubernetes.io/rate-limit: "100"\n    nginx.ingress.kubernetes.io/rate-limit-window: "1m"\nspec:\n  tls:\n  - hosts:\n    - api.example.com\n    secretName: api-tls\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /users\n        pathType: Prefix\n        backend:\n          service:\n            name: user-service\n            port:\n              number: 80\n'})}),"\n",(0,s.jsx)(n.h3,{id:"nextjs-frontend-deployment",children:"Next.js Frontend Deployment"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# k8s/nextjs-frontend.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: frontend\n  namespace: frontend\n  labels:\n    app: frontend\n    version: v1\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 2\n      maxUnavailable: 1\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n        version: v1\n    spec:\n      serviceAccountName: frontend-sa\n      containers:\n      - name: frontend\n        image: your-registry/frontend:latest\n        ports:\n        - containerPort: 3000\n          name: http\n        env:\n        - name: NODE_ENV\n          value: "production"\n        - name: PORT\n          value: "3000"\n        - name: NEXT_PUBLIC_API_BASE_URL\n          valueFrom:\n            configMapKeyRef:\n              name: frontend-config\n              key: api-base-url\n        - name: NEXT_PUBLIC_ENVIRONMENT\n          value: "production"\n        resources:\n          requests:\n            memory: "128Mi"\n            cpu: "50m"\n          limits:\n            memory: "256Mi"\n            cpu: "200m"\n        livenessProbe:\n          httpGet:\n            path: /api/health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /api/health\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n        securityContext:\n          runAsNonRoot: true\n          runAsUser: 1001\n          allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: true\n        volumeMounts:\n        - name: tmp\n          mountPath: /tmp\n        - name: next-cache\n          mountPath: /app/.next/cache\n      volumes:\n      - name: tmp\n        emptyDir: {}\n      - name: next-cache\n        emptyDir: {}\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: frontend\n  namespace: frontend\n  labels:\n    app: frontend\nspec:\n  selector:\n    app: frontend\n  ports:\n  - port: 80\n    targetPort: 3000\n    protocol: TCP\n    name: http\n  type: ClusterIP\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: frontend-ingress\n  namespace: frontend\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n    nginx.ingress.kubernetes.io/enable-cors: "true"\n    nginx.ingress.kubernetes.io/cors-allow-origin: "*"\nspec:\n  tls:\n  - hosts:\n    - app.example.com\n    secretName: frontend-tls\n  rules:\n  - host: app.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend\n            port:\n              number: 80\n'})}),"\n",(0,s.jsx)(n.h2,{id:"gitops-with-argocd",children:"GitOps with ArgoCD"}),"\n",(0,s.jsx)(n.h3,{id:"argocd-application-configuration",children:"ArgoCD Application Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"# argocd/applications/user-service.yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: user-service\n  namespace: argocd\n  finalizers:\n    - resources-finalizer.argocd.argoproj.io\nspec:\n  project: microservices\n  source:\n    repoURL: https://github.com/your-org/microservices-gitops\n    targetRevision: HEAD\n    path: services/user-service/overlays/production\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: microservices\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n      allowEmpty: false\n    syncOptions:\n    - CreateNamespace=true\n    - PrunePropagationPolicy=foreground\n    - PruneLast=true\n    retry:\n      limit: 5\n      backoff:\n        duration: 5s\n        factor: 2\n        maxDuration: 3m\n  revisionHistoryLimit: 10\n  ignoreDifferences:\n  - group: apps\n    kind: Deployment\n    jsonPointers:\n    - /spec/replicas\n  info:\n  - name: Description\n    value: User service for microservices platform\n---\napiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\n  name: microservices\n  namespace: argocd\nspec:\n  description: Microservices project\n  sourceRepos:\n  - 'https://github.com/your-org/microservices-gitops'\n  destinations:\n  - namespace: microservices\n    server: https://kubernetes.default.svc\n  - namespace: frontend\n    server: https://kubernetes.default.svc\n  clusterResourceWhitelist:\n  - group: ''\n    kind: Namespace\n  - group: rbac.authorization.k8s.io\n    kind: ClusterRole\n  - group: rbac.authorization.k8s.io\n    kind: ClusterRoleBinding\n  namespaceResourceWhitelist:\n  - group: ''\n    kind: ConfigMap\n  - group: ''\n    kind: Secret\n  - group: ''\n    kind: Service\n  - group: apps\n    kind: Deployment\n  - group: networking.k8s.io\n    kind: Ingress\n  roles:\n  - name: developer\n    policies:\n    - p, proj:microservices:developer, applications, get, microservices/*, allow\n    - p, proj:microservices:developer, applications, sync, microservices/*, allow\n    groups:\n    - developers\n  - name: admin\n    policies:\n    - p, proj:microservices:admin, applications, *, microservices/*, allow\n    groups:\n    - platform-admins\n"})}),"\n",(0,s.jsx)(n.h3,{id:"kustomization-structure",children:"Kustomization Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"# kustomization/base/kustomization.yaml\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nresources:\n- deployment.yaml\n- service.yaml\n- configmap.yaml\n- secret.yaml\n\ncommonLabels:\n  app: user-service\n  tier: backend\n\nimages:\n- name: user-service\n  newTag: latest\n\nconfigMapGenerator:\n- name: user-service-config\n  literals:\n  - NODE_ENV=production\n  - LOG_LEVEL=info\n\nsecretGenerator:\n- name: user-service-secret\n  literals:\n  - database-url=placeholder\n  - jwt-secret=placeholder\n  type: Opaque\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"# kustomization/overlays/production/kustomization.yaml\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nbases:\n- ../../base\n\npatchesStrategicMerge:\n- replica-patch.yaml\n- resource-patch.yaml\n\nimages:\n- name: user-service\n  newTag: v1.2.3\n\nconfigMapGenerator:\n- name: user-service-config\n  behavior: merge\n  literals:\n  - NODE_ENV=production\n  - LOG_LEVEL=warn\n\nsecretGenerator:\n- name: user-service-secret\n  behavior: replace\n  envs:\n  - secrets.env\n"})}),"\n",(0,s.jsx)(n.h2,{id:"cicd-pipeline-configuration",children:"CI/CD Pipeline Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"github-actions-workflow",children:"GitHub Actions Workflow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"# .github/workflows/deploy.yml\nname: Deploy Microservices\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        service: [api-gateway, user-service, product-service, frontend]\n    \n    steps:\n    - name: Checkout\n      uses: actions/checkout@v4\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'pnpm'\n        cache-dependency-path: ${{ matrix.service }}/pnpm-lock.yaml\n\n    - name: Install dependencies\n      run: |\n        cd ${{ matrix.service }}\n        pnpm install --frozen-lockfile\n\n    - name: Run tests\n      run: |\n        cd ${{ matrix.service }}\n        pnpm run test\n        pnpm run test:e2e\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      with:\n        file: ${{ matrix.service }}/coverage/lcov.info\n        flags: ${{ matrix.service }}\n\n  build:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    strategy:\n      matrix:\n        service: [api-gateway, user-service, product-service, frontend]\n    \n    outputs:\n      image-tag: ${{ steps.meta.outputs.tags }}\n      image-digest: ${{ steps.build.outputs.digest }}\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v4\n\n    - name: Setup Docker Buildx\n      uses: docker/setup-buildx-action@v3\n\n    - name: Log in to Container Registry\n      uses: docker/login-action@v3\n      with:\n        registry: ${{ env.REGISTRY }}\n        username: ${{ github.actor }}\n        password: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Extract metadata\n      id: meta\n      uses: docker/metadata-action@v5\n      with:\n        images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.service }}\n        tags: |\n          type=ref,event=branch\n          type=ref,event=pr\n          type=sha,prefix={{branch}}-\n          type=raw,value=latest,enable={{is_default_branch}}\n\n    - name: Build and push Docker image\n      id: build\n      uses: docker/build-push-action@v5\n      with:\n        context: ${{ matrix.service }}\n        file: ${{ matrix.service }}/Dockerfile\n        push: true\n        tags: ${{ steps.meta.outputs.tags }}\n        labels: ${{ steps.meta.outputs.labels }}\n        cache-from: type=gha\n        cache-to: type=gha,mode=max\n        platforms: linux/amd64,linux/arm64\n\n    - name: Generate SBOM\n      uses: anchore/sbom-action@v0\n      with:\n        image: ${{ steps.meta.outputs.tags }}\n        format: spdx-json\n        output-file: ${{ matrix.service }}-sbom.spdx.json\n\n    - name: Upload SBOM\n      uses: actions/upload-artifact@v3\n      with:\n        name: ${{ matrix.service }}-sbom\n        path: ${{ matrix.service }}-sbom.spdx.json\n\n  security-scan:\n    needs: build\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        service: [api-gateway, user-service, product-service, frontend]\n    \n    steps:\n    - name: Run Trivy vulnerability scanner\n      uses: aquasecurity/trivy-action@master\n      with:\n        image-ref: ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.service }}:latest\n        format: 'sarif'\n        output: 'trivy-results.sarif'\n\n    - name: Upload Trivy scan results\n      uses: github/codeql-action/upload-sarif@v2\n      with:\n        sarif_file: 'trivy-results.sarif'\n\n  deploy-staging:\n    needs: [build, security-scan]\n    runs-on: ubuntu-latest\n    environment: staging\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - name: Checkout GitOps repo\n      uses: actions/checkout@v4\n      with:\n        repository: your-org/microservices-gitops\n        token: ${{ secrets.GITOPS_TOKEN }}\n        path: gitops\n\n    - name: Update staging manifests\n      run: |\n        cd gitops\n        \n        # Update image tags in staging overlays\n        for service in api-gateway user-service product-service frontend; do\n          kustomize edit set image $service=${{ env.REGISTRY }}/${{ github.repository }}/$service:${{ github.sha }}\n        done\n\n    - name: Commit and push changes\n      run: |\n        cd gitops\n        git config user.name \"github-actions[bot]\"\n        git config user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n        git add .\n        git commit -m \"Update staging deployment to ${{ github.sha }}\"\n        git push\n\n  deploy-production:\n    needs: deploy-staging\n    runs-on: ubuntu-latest\n    environment: production\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - name: Wait for staging deployment\n      run: sleep 300 # Wait 5 minutes for staging validation\n\n    - name: Checkout GitOps repo\n      uses: actions/checkout@v4\n      with:\n        repository: your-org/microservices-gitops\n        token: ${{ secrets.GITOPS_TOKEN }}\n        path: gitops\n\n    - name: Update production manifests\n      run: |\n        cd gitops\n        \n        # Update image tags in production overlays\n        for service in api-gateway user-service product-service frontend; do\n          cd services/$service/overlays/production\n          kustomize edit set image $service=${{ env.REGISTRY }}/${{ github.repository }}/$service:${{ github.sha }}\n          cd ../../../../\n        done\n\n    - name: Commit and push changes\n      run: |\n        cd gitops\n        git config user.name \"github-actions[bot]\"\n        git config user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n        git add .\n        git commit -m \"Update production deployment to ${{ github.sha }}\"\n        git push\n\n  notify:\n    needs: [deploy-production]\n    runs-on: ubuntu-latest\n    if: always()\n    \n    steps:\n    - name: Notify Slack\n      uses: 8398a7/action-slack@v3\n      with:\n        status: ${{ job.status }}\n        channel: '#deployments'\n        text: |\n          Deployment ${{ job.status }} for commit ${{ github.sha }}\n          Services: api-gateway, user-service, product-service, frontend\n      env:\n        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-deployment-strategies",children:"Advanced Deployment Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"blue-green-deployment",children:"Blue-Green Deployment"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# scripts/blue-green-deploy.sh\n#!/bin/bash\n\nset -euo pipefail\n\nSERVICE_NAME=$1\nNEW_VERSION=$2\nNAMESPACE=${3:-default}\n\necho "Starting blue-green deployment for $SERVICE_NAME:$NEW_VERSION"\n\n# Deploy green version\nkubectl apply -f - <<EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ${SERVICE_NAME}-green\n  namespace: $NAMESPACE\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: $SERVICE_NAME\n      version: green\n  template:\n    metadata:\n      labels:\n        app: $SERVICE_NAME\n        version: green\n    spec:\n      containers:\n      - name: $SERVICE_NAME\n        image: $SERVICE_NAME:$NEW_VERSION\n        ports:\n        - containerPort: 3000\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n        readinessProbe:\n          httpGet:\n            path: /health/ready\n            port: 3000\n          initialDelaySeconds: 5\nEOF\n\n# Wait for green deployment to be ready\necho "Waiting for green deployment to be ready..."\nkubectl rollout status deployment/${SERVICE_NAME}-green -n $NAMESPACE --timeout=300s\n\n# Run health checks\necho "Running health checks on green deployment..."\nGREEN_POD=$(kubectl get pods -n $NAMESPACE -l app=$SERVICE_NAME,version=green -o jsonpath=\'{.items[0].metadata.name}\')\nkubectl exec -n $NAMESPACE $GREEN_POD -- curl -f http://localhost:3000/health\n\n# Switch traffic to green\necho "Switching traffic to green deployment..."\nkubectl patch service $SERVICE_NAME -n $NAMESPACE -p \'{"spec":{"selector":{"version":"green"}}}\'\n\n# Wait for traffic switch\nsleep 30\n\n# Run post-deployment tests\necho "Running post-deployment tests..."\n./scripts/run-smoke-tests.sh $SERVICE_NAME $NAMESPACE\n\nif [ $? -eq 0 ]; then\n    echo "Deployment successful. Cleaning up blue deployment..."\n    kubectl delete deployment ${SERVICE_NAME}-blue -n $NAMESPACE --ignore-not-found=true\n    \n    # Rename green to blue for next deployment\n    kubectl patch deployment ${SERVICE_NAME}-green -n $NAMESPACE -p \'{"metadata":{"name":"\'${SERVICE_NAME}\'-blue"}}\'\n    kubectl patch deployment ${SERVICE_NAME}-blue -n $NAMESPACE -p \'{"spec":{"selector":{"matchLabels":{"version":"blue"}},"template":{"metadata":{"labels":{"version":"blue"}}}}}\'\n    kubectl patch service $SERVICE_NAME -n $NAMESPACE -p \'{"spec":{"selector":{"version":"blue"}}}\'\n    \n    echo "Blue-green deployment completed successfully!"\nelse\n    echo "Deployment failed. Rolling back to blue deployment..."\n    kubectl patch service $SERVICE_NAME -n $NAMESPACE -p \'{"spec":{"selector":{"version":"blue"}}}\'\n    kubectl delete deployment ${SERVICE_NAME}-green -n $NAMESPACE\n    exit 1\nfi\n'})}),"\n",(0,s.jsx)(n.h3,{id:"canary-deployment-with-flagger",children:"Canary Deployment with Flagger"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# flagger/canary.yaml\napiVersion: flagger.app/v1beta1\nkind: Canary\nmetadata:\n  name: user-service\n  namespace: microservices\nspec:\n  targetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: user-service\n  progressDeadlineSeconds: 60\n  service:\n    port: 80\n    targetPort: 3000\n    gateways:\n    - istio-system/gateway\n    hosts:\n    - api.example.com\n    trafficPolicy:\n      tls:\n        mode: DISABLE\n  analysis:\n    interval: 1m\n    threshold: 5\n    maxWeight: 50\n    stepWeight: 10\n    metrics:\n    - name: request-success-rate\n      thresholdRange:\n        min: 99\n      interval: 1m\n    - name: request-duration\n      thresholdRange:\n        max: 500\n      interval: 30s\n    - name: error-rate\n      thresholdRange:\n        max: 1\n      interval: 30s\n    webhooks:\n    - name: acceptance-test\n      type: pre-rollout\n      url: http://flagger-loadtester.test/\n      timeout: 30s\n      metadata:\n        type: bash\n        cmd: "curl -sd \'test\' http://user-service-canary.microservices/health"\n    - name: load-test\n      url: http://flagger-loadtester.test/\n      timeout: 5s\n      metadata:\n        cmd: "hey -z 1m -q 10 -c 2 http://user-service-canary.microservices/api/users"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"rollback-automation",children:"Rollback Automation"}),"\n",(0,s.jsx)(n.h3,{id:"automated-rollback-script",children:"Automated Rollback Script"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# scripts/auto-rollback.sh\n\nset -euo pipefail\n\nSERVICE_NAME=$1\nNAMESPACE=${2:-default}\nTHRESHOLD_ERROR_RATE=${3:-5} # 5% error rate threshold\nTHRESHOLD_RESPONSE_TIME=${4:-1000} # 1000ms response time threshold\n\necho "Monitoring $SERVICE_NAME for automatic rollback conditions..."\n\n# Function to get current error rate\nget_error_rate() {\n    kubectl exec -n monitoring deployment/prometheus -- \\\n        promtool query instant \\\n        \'rate(http_requests_total{service="\'$SERVICE_NAME\'",status=~"5.."}[5m]) / rate(http_requests_total{service="\'$SERVICE_NAME\'"}[5m]) * 100\' \\\n        | grep -o \'[0-9]*\\.[0-9]*\' || echo "0"\n}\n\n# Function to get current response time\nget_response_time() {\n    kubectl exec -n monitoring deployment/prometheus -- \\\n        promtool query instant \\\n        \'histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{service="\'$SERVICE_NAME\'"}[5m])) * 1000\' \\\n        | grep -o \'[0-9]*\\.[0-9]*\' || echo "0"\n}\n\n# Function to perform rollback\nperform_rollback() {\n    echo "ALERT: Performing automatic rollback for $SERVICE_NAME"\n    \n    # Get previous revision\n    PREVIOUS_REVISION=$(kubectl rollout history deployment/$SERVICE_NAME -n $NAMESPACE | tail -2 | head -1 | awk \'{print $1}\')\n    \n    # Rollback to previous revision\n    kubectl rollout undo deployment/$SERVICE_NAME -n $NAMESPACE --to-revision=$PREVIOUS_REVISION\n    \n    # Wait for rollback to complete\n    kubectl rollout status deployment/$SERVICE_NAME -n $NAMESPACE --timeout=300s\n    \n    # Send notification\n    curl -X POST $SLACK_WEBHOOK -H \'Content-type: application/json\' \\\n        --data \'{"text":"\ud83d\udea8 Automatic rollback performed for \'$SERVICE_NAME\' due to high error rate or response time"}\'\n    \n    echo "Rollback completed for $SERVICE_NAME"\n}\n\n# Monitor for 10 minutes\nEND_TIME=$((SECONDS + 600))\n\nwhile [ $SECONDS -lt $END_TIME ]; do\n    ERROR_RATE=$(get_error_rate)\n    RESPONSE_TIME=$(get_response_time)\n    \n    echo "Current metrics - Error Rate: ${ERROR_RATE}%, Response Time: ${RESPONSE_TIME}ms"\n    \n    # Check if rollback conditions are met\n    if (( $(echo "$ERROR_RATE > $THRESHOLD_ERROR_RATE" | bc -l) )) || \\\n       (( $(echo "$RESPONSE_TIME > $THRESHOLD_RESPONSE_TIME" | bc -l) )); then\n        perform_rollback\n        exit 0\n    fi\n    \n    sleep 30\ndone\n\necho "Monitoring completed. No rollback required for $SERVICE_NAME"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"deployment-health-checks",children:"Deployment Health Checks"}),"\n",(0,s.jsx)(n.h3,{id:"comprehensive-health-check-service",children:"Comprehensive Health Check Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/health/health.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { \n  HealthCheckService,\n  HealthCheck,\n  TypeOrmHealthIndicator,\n  MemoryHealthIndicator,\n  DiskHealthIndicator,\n} from '@nestjs/terminus';\nimport { ConfigService } from '@nestjs/config';\nimport { RedisHealthIndicator } from './redis-health.indicator';\nimport { ExternalServiceHealthIndicator } from './external-service-health.indicator';\n\n@Controller('health')\nexport class HealthController {\n  constructor(\n    private health: HealthCheckService,\n    private db: TypeOrmHealthIndicator,\n    private memory: MemoryHealthIndicator,\n    private disk: DiskHealthIndicator,\n    private redis: RedisHealthIndicator,\n    private externalService: ExternalServiceHealthIndicator,\n    private configService: ConfigService,\n  ) {}\n\n  @Get()\n  @HealthCheck()\n  check() {\n    return this.health.check([\n      // Database health\n      () => this.db.pingCheck('database'),\n      \n      // Redis health\n      () => this.redis.pingCheck('redis'),\n      \n      // Memory health (less than 150MB)\n      () => this.memory.checkHeap('memory_heap', 150 * 1024 * 1024),\n      () => this.memory.checkRSS('memory_rss', 150 * 1024 * 1024),\n      \n      // Disk health (less than 80% usage)\n      () => this.disk.checkStorage('storage', { \n        threshold: 0.8, \n        path: '/' \n      }),\n      \n      // External service health\n      () => this.externalService.pingCheck('external_api', {\n        url: this.configService.get('EXTERNAL_API_URL'),\n        timeout: 5000,\n      }),\n    ]);\n  }\n\n  @Get('ready')\n  @HealthCheck()\n  readiness() {\n    return this.health.check([\n      () => this.db.pingCheck('database'),\n      () => this.redis.pingCheck('redis'),\n    ]);\n  }\n\n  @Get('live')\n  @HealthCheck()\n  liveness() {\n    return this.health.check([\n      () => this.memory.checkHeap('memory_heap', 200 * 1024 * 1024),\n    ]);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline",children:"CI/CD Pipeline"})})," - Continuous integration and delivery setup"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/infrastructure-monitoring",children:"Infrastructure Monitoring"})})," - Deployment monitoring and alerting"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/configuration-management",children:"Configuration Management"})})," - Environment-specific configurations"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"This automated deployment guide should be regularly updated to incorporate new deployment strategies and platform features."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},5741:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(9729);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);