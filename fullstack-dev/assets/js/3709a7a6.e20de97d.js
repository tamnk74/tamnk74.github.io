"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[9965],{5709:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"architecture-practices/architecture-definition/third-party-integration","title":"Third-Party Integration Strategy","description":"This guide provides comprehensive strategies for integrating with third-party services in NestJS microservices and Next.js microfrontend applications, focusing on reliability, security, and maintainability.","source":"@site/docs/architecture-practices/architecture-definition/third-party-integration.md","sourceDirName":"architecture-practices/architecture-definition","slug":"/architecture-practices/architecture-definition/third-party-integration","permalink":"/fullstack-dev/docs/architecture-practices/architecture-definition/third-party-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/tamnk74/fullstack-dev/tree/main/docs-site/docs/architecture-practices/architecture-definition/third-party-integration.md","tags":[],"version":"current","frontMatter":{}}');var i=t(5813),a=t(7814);const o={},s="Third-Party Integration Strategy",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Integration Architecture",id:"integration-architecture",level:2},{value:"Service Integration Patterns",id:"service-integration-patterns",level:3},{value:"NestJS Third-Party Integration",id:"nestjs-third-party-integration",level:2},{value:"HTTP Client Configuration",id:"http-client-configuration",level:3},{value:"Circuit Breaker Implementation",id:"circuit-breaker-implementation",level:3},{value:"Payment Service Integration Example",id:"payment-service-integration-example",level:3},{value:"API Rate Limiting",id:"api-rate-limiting",level:3},{value:"Next.js Client Integration",id:"nextjs-client-integration",level:2},{value:"API Client Hook",id:"api-client-hook",level:3},{value:"Third-Party SDK Integration",id:"third-party-sdk-integration",level:3},{value:"Error Boundary for Third-Party Components",id:"error-boundary-for-third-party-components",level:3},{value:"Integration Testing",id:"integration-testing",level:2},{value:"API Integration Tests",id:"api-integration-tests",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"API Key Management",id:"api-key-management",level:3},{value:"Monitoring and Observability",id:"monitoring-and-observability",level:2},{value:"Integration Metrics",id:"integration-metrics",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"third-party-integration-strategy",children:"Third-Party Integration Strategy"})}),"\n",(0,i.jsx)(n.p,{children:"This guide provides comprehensive strategies for integrating with third-party services in NestJS microservices and Next.js microfrontend applications, focusing on reliability, security, and maintainability."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Third-party integrations are critical components that require careful planning, robust error handling, and comprehensive monitoring. This guide covers integration patterns, security practices, and operational considerations for building resilient external service connections."}),"\n",(0,i.jsx)(n.h2,{id:"integration-architecture",children:"Integration Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"service-integration-patterns",children:"Service Integration Patterns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Application] --\x3e B[Integration Gateway]\n    B --\x3e C[Circuit Breaker]\n    C --\x3e D[Rate Limiter]\n    D --\x3e E[Request Validator]\n    E --\x3e F[HTTP Client]\n    F --\x3e G[Third-Party Service]\n    \n    B --\x3e H[Fallback Handler]\n    B --\x3e I[Cache Layer]\n    B --\x3e J[Retry Mechanism]\n    \n    K[Monitoring] --\x3e B\n    L[Logging] --\x3e B\n    M[Metrics] --\x3e B\n"})}),"\n",(0,i.jsx)(n.h2,{id:"nestjs-third-party-integration",children:"NestJS Third-Party Integration"}),"\n",(0,i.jsx)(n.h3,{id:"http-client-configuration",children:"HTTP Client Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/integrations/http/http-client.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { HttpService } from '@nestjs/axios';\nimport { ConfigService } from '@nestjs/config';\nimport { Observable, throwError, of } from 'rxjs';\nimport { retry, catchError, timeout, map } from 'rxjs/operators';\nimport { AxiosResponse, AxiosRequestConfig } from 'axios';\n\nexport interface HttpClientOptions {\n  baseURL: string;\n  timeout: number;\n  retries: number;\n  retryDelay: number;\n  headers?: Record<string, string>;\n  auth?: {\n    type: 'bearer' | 'basic' | 'apikey';\n    token?: string;\n    username?: string;\n    password?: string;\n    apiKey?: string;\n    apiKeyHeader?: string;\n  };\n}\n\n@Injectable()\nexport class HttpClientService {\n  private readonly logger = new Logger(HttpClientService.name);\n\n  constructor(\n    private readonly httpService: HttpService,\n    private readonly configService: ConfigService,\n  ) {}\n\n  createClient(options: HttpClientOptions) {\n    const config: AxiosRequestConfig = {\n      baseURL: options.baseURL,\n      timeout: options.timeout,\n      headers: {\n        'Content-Type': 'application/json',\n        'User-Agent': 'MyApp/1.0.0',\n        ...options.headers,\n      },\n    };\n\n    // Configure authentication\n    if (options.auth) {\n      switch (options.auth.type) {\n        case 'bearer':\n          config.headers.Authorization = `Bearer ${options.auth.token}`;\n          break;\n        case 'basic':\n          const basicAuth = Buffer.from(\n            `${options.auth.username}:${options.auth.password}`\n          ).toString('base64');\n          config.headers.Authorization = `Basic ${basicAuth}`;\n          break;\n        case 'apikey':\n          const headerName = options.auth.apiKeyHeader || 'X-API-Key';\n          config.headers[headerName] = options.auth.apiKey;\n          break;\n      }\n    }\n\n    return {\n      get: <T>(url: string, config?: AxiosRequestConfig) =>\n        this.makeRequest<T>('get', url, undefined, { ...config, ...options }),\n      \n      post: <T>(url: string, data?: any, config?: AxiosRequestConfig) =>\n        this.makeRequest<T>('post', url, data, { ...config, ...options }),\n      \n      put: <T>(url: string, data?: any, config?: AxiosRequestConfig) =>\n        this.makeRequest<T>('put', url, data, { ...config, ...options }),\n      \n      delete: <T>(url: string, config?: AxiosRequestConfig) =>\n        this.makeRequest<T>('delete', url, undefined, { ...config, ...options }),\n    };\n  }\n\n  private makeRequest<T>(\n    method: 'get' | 'post' | 'put' | 'delete',\n    url: string,\n    data?: any,\n    options?: HttpClientOptions & AxiosRequestConfig,\n  ): Observable<T> {\n    const startTime = Date.now();\n    \n    let request: Observable<AxiosResponse<T>>;\n    \n    switch (method) {\n      case 'get':\n        request = this.httpService.get<T>(url, options);\n        break;\n      case 'post':\n        request = this.httpService.post<T>(url, data, options);\n        break;\n      case 'put':\n        request = this.httpService.put<T>(url, data, options);\n        break;\n      case 'delete':\n        request = this.httpService.delete<T>(url, options);\n        break;\n    }\n\n    return request.pipe(\n      timeout(options?.timeout || 30000),\n      retry({\n        count: options?.retries || 3,\n        delay: (error, retryCount) => {\n          const delay = options?.retryDelay || 1000;\n          this.logger.warn(\n            `Request failed, retrying (${retryCount}/${options?.retries || 3}) after ${delay}ms`,\n            { url, method, error: error.message }\n          );\n          return of(null).pipe(timeout(delay * retryCount));\n        },\n      }),\n      map(response => {\n        const duration = Date.now() - startTime;\n        this.logger.log(\n          `Request completed: ${method.toUpperCase()} ${url} (${response.status}) in ${duration}ms`\n        );\n        return response.data;\n      }),\n      catchError(error => {\n        const duration = Date.now() - startTime;\n        this.logger.error(\n          `Request failed: ${method.toUpperCase()} ${url} after ${duration}ms`,\n          error.response?.data || error.message\n        );\n        return throwError(() => error);\n      }),\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"circuit-breaker-implementation",children:"Circuit Breaker Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/integrations/circuit-breaker/circuit-breaker.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Observable, throwError, of } from 'rxjs';\nimport { catchError, tap } from 'rxjs/operators';\n\nexport enum CircuitState {\n  CLOSED = 'CLOSED',\n  OPEN = 'OPEN',\n  HALF_OPEN = 'HALF_OPEN',\n}\n\nexport interface CircuitBreakerOptions {\n  failureThreshold: number;\n  recoveryTimeout: number;\n  monitoringPeriod: number;\n  fallbackEnabled: boolean;\n}\n\ninterface CircuitBreakerMetrics {\n  failures: number;\n  successes: number;\n  lastFailureTime: number;\n  state: CircuitState;\n}\n\n@Injectable()\nexport class CircuitBreakerService {\n  private readonly logger = new Logger(CircuitBreakerService.name);\n  private readonly circuits = new Map<string, CircuitBreakerMetrics>();\n\n  createCircuit(\n    name: string,\n    options: CircuitBreakerOptions,\n  ): <T>(operation: () => Observable<T>, fallback?: () => Observable<T>) => Observable<T> {\n    \n    if (!this.circuits.has(name)) {\n      this.circuits.set(name, {\n        failures: 0,\n        successes: 0,\n        lastFailureTime: 0,\n        state: CircuitState.CLOSED,\n      });\n    }\n\n    return <T>(\n      operation: () => Observable<T>,\n      fallback?: () => Observable<T>,\n    ): Observable<T> => {\n      const circuit = this.circuits.get(name)!;\n      \n      // Check if circuit should transition from OPEN to HALF_OPEN\n      if (\n        circuit.state === CircuitState.OPEN &&\n        Date.now() - circuit.lastFailureTime > options.recoveryTimeout\n      ) {\n        circuit.state = CircuitState.HALF_OPEN;\n        this.logger.log(`Circuit breaker ${name} transitioning to HALF_OPEN`);\n      }\n\n      // Reject if circuit is OPEN\n      if (circuit.state === CircuitState.OPEN) {\n        this.logger.warn(`Circuit breaker ${name} is OPEN, rejecting request`);\n        \n        if (fallback && options.fallbackEnabled) {\n          return fallback();\n        }\n        \n        return throwError(() => new Error(`Circuit breaker ${name} is OPEN`));\n      }\n\n      return operation().pipe(\n        tap(() => {\n          // Record success\n          circuit.successes++;\n          \n          if (circuit.state === CircuitState.HALF_OPEN) {\n            circuit.state = CircuitState.CLOSED;\n            circuit.failures = 0;\n            this.logger.log(`Circuit breaker ${name} recovered to CLOSED`);\n          }\n        }),\n        catchError(error => {\n          // Record failure\n          circuit.failures++;\n          circuit.lastFailureTime = Date.now();\n\n          // Check if we should open the circuit\n          if (circuit.failures >= options.failureThreshold) {\n            circuit.state = CircuitState.OPEN;\n            this.logger.error(\n              `Circuit breaker ${name} opened after ${circuit.failures} failures`\n            );\n          }\n\n          // Use fallback if available and enabled\n          if (fallback && options.fallbackEnabled) {\n            return fallback();\n          }\n\n          return throwError(() => error);\n        }),\n      );\n    };\n  }\n\n  getCircuitStatus(name: string): CircuitBreakerMetrics | null {\n    return this.circuits.get(name) || null;\n  }\n\n  resetCircuit(name: string): void {\n    const circuit = this.circuits.get(name);\n    if (circuit) {\n      circuit.failures = 0;\n      circuit.successes = 0;\n      circuit.state = CircuitState.CLOSED;\n      circuit.lastFailureTime = 0;\n      this.logger.log(`Circuit breaker ${name} manually reset`);\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"payment-service-integration-example",children:"Payment Service Integration Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/integrations/payment/stripe-payment.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Observable, from, of } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\nimport Stripe from 'stripe';\n\nexport interface PaymentIntent {\n  id: string;\n  amount: number;\n  currency: string;\n  status: string;\n  clientSecret: string;\n}\n\nexport interface CreatePaymentIntentDto {\n  amount: number;\n  currency: string;\n  customerId?: string;\n  metadata?: Record<string, string>;\n}\n\n@Injectable()\nexport class StripePaymentService {\n  private readonly logger = new Logger(StripePaymentService.name);\n  private readonly stripe: Stripe;\n  private readonly circuit: ReturnType<CircuitBreakerService['createCircuit']>;\n\n  constructor(\n    private readonly configService: ConfigService,\n    private readonly circuitBreaker: CircuitBreakerService,\n    private readonly httpClient: HttpClientService,\n  ) {\n    this.stripe = new Stripe(\n      this.configService.get<string>('STRIPE_SECRET_KEY')!,\n      {\n        apiVersion: '2023-10-16',\n        timeout: 30000,\n        maxNetworkRetries: 3,\n      }\n    );\n\n    // Configure circuit breaker for Stripe API\n    this.circuit = this.circuitBreaker.createCircuit('stripe-api', {\n      failureThreshold: 5,\n      recoveryTimeout: 30000, // 30 seconds\n      monitoringPeriod: 60000, // 1 minute\n      fallbackEnabled: true,\n    });\n  }\n\n  createPaymentIntent(data: CreatePaymentIntentDto): Observable<PaymentIntent> {\n    const operation = () => from(\n      this.stripe.paymentIntents.create({\n        amount: data.amount,\n        currency: data.currency,\n        customer: data.customerId,\n        metadata: data.metadata,\n        automatic_payment_methods: {\n          enabled: true,\n        },\n      })\n    ).pipe(\n      map(intent => ({\n        id: intent.id,\n        amount: intent.amount,\n        currency: intent.currency,\n        status: intent.status,\n        clientSecret: intent.client_secret!,\n      }))\n    );\n\n    const fallback = () => {\n      this.logger.warn('Stripe service unavailable, using fallback payment processor');\n      // Implement fallback to secondary payment processor\n      return this.createPaymentIntentFallback(data);\n    };\n\n    return this.circuit(operation, fallback);\n  }\n\n  confirmPaymentIntent(paymentIntentId: string): Observable<PaymentIntent> {\n    const operation = () => from(\n      this.stripe.paymentIntents.confirm(paymentIntentId)\n    ).pipe(\n      map(intent => ({\n        id: intent.id,\n        amount: intent.amount,\n        currency: intent.currency,\n        status: intent.status,\n        clientSecret: intent.client_secret!,\n      }))\n    );\n\n    return this.circuit(operation);\n  }\n\n  private createPaymentIntentFallback(data: CreatePaymentIntentDto): Observable<PaymentIntent> {\n    // Implement fallback payment processor (e.g., PayPal, Square)\n    return of({\n      id: `fallback_${Date.now()}`,\n      amount: data.amount,\n      currency: data.currency,\n      status: 'requires_payment_method',\n      clientSecret: 'fallback_client_secret',\n    });\n  }\n\n  // Webhook handling for Stripe events\n  handleWebhook(payload: string, signature: string): Observable<void> {\n    const operation = () => {\n      try {\n        const event = this.stripe.webhooks.constructEvent(\n          payload,\n          signature,\n          this.configService.get<string>('STRIPE_WEBHOOK_SECRET')!\n        );\n\n        return from(this.processWebhookEvent(event));\n      } catch (error) {\n        this.logger.error('Webhook signature verification failed', error);\n        throw error;\n      }\n    };\n\n    return this.circuit(operation);\n  }\n\n  private async processWebhookEvent(event: Stripe.Event): Promise<void> {\n    this.logger.log(`Processing Stripe webhook event: ${event.type}`);\n\n    switch (event.type) {\n      case 'payment_intent.succeeded':\n        await this.handlePaymentSuccess(event.data.object as Stripe.PaymentIntent);\n        break;\n      case 'payment_intent.payment_failed':\n        await this.handlePaymentFailure(event.data.object as Stripe.PaymentIntent);\n        break;\n      default:\n        this.logger.log(`Unhandled event type: ${event.type}`);\n    }\n  }\n\n  private async handlePaymentSuccess(paymentIntent: Stripe.PaymentIntent): Promise<void> {\n    // Update order status, send confirmation email, etc.\n    this.logger.log(`Payment succeeded for intent: ${paymentIntent.id}`);\n  }\n\n  private async handlePaymentFailure(paymentIntent: Stripe.PaymentIntent): Promise<void> {\n    // Handle payment failure, notify user, etc.\n    this.logger.error(`Payment failed for intent: ${paymentIntent.id}`);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"api-rate-limiting",children:"API Rate Limiting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/integrations/rate-limit/rate-limit.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Redis } from 'ioredis';\n\nexport interface RateLimitOptions {\n  windowMs: number;\n  maxRequests: number;\n  keyGenerator?: (context: any) => string;\n}\n\nexport interface RateLimitResult {\n  allowed: boolean;\n  remaining: number;\n  resetTime: number;\n}\n\n@Injectable()\nexport class RateLimitService {\n  private readonly logger = new Logger(RateLimitService.name);\n\n  constructor(private readonly redis: Redis) {}\n\n  async checkRateLimit(\n    key: string,\n    options: RateLimitOptions,\n  ): Promise<RateLimitResult> {\n    const now = Date.now();\n    const window = Math.floor(now / options.windowMs);\n    const redisKey = `rate_limit:${key}:${window}`;\n\n    try {\n      const current = await this.redis.incr(redisKey);\n      \n      if (current === 1) {\n        // Set expiration for the first request in this window\n        await this.redis.expire(redisKey, Math.ceil(options.windowMs / 1000));\n      }\n\n      const allowed = current <= options.maxRequests;\n      const remaining = Math.max(0, options.maxRequests - current);\n      const resetTime = (window + 1) * options.windowMs;\n\n      if (!allowed) {\n        this.logger.warn(`Rate limit exceeded for key: ${key}`);\n      }\n\n      return {\n        allowed,\n        remaining,\n        resetTime,\n      };\n    } catch (error) {\n      this.logger.error('Rate limit check failed', error);\n      // Fail open - allow request if Redis is unavailable\n      return {\n        allowed: true,\n        remaining: options.maxRequests,\n        resetTime: now + options.windowMs,\n      };\n    }\n  }\n\n  async resetRateLimit(key: string): Promise<void> {\n    try {\n      const pattern = `rate_limit:${key}:*`;\n      const keys = await this.redis.keys(pattern);\n      \n      if (keys.length > 0) {\n        await this.redis.del(...keys);\n        this.logger.log(`Rate limit reset for key: ${key}`);\n      }\n    } catch (error) {\n      this.logger.error('Rate limit reset failed', error);\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"nextjs-client-integration",children:"Next.js Client Integration"}),"\n",(0,i.jsx)(n.h3,{id:"api-client-hook",children:"API Client Hook"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// hooks/use-api-client.ts\nimport { useState, useCallback, useRef } from 'react';\nimport { useAuth } from './use-auth';\n\ninterface ApiClientOptions {\n  baseURL: string;\n  timeout?: number;\n  retries?: number;\n}\n\ninterface ApiResponse<T> {\n  data: T | null;\n  error: string | null;\n  loading: boolean;\n}\n\nexport const useApiClient = (options: ApiClientOptions) => {\n  const { token } = useAuth();\n  const abortControllerRef = useRef<AbortController>();\n\n  const createRequest = useCallback(\n    async <T>(\n      endpoint: string,\n      config: RequestInit = {}\n    ): Promise<T> => {\n      // Cancel previous request\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n\n      abortControllerRef.current = new AbortController();\n\n      const url = `${options.baseURL}${endpoint}`;\n      const timeout = options.timeout || 30000;\n      \n      const requestConfig: RequestInit = {\n        ...config,\n        signal: abortControllerRef.current.signal,\n        headers: {\n          'Content-Type': 'application/json',\n          ...(token && { Authorization: `Bearer ${token}` }),\n          ...config.headers,\n        },\n      };\n\n      // Add timeout\n      const timeoutId = setTimeout(() => {\n        abortControllerRef.current?.abort();\n      }, timeout);\n\n      try {\n        const response = await fetch(url, requestConfig);\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const contentType = response.headers.get('content-type');\n        if (contentType?.includes('application/json')) {\n          return await response.json();\n        }\n\n        return await response.text() as unknown as T;\n      } catch (error) {\n        clearTimeout(timeoutId);\n        \n        if (error instanceof Error && error.name === 'AbortError') {\n          throw new Error('Request timeout');\n        }\n        \n        throw error;\n      }\n    },\n    [options.baseURL, options.timeout, token]\n  );\n\n  const useRequest = <T>(\n    endpoint: string,\n    config: RequestInit = {}\n  ): [ApiResponse<T>, () => Promise<void>] => {\n    const [response, setResponse] = useState<ApiResponse<T>>({\n      data: null,\n      error: null,\n      loading: false,\n    });\n\n    const execute = useCallback(async () => {\n      setResponse(prev => ({ ...prev, loading: true, error: null }));\n\n      try {\n        const data = await createRequest<T>(endpoint, config);\n        setResponse({ data, error: null, loading: false });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        setResponse({ data: null, error: errorMessage, loading: false });\n      }\n    }, [endpoint, config]);\n\n    return [response, execute];\n  };\n\n  return {\n    get: <T>(endpoint: string) => createRequest<T>(endpoint, { method: 'GET' }),\n    post: <T>(endpoint: string, data?: any) =>\n      createRequest<T>(endpoint, {\n        method: 'POST',\n        body: data ? JSON.stringify(data) : undefined,\n      }),\n    put: <T>(endpoint: string, data?: any) =>\n      createRequest<T>(endpoint, {\n        method: 'PUT',\n        body: data ? JSON.stringify(data) : undefined,\n      }),\n    delete: <T>(endpoint: string) => createRequest<T>(endpoint, { method: 'DELETE' }),\n    useRequest,\n  };\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"third-party-sdk-integration",children:"Third-Party SDK Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// components/payment/stripe-payment-form.tsx\nimport React, { useState, useEffect } from 'react';\nimport {\n  Elements,\n  CardElement,\n  useStripe,\n  useElements,\n} from '@stripe/react-stripe-js';\nimport { loadStripe } from '@stripe/stripe-js';\n\nconst stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!);\n\ninterface PaymentFormProps {\n  amount: number;\n  currency: string;\n  onSuccess: (paymentIntent: any) => void;\n  onError: (error: string) => void;\n}\n\nconst PaymentForm: React.FC<PaymentFormProps> = ({\n  amount,\n  currency,\n  onSuccess,\n  onError,\n}) => {\n  const stripe = useStripe();\n  const elements = useElements();\n  const [clientSecret, setClientSecret] = useState<string>();\n  const [processing, setProcessing] = useState(false);\n  const apiClient = useApiClient({ baseURL: '/api' });\n\n  useEffect(() => {\n    // Create payment intent\n    const createPaymentIntent = async () => {\n      try {\n        const { clientSecret } = await apiClient.post<{ clientSecret: string }>(\n          '/payments/create-intent',\n          { amount, currency }\n        );\n        setClientSecret(clientSecret);\n      } catch (error) {\n        onError('Failed to initialize payment');\n      }\n    };\n\n    createPaymentIntent();\n  }, [amount, currency]);\n\n  const handleSubmit = async (event: React.FormEvent) => {\n    event.preventDefault();\n\n    if (!stripe || !elements || !clientSecret) {\n      return;\n    }\n\n    setProcessing(true);\n\n    const cardElement = elements.getElement(CardElement);\n    if (!cardElement) {\n      onError('Card element not found');\n      setProcessing(false);\n      return;\n    }\n\n    try {\n      const { error, paymentIntent } = await stripe.confirmCardPayment(\n        clientSecret,\n        {\n          payment_method: {\n            card: cardElement,\n          },\n        }\n      );\n\n      if (error) {\n        onError(error.message || 'Payment failed');\n      } else if (paymentIntent.status === 'succeeded') {\n        onSuccess(paymentIntent);\n      }\n    } catch (error) {\n      onError('Payment processing failed');\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"space-y-4\">\n      <div className=\"p-4 border rounded-md\">\n        <CardElement\n          options={{\n            style: {\n              base: {\n                fontSize: '16px',\n                color: '#424770',\n                '::placeholder': {\n                  color: '#aab7c4',\n                },\n              },\n            },\n          }}\n        />\n      </div>\n      \n      <button\n        type=\"submit\"\n        disabled={!stripe || processing}\n        className=\"w-full py-2 px-4 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50\"\n      >\n        {processing ? 'Processing...' : `Pay $${(amount / 100).toFixed(2)}`}\n      </button>\n    </form>\n  );\n};\n\nexport const StripePaymentForm: React.FC<PaymentFormProps> = (props) => {\n  return (\n    <Elements stripe={stripePromise}>\n      <PaymentForm {...props} />\n    </Elements>\n  );\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"error-boundary-for-third-party-components",children:"Error Boundary for Third-Party Components"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// components/error-boundary/third-party-error-boundary.tsx\nimport React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n  serviceName?: string;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nexport class ThirdPartyErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error(`Third-party service error (${this.props.serviceName}):`, error);\n    \n    // Log error to monitoring service\n    if (this.props.onError) {\n      this.props.onError(error, errorInfo);\n    }\n\n    // Report to error tracking service\n    if (typeof window !== 'undefined' && window.Sentry) {\n      window.Sentry.captureException(error, {\n        tags: {\n          component: 'ThirdPartyErrorBoundary',\n          service: this.props.serviceName,\n        },\n        extra: errorInfo,\n      });\n    }\n  }\n\n  render() {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div className=\"p-4 border border-red-200 rounded-md bg-red-50\">\n          <h3 className=\"text-lg font-medium text-red-800\">\n            Service Temporarily Unavailable\n          </h3>\n          <p className=\"mt-2 text-red-600\">\n            {this.props.serviceName ? \n              `The ${this.props.serviceName} service is currently experiencing issues.` :\n              'This service is currently experiencing issues.'\n            } Please try again later.\n          </p>\n          <button\n            onClick={() => this.setState({ hasError: false, error: undefined })}\n            className=\"mt-3 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\"\n          >\n            Try Again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,i.jsx)(n.h3,{id:"api-integration-tests",children:"API Integration Tests"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/integrations/payment/stripe-payment.service.spec.ts\ndescribe('StripePaymentService', () => {\n  let service: StripePaymentService;\n  let circuitBreaker: CircuitBreakerService;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        StripePaymentService,\n        CircuitBreakerService,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn().mockImplementation((key: string) => {\n              const config = {\n                STRIPE_SECRET_KEY: 'sk_test_mock_key',\n                STRIPE_WEBHOOK_SECRET: 'whsec_mock_secret',\n              };\n              return config[key];\n            }),\n          },\n        },\n      ],\n    }).compile();\n\n    service = module.get<StripePaymentService>(StripePaymentService);\n    circuitBreaker = module.get<CircuitBreakerService>(CircuitBreakerService);\n  });\n\n  describe('createPaymentIntent', () => {\n    it('should create payment intent successfully', async () => {\n      const mockData = {\n        amount: 2000,\n        currency: 'usd',\n        customerId: 'cus_123',\n      };\n\n      const result = await service.createPaymentIntent(mockData).toPromise();\n\n      expect(result).toBeDefined();\n      expect(result.amount).toBe(2000);\n      expect(result.currency).toBe('usd');\n    });\n\n    it('should use fallback when circuit breaker is open', async () => {\n      // Simulate circuit breaker opening\n      jest.spyOn(circuitBreaker, 'createCircuit').mockReturnValue(\n        jest.fn().mockImplementation((operation, fallback) => fallback())\n      );\n\n      const mockData = {\n        amount: 2000,\n        currency: 'usd',\n      };\n\n      const result = await service.createPaymentIntent(mockData).toPromise();\n\n      expect(result.id).toContain('fallback_');\n    });\n  });\n\n  describe('webhook handling', () => {\n    it('should process payment success webhook', async () => {\n      const mockPayload = JSON.stringify({\n        type: 'payment_intent.succeeded',\n        data: {\n          object: {\n            id: 'pi_123',\n            amount: 2000,\n            currency: 'usd',\n            status: 'succeeded',\n          },\n        },\n      });\n\n      const mockSignature = 'test_signature';\n\n      await expect(\n        service.handleWebhook(mockPayload, mockSignature).toPromise()\n      ).resolves.not.toThrow();\n    });\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"api-key-management",children:"API Key Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/config/secrets.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class SecretsService {\n  constructor(private readonly configService: ConfigService) {}\n\n  getApiKey(service: string): string {\n    const key = this.configService.get<string>(`${service.toUpperCase()}_API_KEY`);\n    \n    if (!key) {\n      throw new Error(`API key for ${service} not configured`);\n    }\n\n    // Validate key format\n    if (!this.validateApiKeyFormat(service, key)) {\n      throw new Error(`Invalid API key format for ${service}`);\n    }\n\n    return key;\n  }\n\n  private validateApiKeyFormat(service: string, key: string): boolean {\n    const patterns = {\n      stripe: /^sk_(test|live)_[a-zA-Z0-9]{24,}$/,\n      paypal: /^[A-Z0-9]{80}$/,\n      sendgrid: /^SG\\.[a-zA-Z0-9_-]{22}\\.[a-zA-Z0-9_-]{43}$/,\n    };\n\n    const pattern = patterns[service.toLowerCase()];\n    return pattern ? pattern.test(key) : true;\n  }\n\n  rotateApiKey(service: string, newKey: string): void {\n    // Implement key rotation logic\n    // 1. Validate new key\n    // 2. Test with new key\n    // 3. Update configuration\n    // 4. Invalidate old key\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"monitoring-and-observability",children:"Monitoring and Observability"}),"\n",(0,i.jsx)(n.h3,{id:"integration-metrics",children:"Integration Metrics"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/monitoring/integration-metrics.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Counter, Histogram, register } from 'prom-client';\n\n@Injectable()\nexport class IntegrationMetricsService {\n  private readonly logger = new Logger(IntegrationMetricsService.name);\n\n  private readonly requestCounter = new Counter({\n    name: 'integration_requests_total',\n    help: 'Total number of integration requests',\n    labelNames: ['service', 'method', 'status'],\n    registers: [register],\n  });\n\n  private readonly requestDuration = new Histogram({\n    name: 'integration_request_duration_seconds',\n    help: 'Duration of integration requests',\n    labelNames: ['service', 'method'],\n    buckets: [0.1, 0.5, 1, 2, 5, 10],\n    registers: [register],\n  });\n\n  private readonly circuitBreakerState = new Counter({\n    name: 'circuit_breaker_state_changes_total',\n    help: 'Total number of circuit breaker state changes',\n    labelNames: ['service', 'from_state', 'to_state'],\n    registers: [register],\n  });\n\n  recordRequest(service: string, method: string, status: string): void {\n    this.requestCounter.inc({ service, method, status });\n  }\n\n  recordDuration(service: string, method: string, duration: number): void {\n    this.requestDuration.observe({ service, method }, duration);\n  }\n\n  recordCircuitBreakerStateChange(\n    service: string,\n    fromState: string,\n    toState: string,\n  ): void {\n    this.circuitBreakerState.inc({ service, from_state: fromState, to_state: toState });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-definition/code-quality-tools",children:"Code Quality Tools"})})," - Testing and quality assurance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-definition/dev-environment-setup",children:"Development Environment Setup"})})," - Development configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/fullstack-dev/docs/architecture-practices/architecture-execution/cicd-pipeline",children:"CI/CD Pipeline"})})," - Deployment and monitoring"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"This third-party integration strategy should be regularly updated to include new services and security requirements."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},7814:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var r=t(9729);const i={},a=r.createContext(i);function o(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);